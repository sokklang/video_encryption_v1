{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n  RBSP_TRAILING_BITS = 128,\n  Stream = require('../utils/stream');\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function (bytes) {\n  var i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function (sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function (pts, userData) {\n  var results = [],\n    i,\n    count,\n    offset,\n    data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\nvar CaptionStream = function () {\n  CaptionStream.prototype.init.call(this);\n  this.captionPackets_ = [];\n  this.ccStreams_ = [new Cea608Stream(0, 0),\n  // eslint-disable-line no-use-before-define\n  new Cea608Stream(0, 1),\n  // eslint-disable-line no-use-before-define\n  new Cea608Stream(1, 0),\n  // eslint-disable-line no-use-before-define\n  new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function (cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n};\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function (event) {\n  var sei, userData;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across 2 packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the second\n  // dts packet we receive that has dts === this.latestDts_. And thus, the\n  // ignoreNextEqualDts_ flag was born.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n    // We've received the last duplicate packet, time to start processing again\n    this.ignoreNextEqualDts_ = false;\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\n  this.latestDts_ = event.dts;\n};\nCaptionStream.prototype.flush = function () {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function (cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function (elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function (a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n  this.captionPackets_.forEach(function (packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function (cc) {\n    cc.flush();\n  }, this);\n  return;\n};\nCaptionStream.prototype.reset = function () {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function (ccStream) {\n    ccStream.reset();\n  });\n};\nCaptionStream.prototype.dispatchCea608Packet = function (packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\nCaptionStream.prototype.setsChannel1Active = function (packet) {\n  return (packet.ccData & 0x7800) === 0x1000;\n};\nCaptionStream.prototype.setsChannel2Active = function (packet) {\n  return (packet.ccData & 0x7800) === 0x1800;\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,\n  // á\n  0x5c: 0xe9,\n  // é\n  0x5e: 0xed,\n  // í\n  0x5f: 0xf3,\n  // ó\n  0x60: 0xfa,\n  // ú\n  0x7b: 0xe7,\n  // ç\n  0x7c: 0xf7,\n  // ÷\n  0x7d: 0xd1,\n  // Ñ\n  0x7e: 0xf1,\n  // ñ\n  0x7f: 0x2588,\n  // █\n  0x0130: 0xae,\n  // ®\n  0x0131: 0xb0,\n  // °\n  0x0132: 0xbd,\n  // ½\n  0x0133: 0xbf,\n  // ¿\n  0x0134: 0x2122,\n  // ™\n  0x0135: 0xa2,\n  // ¢\n  0x0136: 0xa3,\n  // £\n  0x0137: 0x266a,\n  // ♪\n  0x0138: 0xe0,\n  // à\n  0x0139: 0xa0,\n  //\n  0x013a: 0xe8,\n  // è\n  0x013b: 0xe2,\n  // â\n  0x013c: 0xea,\n  // ê\n  0x013d: 0xee,\n  // î\n  0x013e: 0xf4,\n  // ô\n  0x013f: 0xfb,\n  // û\n  0x0220: 0xc1,\n  // Á\n  0x0221: 0xc9,\n  // É\n  0x0222: 0xd3,\n  // Ó\n  0x0223: 0xda,\n  // Ú\n  0x0224: 0xdc,\n  // Ü\n  0x0225: 0xfc,\n  // ü\n  0x0226: 0x2018,\n  // ‘\n  0x0227: 0xa1,\n  // ¡\n  0x0228: 0x2a,\n  // *\n  0x0229: 0x27,\n  // '\n  0x022a: 0x2014,\n  // —\n  0x022b: 0xa9,\n  // ©\n  0x022c: 0x2120,\n  // ℠\n  0x022d: 0x2022,\n  // •\n  0x022e: 0x201c,\n  // “\n  0x022f: 0x201d,\n  // ”\n  0x0230: 0xc0,\n  // À\n  0x0231: 0xc2,\n  // Â\n  0x0232: 0xc7,\n  // Ç\n  0x0233: 0xc8,\n  // È\n  0x0234: 0xca,\n  // Ê\n  0x0235: 0xcb,\n  // Ë\n  0x0236: 0xeb,\n  // ë\n  0x0237: 0xce,\n  // Î\n  0x0238: 0xcf,\n  // Ï\n  0x0239: 0xef,\n  // ï\n  0x023a: 0xd4,\n  // Ô\n  0x023b: 0xd9,\n  // Ù\n  0x023c: 0xf9,\n  // ù\n  0x023d: 0xdb,\n  // Û\n  0x023e: 0xab,\n  // «\n  0x023f: 0xbb,\n  // »\n  0x0320: 0xc3,\n  // Ã\n  0x0321: 0xe3,\n  // ã\n  0x0322: 0xcd,\n  // Í\n  0x0323: 0xcc,\n  // Ì\n  0x0324: 0xec,\n  // ì\n  0x0325: 0xd2,\n  // Ò\n  0x0326: 0xf2,\n  // ò\n  0x0327: 0xd5,\n  // Õ\n  0x0328: 0xf5,\n  // õ\n  0x0329: 0x7b,\n  // {\n  0x032a: 0x7d,\n  // }\n  0x032b: 0x5c,\n  // \\\n  0x032c: 0x5e,\n  // ^\n  0x032d: 0x5f,\n  // _\n  0x032e: 0x7c,\n  // |\n  0x032f: 0x7e,\n  // ~\n  0x0330: 0xc4,\n  // Ä\n  0x0331: 0xe4,\n  // ä\n  0x0332: 0xd6,\n  // Ö\n  0x0333: 0xf6,\n  // ö\n  0x0334: 0xdf,\n  // ß\n  0x0335: 0xa5,\n  // ¥\n  0x0336: 0xa4,\n  // ¤\n  0x0337: 0x2502,\n  // │\n  0x0338: 0xc5,\n  // Å\n  0x0339: 0xe5,\n  // å\n  0x033a: 0xd8,\n  // Ø\n  0x033b: 0xf8,\n  // ø\n  0x033c: 0x250c,\n  // ┌\n  0x033d: 0x2510,\n  // ┐\n  0x033e: 0x2514,\n  // └\n  0x033f: 0x2518 // ┘\n};\nvar getCharFromCode = function (code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function () {\n  var result = [],\n    i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\nvar Cea608Stream = function (field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n  this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n  this.setConstants();\n  this.reset();\n  this.push = function (packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n    if (data === this.PADDING_) {\n      return;\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n    } else if (data === this.END_OF_CAPTION_) {\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 1;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 2;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 3;\n      this.mode_ = 'rollUp';\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      this.mode_ = 'paintOn';\n\n      // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n      // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n      // decoders are supposed to drop the \"è\", while compliant decoders\n      // backspace the \"e\" and insert \"è\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n      // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n      // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += char1 & 0x03;\n\n      // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n      // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n    } // finish data processing\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function (pts) {\n  var content = this.displayed_\n  // remove spaces from the start and end of the string\n  .map(function (row) {\n    return row.trim();\n  })\n  // combine all text rows to display in one cue\n  .join('\\n')\n  // and remove blank rows from the start and end, but not the middle\n  .replace(/^\\n+|\\n+$/g, '');\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function () {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function () {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_ = 0x10;\n    this.EXT_ = 0x11;\n    this.CONTROL_ = (0x14 | this.field_) << 8;\n    this.OFFSET_ = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_ = 0x18;\n    this.EXT_ = 0x19;\n    this.CONTROL_ = (0x1c | this.field_) << 8;\n    this.OFFSET_ = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_ = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d;\n  // paint-on mode (not supported)\n  this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_ = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n  return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function (char0, char1) {\n  return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function (char0, char1) {\n  return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n  return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function (char0, char1) {\n  return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function (char1) {\n  return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function (char) {\n  return char >= 0x20 && char <= 0x7f;\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function (pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function (text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function (pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function (text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function (pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\nCea608Stream.prototype.rollUp = function (pts, text) {\n  var baseRow = this.displayed_[BOTTOM_ROW];\n  baseRow += text;\n  this.displayed_[BOTTOM_ROW] = baseRow;\n};\nCea608Stream.prototype.shiftRowsUp_ = function () {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[BOTTOM_ROW] = '';\n};\n\n// paintOn mode is not implemented\nCea608Stream.prototype.paintOn = function () {};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};","map":{"version":3,"names":["USER_DATA_REGISTERED_ITU_T_T35","RBSP_TRAILING_BITS","Stream","require","parseSei","bytes","i","result","payloadType","payloadSize","byteLength","payload","subarray","parseUserData","sei","String","fromCharCode","length","parseCaptionPackets","pts","userData","results","count","offset","data","type","ccData","push","CaptionStream","prototype","init","call","captionPackets_","ccStreams_","Cea608Stream","reset","forEach","cc","on","trigger","bind","event","nalUnitType","escapedRBSP","dts","latestDts_","ignoreNextEqualDts_","concat","flush","elem","idx","presortIndex","sort","a","b","packet","dispatchCea608Packet","activeCea608Channel_","ccStream","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION","getCharFromCode","code","BOTTOM_ROW","ROWS","createDisplayBuffer","field","dataChannel","field_","dataChannel_","name_","setConstants","swap","char0","char1","text","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","flushDisplayed","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","topRow_","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","slice","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","row_","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","row","indexOf","formatting_","isColorPAC","isNormalChar","content","map","trim","join","replace","startPts","endPts","stream","BASE_","EXT_","CONTROL_","OFFSET_","char","format","reduce","reverse","popOn","baseRow","rollUp","paintOn","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/caption-stream.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128,\n    Stream = require('../utils/stream');\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across 2 packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the second\n  // dts packet we receive that has dts === this.latestDts_. And thus, the\n  // ignoreNextEqualDts_ flag was born.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    // We've received the last duplicate packet, time to start processing again\n    this.ignoreNextEqualDts_ = false;\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // á\n  0x5c: 0xe9,     // é\n  0x5e: 0xed,     // í\n  0x5f: 0xf3,     // ó\n  0x60: 0xfa,     // ú\n  0x7b: 0xe7,     // ç\n  0x7c: 0xf7,     // ÷\n  0x7d: 0xd1,     // Ñ\n  0x7e: 0xf1,     // ñ\n  0x7f: 0x2588,   // █\n  0x0130: 0xae,   // ®\n  0x0131: 0xb0,   // °\n  0x0132: 0xbd,   // ½\n  0x0133: 0xbf,   // ¿\n  0x0134: 0x2122, // ™\n  0x0135: 0xa2,   // ¢\n  0x0136: 0xa3,   // £\n  0x0137: 0x266a, // ♪\n  0x0138: 0xe0,   // à\n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // è\n  0x013b: 0xe2,   // â\n  0x013c: 0xea,   // ê\n  0x013d: 0xee,   // î\n  0x013e: 0xf4,   // ô\n  0x013f: 0xfb,   // û\n  0x0220: 0xc1,   // Á\n  0x0221: 0xc9,   // É\n  0x0222: 0xd3,   // Ó\n  0x0223: 0xda,   // Ú\n  0x0224: 0xdc,   // Ü\n  0x0225: 0xfc,   // ü\n  0x0226: 0x2018, // ‘\n  0x0227: 0xa1,   // ¡\n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // —\n  0x022b: 0xa9,   // ©\n  0x022c: 0x2120, // ℠\n  0x022d: 0x2022, // •\n  0x022e: 0x201c, // “\n  0x022f: 0x201d, // ”\n  0x0230: 0xc0,   // À\n  0x0231: 0xc2,   // Â\n  0x0232: 0xc7,   // Ç\n  0x0233: 0xc8,   // È\n  0x0234: 0xca,   // Ê\n  0x0235: 0xcb,   // Ë\n  0x0236: 0xeb,   // ë\n  0x0237: 0xce,   // Î\n  0x0238: 0xcf,   // Ï\n  0x0239: 0xef,   // ï\n  0x023a: 0xd4,   // Ô\n  0x023b: 0xd9,   // Ù\n  0x023c: 0xf9,   // ù\n  0x023d: 0xdb,   // Û\n  0x023e: 0xab,   // «\n  0x023f: 0xbb,   // »\n  0x0320: 0xc3,   // Ã\n  0x0321: 0xe3,   // ã\n  0x0322: 0xcd,   // Í\n  0x0323: 0xcc,   // Ì\n  0x0324: 0xec,   // ì\n  0x0325: 0xd2,   // Ò\n  0x0326: 0xf2,   // ò\n  0x0327: 0xd5,   // Õ\n  0x0328: 0xf5,   // õ\n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // Ä\n  0x0331: 0xe4,   // ä\n  0x0332: 0xd6,   // Ö\n  0x0333: 0xf6,   // ö\n  0x0334: 0xdf,   // ß\n  0x0335: 0xa5,   // ¥\n  0x0336: 0xa4,   // ¤\n  0x0337: 0x2502, // │\n  0x0338: 0xc5,   // Å\n  0x0339: 0xe5,   // å\n  0x033a: 0xd8,   // Ø\n  0x033b: 0xf8,   // ø\n  0x033c: 0x250c, // ┌\n  0x033d: 0x2510, // ┐\n  0x033e: 0x2514, // └\n  0x033f: 0x2518  // ┘\n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 1;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 2;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 3;\n      this.mode_ = 'rollUp';\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      this.mode_ = 'paintOn';\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n      // decoders are supposed to drop the \"è\", while compliant decoders\n      // backspace the \"e\" and insert \"è\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      return row.trim();\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode (not supported)\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[BOTTOM_ROW];\n\n  baseRow += text;\n  this.displayed_[BOTTOM_ROW] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[BOTTOM_ROW] = '';\n};\n\n// paintOn mode is not implemented\nCea608Stream.prototype.paintOn = function() {};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n"],"mappings":"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hB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,IAAI;EAAI;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,MAAM;EAAE;EAChB,MAAM,EAAE,MAAM,CAAE;AAClB,CAAC;AAED,IAAIC,eAAe,GAAG,SAAAA,CAASC,IAAI,EAAE;EACnC,IAAIA,IAAI,KAAK,IAAI,EAAE;IACjB,OAAO,EAAE;EACX;EACAA,IAAI,GAAGF,qBAAqB,CAACE,IAAI,CAAC,IAAIA,IAAI;EAC1C,OAAOhD,MAAM,CAACC,YAAY,CAAC+C,IAAI,CAAC;AAClC,CAAC;;AAED;AACA,IAAIC,UAAU,GAAG,EAAE;;AAEnB;AACA;AACA,IAAIC,IAAI,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC;;AAEnE;AACA;AACA,IAAIC,mBAAmB,GAAG,SAAAA,CAAA,EAAW;EACnC,IAAI3D,MAAM,GAAG,EAAE;IAAED,CAAC,GAAG0D,UAAU,GAAG,CAAC;EACnC,OAAO1D,CAAC,EAAE,EAAE;IACVC,MAAM,CAACoB,IAAI,CAAC,EAAE,CAAC;EACjB;EACA,OAAOpB,MAAM;AACf,CAAC;AAED,IAAI2B,YAAY,GAAG,SAAAA,CAASiC,KAAK,EAAEC,WAAW,EAAE;EAC9ClC,YAAY,CAACL,SAAS,CAACC,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC;EAEtC,IAAI,CAACsC,MAAM,GAAGF,KAAK,IAAI,CAAC;EACxB,IAAI,CAACG,YAAY,GAAGF,WAAW,IAAI,CAAC;EAEpC,IAAI,CAACG,KAAK,GAAG,IAAI,IAAI,CAAE,IAAI,CAACF,MAAM,IAAI,CAAC,GAAI,IAAI,CAACC,YAAY,IAAI,CAAC,CAAC;EAElE,IAAI,CAACE,YAAY,CAAC,CAAC;EACnB,IAAI,CAACrC,KAAK,CAAC,CAAC;EAEZ,IAAI,CAACR,IAAI,GAAG,UAAS4B,MAAM,EAAE;IAC3B,IAAI/B,IAAI,EAAEiD,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAEC,IAAI;IAClC;IACApD,IAAI,GAAG+B,MAAM,CAAC7B,MAAM,GAAG,MAAM;;IAE7B;IACA,IAAIF,IAAI,KAAK,IAAI,CAACqD,gBAAgB,EAAE;MAClC,IAAI,CAACA,gBAAgB,GAAG,IAAI;MAC5B;IACF;;IAEA;IACA,IAAI,CAACrD,IAAI,GAAG,MAAM,MAAM,MAAM,EAAE;MAC9B,IAAI,CAACqD,gBAAgB,GAAGrD,IAAI;IAC9B,CAAC,MAAM,IAAIA,IAAI,KAAK,IAAI,CAACsD,QAAQ,EAAE;MACjC,IAAI,CAACD,gBAAgB,GAAG,IAAI;IAC9B;IAEAH,KAAK,GAAGlD,IAAI,KAAK,CAAC;IAClBmD,KAAK,GAAGnD,IAAI,GAAG,IAAI;IAEnB,IAAIA,IAAI,KAAK,IAAI,CAACsD,QAAQ,EAAE;MAC1B;IAEF,CAAC,MAAM,IAAItD,IAAI,KAAK,IAAI,CAACuD,uBAAuB,EAAE;MAChD,IAAI,CAACC,KAAK,GAAG,OAAO;IAEtB,CAAC,MAAM,IAAIxD,IAAI,KAAK,IAAI,CAACyD,eAAe,EAAE;MACxC,IAAI,CAACC,eAAe,CAAC3B,MAAM,CAACpC,GAAG,CAAC;MAChC;MACA,IAAI,CAACgE,cAAc,CAAC5B,MAAM,CAACpC,GAAG,CAAC;;MAE/B;MACAsD,IAAI,GAAG,IAAI,CAACW,UAAU;MACtB,IAAI,CAACA,UAAU,GAAG,IAAI,CAACC,aAAa;MACpC,IAAI,CAACA,aAAa,GAAGZ,IAAI;;MAEzB;MACA,IAAI,CAACa,SAAS,GAAG/B,MAAM,CAACpC,GAAG;IAE7B,CAAC,MAAM,IAAIK,IAAI,KAAK,IAAI,CAAC+D,eAAe,EAAE;MACxC,IAAI,CAACC,OAAO,GAAGxB,UAAU,GAAG,CAAC;MAC7B,IAAI,CAACgB,KAAK,GAAG,QAAQ;IACvB,CAAC,MAAM,IAAIxD,IAAI,KAAK,IAAI,CAACiE,eAAe,EAAE;MACxC,IAAI,CAACD,OAAO,GAAGxB,UAAU,GAAG,CAAC;MAC7B,IAAI,CAACgB,KAAK,GAAG,QAAQ;IACvB,CAAC,MAAM,IAAIxD,IAAI,KAAK,IAAI,CAACkE,eAAe,EAAE;MACxC,IAAI,CAACF,OAAO,GAAGxB,UAAU,GAAG,CAAC;MAC7B,IAAI,CAACgB,KAAK,GAAG,QAAQ;IACvB,CAAC,MAAM,IAAIxD,IAAI,KAAK,IAAI,CAACmE,gBAAgB,EAAE;MACzC,IAAI,CAACT,eAAe,CAAC3B,MAAM,CAACpC,GAAG,CAAC;MAChC,IAAI,CAACgE,cAAc,CAAC5B,MAAM,CAACpC,GAAG,CAAC;MAC/B,IAAI,CAACyE,YAAY,CAAC,CAAC;MACnB,IAAI,CAACN,SAAS,GAAG/B,MAAM,CAACpC,GAAG;IAE7B,CAAC,MAAM,IAAIK,IAAI,KAAK,IAAI,CAACqE,UAAU,EAAE;MACnC,IAAI,IAAI,CAACb,KAAK,KAAK,OAAO,EAAE;QAC1B,IAAI,CAACK,aAAa,CAACrB,UAAU,CAAC,GAAG,IAAI,CAACqB,aAAa,CAACrB,UAAU,CAAC,CAAC8B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC9E,CAAC,MAAM;QACL,IAAI,CAACV,UAAU,CAACpB,UAAU,CAAC,GAAG,IAAI,CAACoB,UAAU,CAACpB,UAAU,CAAC,CAAC8B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACxE;IACF,CAAC,MAAM,IAAItE,IAAI,KAAK,IAAI,CAACuE,uBAAuB,EAAE;MAChD,IAAI,CAACZ,cAAc,CAAC5B,MAAM,CAACpC,GAAG,CAAC;MAC/B,IAAI,CAACiE,UAAU,GAAGlB,mBAAmB,CAAC,CAAC;IACzC,CAAC,MAAM,IAAI1C,IAAI,KAAK,IAAI,CAACwE,2BAA2B,EAAE;MACpD,IAAI,CAACX,aAAa,GAAGnB,mBAAmB,CAAC,CAAC;IAE5C,CAAC,MAAM,IAAI1C,IAAI,KAAK,IAAI,CAACyE,yBAAyB,EAAE;MAClD,IAAI,CAACjB,KAAK,GAAG,SAAS;;MAExB;IACA,CAAC,MAAM,IAAI,IAAI,CAACkB,kBAAkB,CAACxB,KAAK,EAAEC,KAAK,CAAC,EAAE;MAChD;MACA;MACA;MACA;MACAD,KAAK,GAAG,CAACA,KAAK,GAAG,IAAI,KAAK,CAAC;MAC3BE,IAAI,GAAGd,eAAe,CAACY,KAAK,GAAGC,KAAK,CAAC;MACrC,IAAI,CAAC,IAAI,CAACK,KAAK,CAAC,CAACzB,MAAM,CAACpC,GAAG,EAAEyD,IAAI,CAAC;MAClC,IAAI,CAACuB,OAAO,EAAE;;MAEhB;IACA,CAAC,MAAM,IAAI,IAAI,CAACC,cAAc,CAAC1B,KAAK,EAAEC,KAAK,CAAC,EAAE;MAC5C;MACA;MACA;MACA;;MAEA;MACA,IAAI,IAAI,CAACK,KAAK,KAAK,OAAO,EAAE;QAC1B,IAAI,CAACK,aAAa,CAAC,IAAI,CAACgB,IAAI,CAAC,GAAG,IAAI,CAAChB,aAAa,CAAC,IAAI,CAACgB,IAAI,CAAC,CAACP,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC5E,CAAC,MAAM;QACL,IAAI,CAACV,UAAU,CAACpB,UAAU,CAAC,GAAG,IAAI,CAACoB,UAAU,CAACpB,UAAU,CAAC,CAAC8B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACxE;;MAEA;MACA;MACA;MACA;MACApB,KAAK,GAAG,CAACA,KAAK,GAAG,IAAI,KAAK,CAAC;MAC3BE,IAAI,GAAGd,eAAe,CAACY,KAAK,GAAGC,KAAK,CAAC;MACrC,IAAI,CAAC,IAAI,CAACK,KAAK,CAAC,CAACzB,MAAM,CAACpC,GAAG,EAAEyD,IAAI,CAAC;MAClC,IAAI,CAACuB,OAAO,EAAE;;MAEhB;IACA,CAAC,MAAM,IAAI,IAAI,CAACG,YAAY,CAAC5B,KAAK,EAAEC,KAAK,CAAC,EAAE;MAC1C;MACA,IAAI,CAACO,eAAe,CAAC3B,MAAM,CAACpC,GAAG,CAAC;;MAEhC;MACA;MACA,IAAI,CAAC,IAAI,CAAC6D,KAAK,CAAC,CAACzB,MAAM,CAACpC,GAAG,EAAE,GAAG,CAAC;MACjC,IAAI,CAACgF,OAAO,EAAE;MAEd,IAAI,CAACxB,KAAK,GAAG,GAAG,MAAM,GAAG,EAAE;QACzB,IAAI,CAAC4B,aAAa,CAAChD,MAAM,CAACpC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;MACvC;MAEA,IAAI,CAACwD,KAAK,GAAG,GAAG,MAAM,GAAG,EAAE;QACzB,IAAI,CAAC4B,aAAa,CAAChD,MAAM,CAACpC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;MACvC;;MAEF;IACA,CAAC,MAAM,IAAI,IAAI,CAACqF,mBAAmB,CAAC9B,KAAK,EAAEC,KAAK,CAAC,EAAE;MACjD;MACA;MACA;MACA;MACA,IAAI,CAACwB,OAAO,IAAKxB,KAAK,GAAG,IAAK;;MAEhC;IACA,CAAC,MAAM,IAAI,IAAI,CAAC8B,KAAK,CAAC/B,KAAK,EAAEC,KAAK,CAAC,EAAE;MAEnC;MACA;MACA,IAAI+B,GAAG,GAAGzC,IAAI,CAAC0C,OAAO,CAACnF,IAAI,GAAG,MAAM,CAAC;MAErC,IAAIkF,GAAG,KAAK,IAAI,CAACL,IAAI,EAAE;QACrB;QACA,IAAI,CAACnB,eAAe,CAAC3B,MAAM,CAACpC,GAAG,CAAC;QAChC,IAAI,CAACkF,IAAI,GAAGK,GAAG;MACjB;MACA;MACA;MACA,IAAK/B,KAAK,GAAG,GAAG,IAAM,IAAI,CAACiC,WAAW,CAACD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAE,EAAE;QACzD,IAAI,CAACJ,aAAa,CAAChD,MAAM,CAACpC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;MACzC;MAEA,IAAI,CAACK,IAAI,GAAG,IAAI,MAAM,IAAI,EAAE;QAC1B;QACA;QACA;QACA;QACA,IAAI,CAAC2E,OAAO,GAAG,CAAC,CAAC3E,IAAI,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC;MACxC;MAEA,IAAI,IAAI,CAACqF,UAAU,CAAClC,KAAK,CAAC,EAAE;QAC1B;QACA;QACA;QACA;QACA,IAAI,CAACA,KAAK,GAAG,GAAG,MAAM,GAAG,EAAE;UACzB,IAAI,CAAC4B,aAAa,CAAChD,MAAM,CAACpC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;QACvC;MACF;;MAEF;IACA,CAAC,MAAM,IAAI,IAAI,CAAC2F,YAAY,CAACpC,KAAK,CAAC,EAAE;MACnC,IAAIC,KAAK,KAAK,IAAI,EAAE;QAClBA,KAAK,GAAG,IAAI;MACd;MACAC,IAAI,GAAGd,eAAe,CAACY,KAAK,CAAC;MAC7BE,IAAI,IAAId,eAAe,CAACa,KAAK,CAAC;MAC9B,IAAI,CAAC,IAAI,CAACK,KAAK,CAAC,CAACzB,MAAM,CAACpC,GAAG,EAAEyD,IAAI,CAAC;MAClC,IAAI,CAACuB,OAAO,IAAIvB,IAAI,CAAC3D,MAAM;IAE7B,CAAC,CAAC;EAEJ,CAAC;AACH,CAAC;AACDiB,YAAY,CAACL,SAAS,GAAG,IAAI3B,MAAM,CAAC,CAAC;AACrC;AACA;AACAgC,YAAY,CAACL,SAAS,CAACsD,cAAc,GAAG,UAAShE,GAAG,EAAE;EACpD,IAAI4F,OAAO,GAAG,IAAI,CAAC3B;EACjB;EAAA,CACC4B,GAAG,CAAC,UAASN,GAAG,EAAE;IACjB,OAAOA,GAAG,CAACO,IAAI,CAAC,CAAC;EACnB,CAAC;EACD;EAAA,CACCC,IAAI,CAAC,IAAI;EACV;EAAA,CACCC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;EAE5B,IAAIJ,OAAO,CAAC9F,MAAM,EAAE;IAClB,IAAI,CAACsB,OAAO,CAAC,MAAM,EAAE;MACnB6E,QAAQ,EAAE,IAAI,CAAC9B,SAAS;MACxB+B,MAAM,EAAElG,GAAG;MACXyD,IAAI,EAAEmC,OAAO;MACbO,MAAM,EAAE,IAAI,CAAC/C;IACf,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA;AACA;AACArC,YAAY,CAACL,SAAS,CAACM,KAAK,GAAG,YAAW;EACxC,IAAI,CAAC6C,KAAK,GAAG,OAAO;EACpB;EACA;EACA;EACA;EACA,IAAI,CAACQ,OAAO,GAAG,CAAC;EAChB,IAAI,CAACF,SAAS,GAAG,CAAC;EAClB,IAAI,CAACF,UAAU,GAAGlB,mBAAmB,CAAC,CAAC;EACvC,IAAI,CAACmB,aAAa,GAAGnB,mBAAmB,CAAC,CAAC;EAC1C,IAAI,CAACW,gBAAgB,GAAG,IAAI;;EAE5B;EACA,IAAI,CAACsB,OAAO,GAAG,CAAC;EAChB,IAAI,CAACE,IAAI,GAAGrC,UAAU;;EAEtB;EACA,IAAI,CAAC4C,WAAW,GAAG,EAAE;AACvB,CAAC;;AAED;AACA;AACA;AACA1E,YAAY,CAACL,SAAS,CAAC2C,YAAY,GAAG,YAAW;EAC/C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,IAAI,CAACF,YAAY,KAAK,CAAC,EAAE;IAC3B,IAAI,CAACiD,KAAK,GAAO,IAAI;IACrB,IAAI,CAACC,IAAI,GAAQ,IAAI;IACrB,IAAI,CAACC,QAAQ,GAAI,CAAC,IAAI,GAAG,IAAI,CAACpD,MAAM,KAAK,CAAC;IAC1C,IAAI,CAACqD,OAAO,GAAK,IAAI;EACvB,CAAC,MAAM,IAAI,IAAI,CAACpD,YAAY,KAAK,CAAC,EAAE;IAClC,IAAI,CAACiD,KAAK,GAAO,IAAI;IACrB,IAAI,CAACC,IAAI,GAAQ,IAAI;IACrB,IAAI,CAACC,QAAQ,GAAI,CAAC,IAAI,GAAG,IAAI,CAACpD,MAAM,KAAK,CAAC;IAC1C,IAAI,CAACqD,OAAO,GAAK,IAAI;EACvB;;EAEA;EACA;EACA;EACA;EACA,IAAI,CAAC5C,QAAQ,GAAsB,MAAM;EACzC;EACA,IAAI,CAACC,uBAAuB,GAAO,IAAI,CAAC0C,QAAQ,GAAG,IAAI;EACvD,IAAI,CAACxC,eAAe,GAAe,IAAI,CAACwC,QAAQ,GAAG,IAAI;EACvD;EACA,IAAI,CAAClC,eAAe,GAAe,IAAI,CAACkC,QAAQ,GAAG,IAAI;EACvD,IAAI,CAAChC,eAAe,GAAe,IAAI,CAACgC,QAAQ,GAAG,IAAI;EACvD,IAAI,CAAC/B,eAAe,GAAe,IAAI,CAAC+B,QAAQ,GAAG,IAAI;EACvD,IAAI,CAAC9B,gBAAgB,GAAc,IAAI,CAAC8B,QAAQ,GAAG,IAAI;EACvD;EACA,IAAI,CAACxB,yBAAyB,GAAK,IAAI,CAACwB,QAAQ,GAAG,IAAI;EACvD;EACA,IAAI,CAAC5B,UAAU,GAAoB,IAAI,CAAC4B,QAAQ,GAAG,IAAI;EACvD,IAAI,CAAC1B,uBAAuB,GAAO,IAAI,CAAC0B,QAAQ,GAAG,IAAI;EACvD,IAAI,CAACzB,2BAA2B,GAAG,IAAI,CAACyB,QAAQ,GAAG,IAAI;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvF,YAAY,CAACL,SAAS,CAACqE,kBAAkB,GAAG,UAASxB,KAAK,EAAEC,KAAK,EAAE;EACjE,OAAQD,KAAK,KAAK,IAAI,CAAC8C,IAAI,IAAI7C,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAI;AAC/D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAACuE,cAAc,GAAG,UAAS1B,KAAK,EAAEC,KAAK,EAAE;EAC7D,OAAQ,CAACD,KAAK,KAAM,IAAI,CAAC8C,IAAI,GAAG,CAAE,IAAI9C,KAAK,KAAM,IAAI,CAAC8C,IAAI,GAAG,CAAE,KAC5D7C,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAK;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAACyE,YAAY,GAAG,UAAS5B,KAAK,EAAEC,KAAK,EAAE;EAC3D,OAAQD,KAAK,KAAK,IAAI,CAAC8C,IAAI,IAAK7C,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAK;AACjE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAAC2E,mBAAmB,GAAG,UAAS9B,KAAK,EAAEC,KAAK,EAAE;EAClE,OAAQD,KAAK,KAAK,IAAI,CAACgD,OAAO,IAAK/C,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAK;AACpE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAAC4E,KAAK,GAAG,UAAS/B,KAAK,EAAEC,KAAK,EAAE;EACpD,OAAQD,KAAK,IAAI,IAAI,CAAC6C,KAAK,IAAI7C,KAAK,GAAI,IAAI,CAAC6C,KAAK,GAAG,CAAE,IACpD5C,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAK;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAACgF,UAAU,GAAG,UAASlC,KAAK,EAAE;EAClD,OAASA,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAI,IAAMA,KAAK,IAAI,IAAI,IAAIA,KAAK,IAAI,IAAK;AAC9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACL,SAAS,CAACiF,YAAY,GAAG,UAASa,IAAI,EAAE;EACnD,OAAQA,IAAI,IAAI,IAAI,IAAIA,IAAI,IAAI,IAAI;AACtC,CAAC;;AAED;AACA;AACAzF,YAAY,CAACL,SAAS,CAAC0E,aAAa,GAAG,UAASpF,GAAG,EAAEyG,MAAM,EAAE;EAC3D,IAAI,CAAChB,WAAW,GAAG,IAAI,CAACA,WAAW,CAAC7D,MAAM,CAAC6E,MAAM,CAAC;EAClD,IAAIhD,IAAI,GAAGgD,MAAM,CAACC,MAAM,CAAC,UAASjD,IAAI,EAAEgD,MAAM,EAAE;IAC9C,OAAOhD,IAAI,GAAG,GAAG,GAAGgD,MAAM,GAAG,GAAG;EAClC,CAAC,EAAE,EAAE,CAAC;EACN,IAAI,CAAC,IAAI,CAAC5C,KAAK,CAAC,CAAC7D,GAAG,EAAEyD,IAAI,CAAC;AAC7B,CAAC;;AAED;AACA;AACA1C,YAAY,CAACL,SAAS,CAACqD,eAAe,GAAG,UAAS/D,GAAG,EAAE;EACrD,IAAI,CAAC,IAAI,CAACyF,WAAW,CAAC3F,MAAM,EAAE;IAC5B;EACF;EACA,IAAI2D,IAAI,GAAG,IAAI,CAACgC,WAAW,CAACkB,OAAO,CAAC,CAAC,CAACD,MAAM,CAAC,UAASjD,IAAI,EAAEgD,MAAM,EAAE;IAClE,OAAOhD,IAAI,GAAG,IAAI,GAAGgD,MAAM,GAAG,GAAG;EACnC,CAAC,EAAE,EAAE,CAAC;EACN,IAAI,CAAChB,WAAW,GAAG,EAAE;EACrB,IAAI,CAAC,IAAI,CAAC5B,KAAK,CAAC,CAAC7D,GAAG,EAAEyD,IAAI,CAAC;AAC7B,CAAC;;AAED;AACA1C,YAAY,CAACL,SAAS,CAACkG,KAAK,GAAG,UAAS5G,GAAG,EAAEyD,IAAI,EAAE;EACjD,IAAIoD,OAAO,GAAG,IAAI,CAAC3C,aAAa,CAAC,IAAI,CAACgB,IAAI,CAAC;;EAE3C;EACA2B,OAAO,IAAIpD,IAAI;EACf,IAAI,CAACS,aAAa,CAAC,IAAI,CAACgB,IAAI,CAAC,GAAG2B,OAAO;AACzC,CAAC;AAED9F,YAAY,CAACL,SAAS,CAACoG,MAAM,GAAG,UAAS9G,GAAG,EAAEyD,IAAI,EAAE;EAClD,IAAIoD,OAAO,GAAG,IAAI,CAAC5C,UAAU,CAACpB,UAAU,CAAC;EAEzCgE,OAAO,IAAIpD,IAAI;EACf,IAAI,CAACQ,UAAU,CAACpB,UAAU,CAAC,GAAGgE,OAAO;AAEvC,CAAC;AAED9F,YAAY,CAACL,SAAS,CAAC+D,YAAY,GAAG,YAAW;EAC/C,IAAItF,CAAC;EACL;EACA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACkF,OAAO,EAAElF,CAAC,EAAE,EAAE;IACjC,IAAI,CAAC8E,UAAU,CAAC9E,CAAC,CAAC,GAAG,EAAE;EACzB;EACA;EACA,KAAKA,CAAC,GAAG,IAAI,CAACkF,OAAO,EAAElF,CAAC,GAAG0D,UAAU,EAAE1D,CAAC,EAAE,EAAE;IAC1C,IAAI,CAAC8E,UAAU,CAAC9E,CAAC,CAAC,GAAG,IAAI,CAAC8E,UAAU,CAAC9E,CAAC,GAAG,CAAC,CAAC;EAC7C;EACA;EACA,IAAI,CAAC8E,UAAU,CAACpB,UAAU,CAAC,GAAG,EAAE;AAClC,CAAC;;AAED;AACA9B,YAAY,CAACL,SAAS,CAACqG,OAAO,GAAG,YAAW,CAAC,CAAC;;AAE9C;AACAC,MAAM,CAACC,OAAO,GAAG;EACfxG,aAAa,EAAEA,aAAa;EAC5BM,YAAY,EAAEA;AAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}