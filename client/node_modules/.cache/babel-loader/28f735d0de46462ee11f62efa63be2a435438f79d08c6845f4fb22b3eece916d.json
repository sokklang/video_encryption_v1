{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar findBox, parseType, timescale, startTime;\n\n// Find the data for a box specified by its path\nfindBox = function (data, path) {\n  var results = [],\n    i,\n    size,\n    type,\n    end,\n    subresults;\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n  for (i = 0; i < data.byteLength;) {\n    size = data[i] << 24;\n    size |= data[i + 1] << 16;\n    size |= data[i + 2] << 8;\n    size |= data[i + 3];\n    type = parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function (buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function (init) {\n  var result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function (result, trak) {\n    var tkhd, version, index, id, mdhd;\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function (timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function (traf) {\n    return findBox(traf, ['tfhd']).map(function (tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n        var version, result;\n        version = tfdt[0];\n        result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\nmodule.exports = {\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime\n};","map":{"version":3,"names":["findBox","parseType","timescale","startTime","data","path","results","i","size","type","end","subresults","length","byteLength","subarray","push","slice","concat","buffer","result","String","fromCharCode","init","traks","reduce","trak","tkhd","version","index","id","mdhd","fragment","trafs","baseTimes","apply","map","traf","tfhd","scale","baseTime","tfdt","Math","pow","Infinity","min","isFinite","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/node_modules/mux.js/lib/mp4/probe.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar findBox, parseType, timescale, startTime;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = data[i]     << 24;\n    size |= data[i + 1] << 16;\n    size |= data[i + 2] << 8;\n    size |= data[i + 3];\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = tkhd[index]     << 24 |\n         tkhd[index + 1] << 16 |\n         tkhd[index + 2] <<  8 |\n         tkhd[index + 3];\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = mdhd[index]     << 24 |\n                 mdhd[index + 1] << 16 |\n                 mdhd[index + 2] <<  8 |\n                 mdhd[index + 3];\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = tfhd[4] << 24 |\n           tfhd[5] << 16 |\n           tfhd[6] << 8 |\n           tfhd[7];\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = tfdt[4] << 24 |\n                 tfdt[5] << 16 |\n                 tfdt[6] <<  8 |\n                 tfdt[7];\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += tfdt[8]  << 24 |\n                    tfdt[9]  << 16 |\n                    tfdt[10] <<  8 |\n                    tfdt[11];\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\nmodule.exports = {\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}