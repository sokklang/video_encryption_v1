{"ast":null,"code":"'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function (workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n    // the current word being examined\n    workingWord = 0,\n    // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function () {\n    return 8 * workingBytesAvailable;\n  };\n\n  // ():uint\n  this.bitsAvailable = function () {\n    return 8 * workingBytesAvailable + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function () {\n    var position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(workingData.subarray(position, position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function (count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n      count -= skipBytes * 8;\n      workingBytesAvailable -= skipBytes;\n      this.loadWord();\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function (size) {\n    var bits = Math.min(workingBitsAvailable, size),\n      // :uint\n      valu = workingWord >>> 32 - bits; // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function () {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function () {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function () {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function () {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function () {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function () {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function () {\n    return this.readBits(8);\n  };\n  this.loadWord();\n};\nmodule.exports = ExpGolomb;","map":{"version":3,"names":["ExpGolomb","workingData","workingBytesAvailable","byteLength","workingWord","workingBitsAvailable","length","bitsAvailable","loadWord","position","workingBytes","Uint8Array","availableBytes","Math","min","Error","set","subarray","DataView","buffer","getUint32","skipBits","count","skipBytes","floor","readBits","size","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/exp-golomb.js"],"sourcesContent":["'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}