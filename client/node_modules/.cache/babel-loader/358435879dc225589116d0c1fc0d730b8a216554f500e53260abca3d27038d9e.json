{"ast":null,"code":"/**\n * @file master-playlist-controller.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x, _x2, _x3) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x,\n      property = _x2,\n      receiver = _x3;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x = parent;\n        _x2 = property;\n        _x3 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _playlistLoader = require('./playlist-loader');\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\nvar _playlistJs = require('./playlist.js');\nvar _segmentLoader = require('./segment-loader');\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\nvar _vttSegmentLoader = require('./vtt-segment-loader');\nvar _vttSegmentLoader2 = _interopRequireDefault(_vttSegmentLoader);\nvar _ranges = require('./ranges');\nvar _ranges2 = _interopRequireDefault(_ranges);\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _adCueTags = require('./ad-cue-tags');\nvar _adCueTags2 = _interopRequireDefault(_adCueTags);\nvar _syncController = require('./sync-controller');\nvar _syncController2 = _interopRequireDefault(_syncController);\nvar _videojsContribMediaSourcesEs5CodecUtils = require('videojs-contrib-media-sources/es5/codec-utils');\nvar _webwackify = require('webwackify');\nvar _webwackify2 = _interopRequireDefault(_webwackify);\nvar _decrypterWorker = require('./decrypter-worker');\nvar _decrypterWorker2 = _interopRequireDefault(_decrypterWorker);\nvar _config = require('./config');\nvar _config2 = _interopRequireDefault(_config);\nvar _utilCodecsJs = require('./util/codecs.js');\nvar _mediaGroups = require('./media-groups');\nvar ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\nvar Hls = undefined;\n\n// Default codec parameters if none were provided for video and/or audio\nvar defaultCodecs = {\n  videoCodec: 'avc1',\n  videoObjectTypeIndicator: '.4d400d',\n  // AAC-LC\n  audioProfile: '2'\n};\n\n// SegmentLoader stats that need to have each loader's\n// values summed to calculate the final value\nvar loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred'];\nvar sumLoaderStat = function sumLoaderStat(stat) {\n  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n};\nvar resolveDecrypterWorker = function resolveDecrypterWorker() {\n  var result = undefined;\n  try {\n    result = require.resolve('./decrypter-worker');\n  } catch (e) {\n    // no result\n  }\n  return result;\n};\n\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param codecString {String} the codec string\n * @return {String} the codec string with old apple-style codecs replaced\n *\n * @private\n */\nvar mapLegacyAvcCodecs_ = function mapLegacyAvcCodecs_(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return (0, _videojsContribMediaSourcesEs5CodecUtils.translateLegacyCodecs)([match])[0];\n  });\n};\nexports.mapLegacyAvcCodecs_ = mapLegacyAvcCodecs_;\n/**\n * Build a media mime-type string from a set of parameters\n * @param {String} type either 'audio' or 'video'\n * @param {String} container either 'mp2t' or 'mp4'\n * @param {Array} codecs an array of codec strings to add\n * @return {String} a valid media mime-type\n */\nvar makeMimeTypeString = function makeMimeTypeString(type, container, codecs) {\n  // The codecs array is filtered so that falsey values are\n  // dropped and don't cause Array#join to create spurious\n  // commas\n  return type + '/' + container + '; codecs=\"' + codecs.filter(function (c) {\n    return !!c;\n  }).join(', ') + '\"';\n};\n\n/**\n * Returns the type container based on information in the playlist\n * @param {Playlist} media the current media playlist\n * @return {String} a valid media container type\n */\nvar getContainerType = function getContainerType(media) {\n  // An initialization segment means the media playlist is an iframe\n  // playlist or is using the mp4 container. We don't currently\n  // support iframe playlists, so assume this is signalling mp4\n  // fragments.\n  if (media.segments && media.segments.length && media.segments[0].map) {\n    return 'mp4';\n  }\n  return 'mp2t';\n};\n\n/**\n * Returns a set of codec strings parsed from the playlist or the default\n * codec strings if no codecs were specified in the playlist\n * @param {Playlist} media the current media playlist\n * @return {Object} an object with the video and audio codecs\n */\nvar getCodecs = function getCodecs(media) {\n  // if the codecs were explicitly specified, use them instead of the\n  // defaults\n  var mediaAttributes = media.attributes || {};\n  if (mediaAttributes.CODECS) {\n    return (0, _utilCodecsJs.parseCodecs)(mediaAttributes.CODECS);\n  }\n  return defaultCodecs;\n};\n\n/**\n * Calculates the MIME type strings for a working configuration of\n * SourceBuffers to play variant streams in a master playlist. If\n * there is no possible working configuration, an empty array will be\n * returned.\n *\n * @param master {Object} the m3u8 object for the master playlist\n * @param media {Object} the m3u8 object for the variant playlist\n * @return {Array} the MIME type strings. If the array has more than\n * one entry, the first element should be applied to the video\n * SourceBuffer and the second to the audio SourceBuffer.\n *\n * @private\n */\nvar mimeTypesForPlaylist_ = function mimeTypesForPlaylist_(master, media) {\n  var containerType = getContainerType(media);\n  var codecInfo = getCodecs(media);\n  var mediaAttributes = media.attributes || {};\n  // Default condition for a traditional HLS (no demuxed audio/video)\n  var isMuxed = true;\n  var isMaat = false;\n  if (!media) {\n    // Not enough information\n    return [];\n  }\n  if (master.mediaGroups.AUDIO && mediaAttributes.AUDIO) {\n    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n\n    // Handle the case where we are in a multiple-audio track scenario\n    if (audioGroup) {\n      isMaat = true;\n      // Start with the everything demuxed then...\n      isMuxed = false;\n      // ...check to see if any audio group tracks are muxed (ie. lacking a uri)\n      for (var groupId in audioGroup) {\n        if (!audioGroup[groupId].uri) {\n          isMuxed = true;\n          break;\n        }\n      }\n    }\n  }\n\n  // HLS with multiple-audio tracks must always get an audio codec.\n  // Put another way, there is no way to have a video-only multiple-audio HLS!\n  if (isMaat && !codecInfo.audioProfile) {\n    _videoJs2['default'].log.warn('Multiple audio tracks present but no audio codec string is specified. ' + 'Attempting to use the default audio codec (mp4a.40.2)');\n    codecInfo.audioProfile = defaultCodecs.audioProfile;\n  }\n\n  // Generate the final codec strings from the codec object generated above\n  var codecStrings = {};\n  if (codecInfo.videoCodec) {\n    codecStrings.video = '' + codecInfo.videoCodec + codecInfo.videoObjectTypeIndicator;\n  }\n  if (codecInfo.audioProfile) {\n    codecStrings.audio = 'mp4a.40.' + codecInfo.audioProfile;\n  }\n\n  // Finally, make and return an array with proper mime-types depending on\n  // the configuration\n  var justAudio = makeMimeTypeString('audio', containerType, [codecStrings.audio]);\n  var justVideo = makeMimeTypeString('video', containerType, [codecStrings.video]);\n  var bothVideoAudio = makeMimeTypeString('video', containerType, [codecStrings.video, codecStrings.audio]);\n  if (isMaat) {\n    if (!isMuxed && codecStrings.video) {\n      return [justVideo, justAudio];\n    }\n    // There exists the possiblity that this will return a `video/container`\n    // mime-type for the first entry in the array even when there is only audio.\n    // This doesn't appear to be a problem and simplifies the code.\n    return [bothVideoAudio, justAudio];\n  }\n\n  // If there is ano video codec at all, always just return a single\n  // audio/<container> mime-type\n  if (!codecStrings.video) {\n    return [justAudio];\n  }\n\n  // When not using separate audio media groups, audio and video is\n  // *always* muxed\n  return [bothVideoAudio];\n};\nexports.mimeTypesForPlaylist_ = mimeTypesForPlaylist_;\n/**\n * the master playlist controller controls all interactons\n * between playlists and segmentloaders. At this time this mainly\n * involves a master playlist and a series of audio playlists\n * if they are available\n *\n * @class MasterPlaylistController\n * @extends videojs.EventTarget\n */\n\nvar MasterPlaylistController = function (_videojs$EventTarget) {\n  _inherits(MasterPlaylistController, _videojs$EventTarget);\n  function MasterPlaylistController(options) {\n    var _this = this;\n    _classCallCheck(this, MasterPlaylistController);\n    _get(Object.getPrototypeOf(MasterPlaylistController.prototype), 'constructor', this).call(this);\n    var url = options.url;\n    var handleManifestRedirects = options.handleManifestRedirects;\n    var withCredentials = options.withCredentials;\n    var mode = options.mode;\n    var tech = options.tech;\n    var bandwidth = options.bandwidth;\n    var externHls = options.externHls;\n    var useCueTags = options.useCueTags;\n    var blacklistDuration = options.blacklistDuration;\n    var enableLowInitialPlaylist = options.enableLowInitialPlaylist;\n    if (!url) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n    Hls = externHls;\n    this.tech_ = tech;\n    this.hls_ = tech.hls;\n    this.mode_ = mode;\n    this.useCueTags_ = useCueTags;\n    this.blacklistDuration = blacklistDuration;\n    this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n    if (this.useCueTags_) {\n      this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n      this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n    }\n    this.requestOptions_ = {\n      withCredentials: withCredentials,\n      handleManifestRedirects: handleManifestRedirects,\n      timeout: null\n    };\n    this.mediaTypes_ = (0, _mediaGroups.createMediaTypes)();\n    this.mediaSource = new _videoJs2['default'].MediaSource({\n      mode: mode\n    });\n\n    // load the media source into the player\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_.bind(this));\n    this.seekable_ = _videoJs2['default'].createTimeRanges();\n    this.hasPlayed_ = function () {\n      return false;\n    };\n    this.syncController_ = new _syncController2['default'](options);\n    this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'segment-metadata'\n    }, false).track;\n    this.decrypter_ = (0, _webwackify2['default'])(_decrypterWorker2['default'], resolveDecrypterWorker());\n    var segmentLoaderSettings = {\n      hls: this.hls_,\n      mediaSource: this.mediaSource,\n      currentTime: this.tech_.currentTime.bind(this.tech_),\n      seekable: function seekable() {\n        return _this.seekable();\n      },\n      seeking: function seeking() {\n        return _this.tech_.seeking();\n      },\n      duration: function duration() {\n        return _this.mediaSource.duration;\n      },\n      hasPlayed: function hasPlayed() {\n        return _this.hasPlayed_();\n      },\n      goalBufferLength: function goalBufferLength() {\n        return _this.goalBufferLength();\n      },\n      bandwidth: bandwidth,\n      syncController: this.syncController_,\n      decrypter: this.decrypter_\n    };\n\n    // setup playlist loaders\n    this.masterPlaylistLoader_ = new _playlistLoader2['default'](url, this.hls_, this.requestOptions_);\n    this.setupMasterPlaylistLoaderListeners_();\n\n    // setup segment loaders\n    // combined audio/video or just video when alternate audio track is selected\n    this.mainSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      segmentMetadataTrack: this.segmentMetadataTrack_,\n      loaderType: 'main'\n    }), options);\n\n    // alternate audio track\n    this.audioSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'audio'\n    }), options);\n    this.subtitleSegmentLoader_ = new _vttSegmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'vtt'\n    }), options);\n    this.setupSegmentLoaderListeners_();\n\n    // Create SegmentLoader stat-getters\n    loaderStats.forEach(function (stat) {\n      _this[stat + '_'] = sumLoaderStat.bind(_this, stat);\n    });\n    this.masterPlaylistLoader_.load();\n  }\n\n  /**\n   * Register event handlers on the master playlist loader. A helper\n   * function for construction time.\n   *\n   * @private\n   */\n\n  _createClass(MasterPlaylistController, [{\n    key: 'setupMasterPlaylistLoaderListeners_',\n    value: function setupMasterPlaylistLoaderListeners_() {\n      var _this2 = this;\n      this.masterPlaylistLoader_.on('loadedmetadata', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // if this isn't a live video and preload permits, start\n        // downloading segments\n        if (media.endList && _this2.tech_.preload() !== 'none') {\n          _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n          _this2.mainSegmentLoader_.load();\n        }\n        (0, _mediaGroups.setupMediaGroups)({\n          segmentLoaders: {\n            AUDIO: _this2.audioSegmentLoader_,\n            SUBTITLES: _this2.subtitleSegmentLoader_,\n            main: _this2.mainSegmentLoader_\n          },\n          tech: _this2.tech_,\n          requestOptions: _this2.requestOptions_,\n          masterPlaylistLoader: _this2.masterPlaylistLoader_,\n          mode: _this2.mode_,\n          hls: _this2.hls_,\n          master: _this2.master(),\n          mediaTypes: _this2.mediaTypes_,\n          blacklistCurrentPlaylist: _this2.blacklistCurrentPlaylist.bind(_this2)\n        });\n        _this2.triggerPresenceUsage_(_this2.master(), media);\n        try {\n          _this2.setupSourceBuffers_();\n        } catch (e) {\n          _videoJs2['default'].log.warn('Failed to create SourceBuffers', e);\n          return _this2.mediaSource.endOfStream('decode');\n        }\n        _this2.setupFirstPlay();\n        _this2.trigger('selectedinitialmedia');\n      });\n      this.masterPlaylistLoader_.on('loadedplaylist', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n        if (!updatedPlaylist) {\n          var selectedMedia = undefined;\n          if (_this2.enableLowInitialPlaylist) {\n            selectedMedia = _this2.selectInitialPlaylist();\n          }\n          if (!selectedMedia) {\n            selectedMedia = _this2.selectPlaylist();\n          }\n          _this2.initialMedia_ = selectedMedia;\n          _this2.masterPlaylistLoader_.media(_this2.initialMedia_);\n          return;\n        }\n        if (_this2.useCueTags_) {\n          _this2.updateAdCues_(updatedPlaylist);\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `mediachange`\n        _this2.mainSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\n        _this2.updateDuration();\n\n        // If the player isn't paused, ensure that the segment loader is running,\n        // as it is possible that it was temporarily stopped while waiting for\n        // a playlist (e.g., in case the playlist errored and we re-requested it).\n        if (!_this2.tech_.paused()) {\n          _this2.mainSegmentLoader_.load();\n        }\n        if (!updatedPlaylist.endList) {\n          (function () {\n            var addSeekableRange = function addSeekableRange() {\n              var seekable = _this2.seekable();\n              if (seekable.length !== 0) {\n                _this2.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));\n              }\n            };\n            if (_this2.duration() !== Infinity) {\n              (function () {\n                var onDurationchange = function onDurationchange() {\n                  if (_this2.duration() === Infinity) {\n                    addSeekableRange();\n                  } else {\n                    _this2.tech_.one('durationchange', onDurationchange);\n                  }\n                };\n                _this2.tech_.one('durationchange', onDurationchange);\n              })();\n            } else {\n              addSeekableRange();\n            }\n          })();\n        }\n      });\n      this.masterPlaylistLoader_.on('error', function () {\n        _this2.blacklistCurrentPlaylist(_this2.masterPlaylistLoader_.error);\n      });\n      this.masterPlaylistLoader_.on('mediachanging', function () {\n        _this2.mainSegmentLoader_.abort();\n        _this2.mainSegmentLoader_.pause();\n      });\n      this.masterPlaylistLoader_.on('mediachange', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `loadedplaylist`\n        _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n        _this2.mainSegmentLoader_.load();\n        _this2.tech_.trigger({\n          type: 'mediachange',\n          bubbles: true\n        });\n      });\n      this.masterPlaylistLoader_.on('playlistunchanged', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n        var playlistOutdated = _this2.stuckAtPlaylistEnd_(updatedPlaylist);\n        if (playlistOutdated) {\n          // Playlist has stopped updating and we're stuck at its end. Try to\n          // blacklist it and switch to another playlist in the hope that that\n          // one is updating (and give the player a chance to re-adjust to the\n          // safe live point).\n          _this2.blacklistCurrentPlaylist({\n            message: 'Playlist no longer updating.'\n          });\n          // useful for monitoring QoS\n          _this2.tech_.trigger('playliststuck');\n        }\n      });\n      this.masterPlaylistLoader_.on('renditiondisabled', function () {\n        _this2.tech_.trigger({\n          type: 'usage',\n          name: 'hls-rendition-disabled'\n        });\n      });\n      this.masterPlaylistLoader_.on('renditionenabled', function () {\n        _this2.tech_.trigger({\n          type: 'usage',\n          name: 'hls-rendition-enabled'\n        });\n      });\n    }\n\n    /**\n     * A helper function for triggerring presence usage events once per source\n     *\n     * @private\n     */\n  }, {\n    key: 'triggerPresenceUsage_',\n    value: function triggerPresenceUsage_(master, media) {\n      var mediaGroups = master.mediaGroups || {};\n      var defaultDemuxed = true;\n      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n      for (var mediaGroup in mediaGroups.AUDIO) {\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\n          if (!properties.uri) {\n            defaultDemuxed = false;\n          }\n        }\n      }\n      if (defaultDemuxed) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-demuxed'\n        });\n      }\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-webvtt'\n        });\n      }\n      if (Hls.Playlist.isAes(media)) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-aes'\n        });\n      }\n      if (Hls.Playlist.isFmp4(media)) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-fmp4'\n        });\n      }\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-alternate-audio'\n        });\n      }\n      if (this.useCueTags_) {\n        this.tech_.trigger({\n          type: 'usage',\n          name: 'hls-playlist-cue-tags'\n        });\n      }\n    }\n\n    /**\n     * Register event handlers on the segment loaders. A helper function\n     * for construction time.\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSegmentLoaderListeners_',\n    value: function setupSegmentLoaderListeners_() {\n      var _this3 = this;\n      this.mainSegmentLoader_.on('bandwidthupdate', function () {\n        var nextPlaylist = _this3.selectPlaylist();\n        var currentPlaylist = _this3.masterPlaylistLoader_.media();\n        var buffered = _this3.tech_.buffered();\n        var forwardBuffer = buffered.length ? buffered.end(buffered.length - 1) - _this3.tech_.currentTime() : 0;\n        var bufferLowWaterLine = _this3.bufferLowWaterLine();\n\n        // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n        if (!currentPlaylist.endList ||\n        // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n        _this3.duration() < _config2['default'].MAX_BUFFER_LOW_WATER_LINE ||\n        // we want to switch down to lower resolutions quickly to continue playback, but\n        nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH ||\n        // ensure we have some buffer before we switch up to prevent us running out of\n        // buffer while loading a higher rendition.\n        forwardBuffer >= bufferLowWaterLine) {\n          _this3.masterPlaylistLoader_.media(nextPlaylist);\n        }\n        _this3.tech_.trigger('bandwidthupdate');\n      });\n      this.mainSegmentLoader_.on('progress', function () {\n        _this3.trigger('progress');\n      });\n      this.mainSegmentLoader_.on('error', function () {\n        _this3.blacklistCurrentPlaylist(_this3.mainSegmentLoader_.error());\n      });\n      this.mainSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n      this.mainSegmentLoader_.on('timestampoffset', function () {\n        _this3.tech_.trigger({\n          type: 'usage',\n          name: 'hls-timestamp-offset'\n        });\n      });\n      this.audioSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n      this.mainSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n      this.mainSegmentLoader_.on('earlyabort', function () {\n        _this3.blacklistCurrentPlaylist({\n          message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\n        }, ABORT_EARLY_BLACKLIST_SECONDS);\n      });\n      this.mainSegmentLoader_.on('reseteverything', function () {\n        // If playing an MTS stream, a videojs.MediaSource is listening for\n        // hls-reset to reset caption parsing state in the transmuxer\n        _this3.tech_.trigger('hls-reset');\n      });\n      this.mainSegmentLoader_.on('segmenttimemapping', function (event) {\n        // If playing an MTS stream in html, a videojs.MediaSource is listening for\n        // hls-segment-time-mapping update its internal mapping of stream to display time\n        _this3.tech_.trigger({\n          type: 'hls-segment-time-mapping',\n          mapping: event.mapping\n        });\n      });\n      this.audioSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n    }\n  }, {\n    key: 'mediaSecondsLoaded_',\n    value: function mediaSecondsLoaded_() {\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n    }\n\n    /**\n     * Call load on our SegmentLoaders\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      this.mainSegmentLoader_.load();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.load();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.load();\n      }\n    }\n\n    /**\n     * Re-tune playback quality level for the current player\n     * conditions. This method may perform destructive actions, like\n     * removing already buffered content, to readjust the currently\n     * active playlist quickly.\n     *\n     * @private\n     */\n  }, {\n    key: 'fastQualityChange_',\n    value: function fastQualityChange_() {\n      var media = this.selectPlaylist();\n      if (media !== this.masterPlaylistLoader_.media()) {\n        this.masterPlaylistLoader_.media(media);\n        this.mainSegmentLoader_.resetLoader();\n        // don't need to reset audio as it is reset when media changes\n      }\n    }\n\n    /**\n     * Begin playback.\n     */\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.setupFirstPlay()) {\n        return;\n      }\n      if (this.tech_.ended()) {\n        this.tech_.setCurrentTime(0);\n      }\n      if (this.hasPlayed_()) {\n        this.load();\n      }\n      var seekable = this.tech_.seekable();\n\n      // if the viewer has paused and we fell out of the live window,\n      // seek forward to the live point\n      if (this.tech_.duration() === Infinity) {\n        if (this.tech_.currentTime() < seekable.start(0)) {\n          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n        }\n      }\n    }\n\n    /**\n     * Seek to the latest media position if this is a live video and the\n     * player and video are loaded and initialized.\n     */\n  }, {\n    key: 'setupFirstPlay',\n    value: function setupFirstPlay() {\n      var _this4 = this;\n      var media = this.masterPlaylistLoader_.media();\n\n      // Check that everything is ready to begin buffering for the first call to play\n      //  If 1) there is no active media\n      //     2) the player is paused\n      //     3) the first play has already been setup\n      // then exit early\n      if (!media || this.tech_.paused() || this.hasPlayed_()) {\n        return false;\n      }\n\n      // when the video is a live stream\n      if (!media.endList) {\n        var _ret3 = function () {\n          var seekable = _this4.seekable();\n          if (!seekable.length) {\n            // without a seekable range, the player cannot seek to begin buffering at the live\n            // point\n            return {\n              v: false\n            };\n          }\n          if (_videoJs2['default'].browser.IE_VERSION && _this4.mode_ === 'html5' && _this4.tech_.readyState() === 0) {\n            // IE11 throws an InvalidStateError if you try to set currentTime while the\n            // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n            _this4.tech_.one('loadedmetadata', function () {\n              _this4.trigger('firstplay');\n              _this4.tech_.setCurrentTime(seekable.end(0));\n              _this4.hasPlayed_ = function () {\n                return true;\n              };\n            });\n            return {\n              v: false\n            };\n          }\n\n          // trigger firstplay to inform the source handler to ignore the next seek event\n          _this4.trigger('firstplay');\n          // seek to the live point\n          _this4.tech_.setCurrentTime(seekable.end(0));\n        }();\n        if (typeof _ret3 === 'object') return _ret3.v;\n      }\n      this.hasPlayed_ = function () {\n        return true;\n      };\n      // we can begin loading now that everything is ready\n      this.load();\n      return true;\n    }\n\n    /**\n     * handle the sourceopen event on the MediaSource\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSourceOpen_',\n    value: function handleSourceOpen_() {\n      // Only attempt to create the source buffer if none already exist.\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n      // after `endOfStream` has been called (in response to a seek for instance)\n      try {\n        this.setupSourceBuffers_();\n      } catch (e) {\n        _videoJs2['default'].log.warn('Failed to create Source Buffers', e);\n        return this.mediaSource.endOfStream('decode');\n      }\n\n      // if autoplay is enabled, begin playback. This is duplicative of\n      // code in video.js but is required because play() must be invoked\n      // *after* the media source has opened.\n      if (this.tech_.autoplay()) {\n        var playPromise = this.tech_.play();\n\n        // Catch/silence error when a pause interrupts a play request\n        // on browsers which return a promise\n        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n          playPromise.then(null, function (e) {});\n        }\n      }\n      this.trigger('sourceopen');\n    }\n\n    /**\n     * Calls endOfStream on the media source when all active stream types have called\n     * endOfStream\n     *\n     * @param {string} streamType\n     *        Stream type of the segment loader that called endOfStream\n     * @private\n     */\n  }, {\n    key: 'onEndOfStream',\n    value: function onEndOfStream() {\n      var isEndOfStream = this.mainSegmentLoader_.ended_;\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        // if the audio playlist loader exists, then alternate audio is active, so we need\n        // to wait for both the main and audio segment loaders to call endOfStream\n        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n      }\n      if (isEndOfStream) {\n        this.mediaSource.endOfStream();\n      }\n    }\n\n    /**\n     * Check if a playlist has stopped being updated\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist has stopped being updated or not\n     */\n  }, {\n    key: 'stuckAtPlaylistEnd_',\n    value: function stuckAtPlaylistEnd_(playlist) {\n      var seekable = this.seekable();\n      if (!seekable.length) {\n        // playlist doesn't have enough information to determine whether we are stuck\n        return false;\n      }\n      var expired = this.syncController_.getExpiredTime(playlist, this.mediaSource.duration);\n      if (expired === null) {\n        return false;\n      }\n\n      // does not use the safe live end to calculate playlist end, since we\n      // don't want to say we are stuck while there is still content\n      var absolutePlaylistEnd = Hls.Playlist.playlistEnd(playlist, expired);\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n      if (!buffered.length) {\n        // return true if the playhead reached the absolute end of the playlist\n        return absolutePlaylistEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA;\n      }\n      var bufferedEnd = buffered.end(buffered.length - 1);\n\n      // return true if there is too little buffer left and buffer has reached absolute\n      // end of playlist\n      return bufferedEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= _ranges2['default'].SAFE_TIME_DELTA;\n    }\n\n    /**\n     * Blacklists a playlist when an error occurs for a set amount of time\n     * making it unavailable for selection by the rendition selection algorithm\n     * and then forces a new playlist (rendition) selection.\n     *\n     * @param {Object=} error an optional error that may include the playlist\n     * to blacklist\n     * @param {Number=} blacklistDuration an optional number of seconds to blacklist the\n     * playlist\n     */\n  }, {\n    key: 'blacklistCurrentPlaylist',\n    value: function blacklistCurrentPlaylist(error, blacklistDuration) {\n      if (error === undefined) error = {};\n      var currentPlaylist = undefined;\n      var nextPlaylist = undefined;\n\n      // If the `error` was generated by the playlist loader, it will contain\n      // the playlist we were trying to load (but failed) and that should be\n      // blacklisted instead of the currently selected playlist which is likely\n      // out-of-date in this scenario\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;\n\n      // If there is no current playlist, then an error occurred while we were\n      // trying to load the master OR while we were disposing of the tech\n      if (!currentPlaylist) {\n        this.error = error;\n        try {\n          return this.mediaSource.endOfStream('network');\n        } catch (e) {\n          return this.trigger('error');\n        }\n      }\n      var isFinalRendition = this.masterPlaylistLoader_.master.playlists.filter(_playlistJs.isEnabled).length === 1;\n      if (isFinalRendition) {\n        // Never blacklisting this playlist because it's final rendition\n        _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. Trying again since it is the final playlist.');\n        this.tech_.trigger('retryplaylist');\n        return this.masterPlaylistLoader_.load(isFinalRendition);\n      }\n      // Blacklist this playlist\n      currentPlaylist.excludeUntil = Date.now() + blacklistDuration * 1000;\n      this.tech_.trigger('blacklistplaylist');\n      this.tech_.trigger({\n        type: 'usage',\n        name: 'hls-rendition-blacklisted'\n      });\n\n      // Select a new playlist\n      nextPlaylist = this.selectPlaylist();\n      _videoJs2['default'].log.warn('Problem encountered with the current HLS playlist.' + (error.message ? ' ' + error.message : '') + ' Switching to another playlist.');\n      return this.masterPlaylistLoader_.media(nextPlaylist);\n    }\n\n    /**\n     * Pause all segment loaders\n     */\n  }, {\n    key: 'pauseLoading',\n    value: function pauseLoading() {\n      this.mainSegmentLoader_.pause();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.pause();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.pause();\n      }\n    }\n\n    /**\n     * set the current time on all segment loaders\n     *\n     * @param {TimeRange} currentTime the current time to set\n     * @return {TimeRange} the current time\n     */\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      var buffered = _ranges2['default'].findRange(this.tech_.buffered(), currentTime);\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\n        // return immediately if the metadata is not ready yet\n        return 0;\n      }\n\n      // it's clearly an edge-case but don't thrown an error if asked to\n      // seek within an empty playlist\n      if (!this.masterPlaylistLoader_.media().segments) {\n        return 0;\n      }\n\n      // In flash playback, the segment loaders should be reset on every seek, even\n      // in buffer seeks. If the seek location is already buffered, continue buffering as\n      // usual\n      if (buffered && buffered.length && this.mode_ !== 'flash') {\n        return currentTime;\n      }\n\n      // cancel outstanding requests so we begin buffering at the new\n      // location\n      this.mainSegmentLoader_.resetEverything();\n      this.mainSegmentLoader_.abort();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.resetEverything();\n        this.audioSegmentLoader_.abort();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.resetEverything();\n        this.subtitleSegmentLoader_.abort();\n      }\n\n      // start segment loader loading in case they are paused\n      this.load();\n    }\n\n    /**\n     * get the current duration\n     *\n     * @return {TimeRange} the duration\n     */\n  }, {\n    key: 'duration',\n    value: function duration() {\n      if (!this.masterPlaylistLoader_) {\n        return 0;\n      }\n      if (this.mediaSource) {\n        return this.mediaSource.duration;\n      }\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n    }\n\n    /**\n     * check the seekable range\n     *\n     * @return {TimeRange} the seekable range\n     */\n  }, {\n    key: 'seekable',\n    value: function seekable() {\n      return this.seekable_;\n    }\n  }, {\n    key: 'onSyncInfoUpdate_',\n    value: function onSyncInfoUpdate_() {\n      var mainSeekable = undefined;\n      var audioSeekable = undefined;\n      if (!this.masterPlaylistLoader_) {\n        return;\n      }\n      var media = this.masterPlaylistLoader_.media();\n      if (!media) {\n        return;\n      }\n      var expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n      if (expired === null) {\n        // not enough information to update seekable\n        return;\n      }\n      mainSeekable = Hls.Playlist.seekable(media, expired);\n      if (mainSeekable.length === 0) {\n        return;\n      }\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n        expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n        if (expired === null) {\n          return;\n        }\n        audioSeekable = Hls.Playlist.seekable(media, expired);\n        if (audioSeekable.length === 0) {\n          return;\n        }\n      }\n      if (!audioSeekable) {\n        // seekable has been calculated based on buffering video data so it\n        // can be returned directly\n        this.seekable_ = mainSeekable;\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n        // seekables are pretty far off, rely on main\n        this.seekable_ = mainSeekable;\n      } else {\n        this.seekable_ = _videoJs2['default'].createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n      }\n      this.tech_.trigger('seekablechanged');\n    }\n\n    /**\n     * Update the player duration\n     */\n  }, {\n    key: 'updateDuration',\n    value: function updateDuration() {\n      var _this5 = this;\n      var oldDuration = this.mediaSource.duration;\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n      var buffered = this.tech_.buffered();\n      var setDuration = function setDuration() {\n        _this5.mediaSource.duration = newDuration;\n        _this5.tech_.trigger('durationchange');\n        _this5.mediaSource.removeEventListener('sourceopen', setDuration);\n      };\n      if (buffered.length > 0) {\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\n      }\n\n      // if the duration has changed, invalidate the cached value\n      if (oldDuration !== newDuration) {\n        // update the duration\n        if (this.mediaSource.readyState !== 'open') {\n          this.mediaSource.addEventListener('sourceopen', setDuration);\n        } else {\n          setDuration();\n        }\n      }\n    }\n\n    /**\n     * dispose of the MasterPlaylistController and everything\n     * that it controls\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      var _this6 = this;\n      this.decrypter_.terminate();\n      this.masterPlaylistLoader_.dispose();\n      this.mainSegmentLoader_.dispose();\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n        var groups = _this6.mediaTypes_[type].groups;\n        for (var id in groups) {\n          groups[id].forEach(function (group) {\n            if (group.playlistLoader) {\n              group.playlistLoader.dispose();\n            }\n          });\n        }\n      });\n      this.audioSegmentLoader_.dispose();\n      this.subtitleSegmentLoader_.dispose();\n    }\n\n    /**\n     * return the master playlist object if we have one\n     *\n     * @return {Object} the master playlist object that we parsed\n     */\n  }, {\n    key: 'master',\n    value: function master() {\n      return this.masterPlaylistLoader_.master;\n    }\n\n    /**\n     * return the currently selected playlist\n     *\n     * @return {Object} the currently selected playlist object that we parsed\n     */\n  }, {\n    key: 'media',\n    value: function media() {\n      // playlist loader will not return media if it has not been fully loaded\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\n    }\n\n    /**\n     * setup our internal source buffers on our segment Loaders\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSourceBuffers_',\n    value: function setupSourceBuffers_() {\n      var media = this.masterPlaylistLoader_.media();\n      var mimeTypes = undefined;\n\n      // wait until a media playlist is available and the Media Source is\n      // attached\n      if (!media || this.mediaSource.readyState !== 'open') {\n        return;\n      }\n      mimeTypes = mimeTypesForPlaylist_(this.masterPlaylistLoader_.master, media);\n      if (mimeTypes.length < 1) {\n        this.error = 'No compatible SourceBuffer configuration for the variant stream:' + media.resolvedUri;\n        return this.mediaSource.endOfStream('decode');\n      }\n      this.mainSegmentLoader_.mimeType(mimeTypes[0]);\n      if (mimeTypes[1]) {\n        this.audioSegmentLoader_.mimeType(mimeTypes[1]);\n      }\n\n      // exclude any incompatible variant streams from future playlist\n      // selection\n      this.excludeIncompatibleVariants_(media);\n    }\n\n    /**\n     * Blacklist playlists that are known to be codec or\n     * stream-incompatible with the SourceBuffer configuration. For\n     * instance, Media Source Extensions would cause the video element to\n     * stall waiting for video data if you switched from a variant with\n     * video and audio to an audio-only one.\n     *\n     * @param {Object} media a media playlist compatible with the current\n     * set of SourceBuffers. Variants in the current master playlist that\n     * do not appear to have compatible codec or stream configurations\n     * will be excluded from the default playlist selection algorithm\n     * indefinitely.\n     * @private\n     */\n  }, {\n    key: 'excludeIncompatibleVariants_',\n    value: function excludeIncompatibleVariants_(media) {\n      var master = this.masterPlaylistLoader_.master;\n      var codecCount = 2;\n      var videoCodec = null;\n      var codecs = undefined;\n      if (media.attributes.CODECS) {\n        codecs = (0, _utilCodecsJs.parseCodecs)(media.attributes.CODECS);\n        videoCodec = codecs.videoCodec;\n        codecCount = codecs.codecCount;\n      }\n      master.playlists.forEach(function (variant) {\n        var variantCodecs = {\n          codecCount: 2,\n          videoCodec: null\n        };\n        if (variant.attributes.CODECS) {\n          var codecString = variant.attributes.CODECS;\n          variantCodecs = (0, _utilCodecsJs.parseCodecs)(codecString);\n          if (window.MediaSource && window.MediaSource.isTypeSupported && !window.MediaSource.isTypeSupported('video/mp4; codecs=\"' + mapLegacyAvcCodecs_(codecString) + '\"')) {\n            variant.excludeUntil = Infinity;\n          }\n        }\n\n        // if the streams differ in the presence or absence of audio or\n        // video, they are incompatible\n        if (variantCodecs.codecCount !== codecCount) {\n          variant.excludeUntil = Infinity;\n        }\n\n        // if h.264 is specified on the current playlist, some flavor of\n        // it must be specified on all compatible variants\n        if (variantCodecs.videoCodec !== videoCodec) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n    }\n  }, {\n    key: 'updateAdCues_',\n    value: function updateAdCues_(media) {\n      var offset = 0;\n      var seekable = this.seekable();\n      if (seekable.length) {\n        offset = seekable.start(0);\n      }\n      _adCueTags2['default'].updateAdCues(media, this.cueTagsTrack_, offset);\n    }\n\n    /**\n     * Calculates the desired forward buffer length based on current time\n     *\n     * @return {Number} Desired forward buffer length in seconds\n     */\n  }, {\n    key: 'goalBufferLength',\n    value: function goalBufferLength() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].GOAL_BUFFER_LENGTH;\n      var rate = _config2['default'].GOAL_BUFFER_LENGTH_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_GOAL_BUFFER_LENGTH);\n      return Math.min(initial + currentTime * rate, max);\n    }\n\n    /**\n     * Calculates the desired buffer low water line based on current time\n     *\n     * @return {Number} Desired buffer low water line in seconds\n     */\n  }, {\n    key: 'bufferLowWaterLine',\n    value: function bufferLowWaterLine() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].BUFFER_LOW_WATER_LINE;\n      var rate = _config2['default'].BUFFER_LOW_WATER_LINE_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_BUFFER_LOW_WATER_LINE);\n      return Math.min(initial + currentTime * rate, max);\n    }\n  }]);\n  return MasterPlaylistController;\n}(_videoJs2['default'].EventTarget);\nexports.MasterPlaylistController = MasterPlaylistController;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x","_x2","_x3","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_playlistLoader","require","_playlistLoader2","_playlistJs","_segmentLoader","_segmentLoader2","_vttSegmentLoader","_vttSegmentLoader2","_ranges","_ranges2","_videoJs","_videoJs2","_adCueTags","_adCueTags2","_syncController","_syncController2","_videojsContribMediaSourcesEs5CodecUtils","_webwackify","_webwackify2","_decrypterWorker","_decrypterWorker2","_config","_config2","_utilCodecsJs","_mediaGroups","ABORT_EARLY_BLACKLIST_SECONDS","Hls","defaultCodecs","videoCodec","videoObjectTypeIndicator","audioProfile","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","resolveDecrypterWorker","result","resolve","e","mapLegacyAvcCodecs_","codecString","replace","match","translateLegacyCodecs","makeMimeTypeString","type","container","codecs","filter","c","join","getContainerType","media","segments","map","getCodecs","mediaAttributes","attributes","CODECS","parseCodecs","mimeTypesForPlaylist_","master","containerType","codecInfo","isMuxed","isMaat","mediaGroups","AUDIO","audioGroup","groupId","uri","log","warn","codecStrings","video","audio","justAudio","justVideo","bothVideoAudio","MasterPlaylistController","_videojs$EventTarget","options","_this","url","handleManifestRedirects","withCredentials","mode","tech","bandwidth","externHls","useCueTags","blacklistDuration","enableLowInitialPlaylist","Error","tech_","hls_","hls","mode_","useCueTags_","cueTagsTrack_","addTextTrack","inBandMetadataTrackDispatchType","requestOptions_","timeout","mediaTypes_","createMediaTypes","mediaSource","MediaSource","addEventListener","handleSourceOpen_","bind","seekable_","createTimeRanges","hasPlayed_","syncController_","segmentMetadataTrack_","addRemoteTextTrack","kind","label","track","decrypter_","segmentLoaderSettings","currentTime","seekable","seeking","duration","hasPlayed","goalBufferLength","syncController","decrypter","masterPlaylistLoader_","setupMasterPlaylistLoaderListeners_","mergeOptions","segmentMetadataTrack","loaderType","subtitleSegmentLoader_","setupSegmentLoaderListeners_","forEach","load","_this2","on","requestTimeout","targetDuration","isLowestEnabledRendition","endList","preload","playlist","setupMediaGroups","segmentLoaders","SUBTITLES","main","requestOptions","masterPlaylistLoader","mediaTypes","blacklistCurrentPlaylist","triggerPresenceUsage_","setupSourceBuffers_","endOfStream","setupFirstPlay","trigger","updatedPlaylist","selectedMedia","selectInitialPlaylist","selectPlaylist","initialMedia_","updateAdCues_","updateDuration","paused","addSeekableRange","addSeekableRange_","start","end","Infinity","onDurationchange","one","error","abort","pause","bubbles","playlistOutdated","stuckAtPlaylistEnd_","message","name","defaultDemuxed","audioGroupKeys","keys","mediaGroup","properties","Playlist","isAes","isFmp4","_this3","nextPlaylist","currentPlaylist","buffered","forwardBuffer","bufferLowWaterLine","MAX_BUFFER_LOW_WATER_LINE","BANDWIDTH","onSyncInfoUpdate_","onEndOfStream","event","mapping","mediaSecondsLoaded_","Math","max","mediaSecondsLoaded","activePlaylistLoader","fastQualityChange_","resetLoader","play","ended","setCurrentTime","_this4","_ret3","v","browser","IE_VERSION","readyState","autoplay","playPromise","then","isEndOfStream","ended_","expired","getExpiredTime","absolutePlaylistEnd","playlistEnd","SAFE_TIME_DELTA","bufferedEnd","isFinalRendition","playlists","isEnabled","excludeUntil","Date","now","pauseLoading","findRange","resetEverything","mainSeekable","audioSeekable","_this5","oldDuration","newDuration","setDuration","removeEventListener","dispose","_this6","terminate","groups","id","group","playlistLoader","mimeTypes","resolvedUri","mimeType","excludeIncompatibleVariants_","codecCount","variant","variantCodecs","window","isTypeSupported","offset","updateAdCues","initial","GOAL_BUFFER_LENGTH","rate","GOAL_BUFFER_LENGTH_RATE","MAX_GOAL_BUFFER_LENGTH","min","BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","EventTarget"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/master-playlist-controller.js"],"sourcesContent":["/**\n * @file master-playlist-controller.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _playlistLoader = require('./playlist-loader');\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _playlistJs = require('./playlist.js');\n\nvar _segmentLoader = require('./segment-loader');\n\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\n\nvar _vttSegmentLoader = require('./vtt-segment-loader');\n\nvar _vttSegmentLoader2 = _interopRequireDefault(_vttSegmentLoader);\n\nvar _ranges = require('./ranges');\n\nvar _ranges2 = _interopRequireDefault(_ranges);\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _adCueTags = require('./ad-cue-tags');\n\nvar _adCueTags2 = _interopRequireDefault(_adCueTags);\n\nvar _syncController = require('./sync-controller');\n\nvar _syncController2 = _interopRequireDefault(_syncController);\n\nvar _videojsContribMediaSourcesEs5CodecUtils = require('videojs-contrib-media-sources/es5/codec-utils');\n\nvar _webwackify = require('webwackify');\n\nvar _webwackify2 = _interopRequireDefault(_webwackify);\n\nvar _decrypterWorker = require('./decrypter-worker');\n\nvar _decrypterWorker2 = _interopRequireDefault(_decrypterWorker);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utilCodecsJs = require('./util/codecs.js');\n\nvar _mediaGroups = require('./media-groups');\n\nvar ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\n\nvar Hls = undefined;\n\n// Default codec parameters if none were provided for video and/or audio\nvar defaultCodecs = {\n  videoCodec: 'avc1',\n  videoObjectTypeIndicator: '.4d400d',\n  // AAC-LC\n  audioProfile: '2'\n};\n\n// SegmentLoader stats that need to have each loader's\n// values summed to calculate the final value\nvar loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred'];\nvar sumLoaderStat = function sumLoaderStat(stat) {\n  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n};\n\nvar resolveDecrypterWorker = function resolveDecrypterWorker() {\n  var result = undefined;\n\n  try {\n    result = require.resolve('./decrypter-worker');\n  } catch (e) {\n    // no result\n  }\n\n  return result;\n};\n\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param codecString {String} the codec string\n * @return {String} the codec string with old apple-style codecs replaced\n *\n * @private\n */\nvar mapLegacyAvcCodecs_ = function mapLegacyAvcCodecs_(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return (0, _videojsContribMediaSourcesEs5CodecUtils.translateLegacyCodecs)([match])[0];\n  });\n};\n\nexports.mapLegacyAvcCodecs_ = mapLegacyAvcCodecs_;\n/**\n * Build a media mime-type string from a set of parameters\n * @param {String} type either 'audio' or 'video'\n * @param {String} container either 'mp2t' or 'mp4'\n * @param {Array} codecs an array of codec strings to add\n * @return {String} a valid media mime-type\n */\nvar makeMimeTypeString = function makeMimeTypeString(type, container, codecs) {\n  // The codecs array is filtered so that falsey values are\n  // dropped and don't cause Array#join to create spurious\n  // commas\n  return type + '/' + container + '; codecs=\"' + codecs.filter(function (c) {\n    return !!c;\n  }).join(', ') + '\"';\n};\n\n/**\n * Returns the type container based on information in the playlist\n * @param {Playlist} media the current media playlist\n * @return {String} a valid media container type\n */\nvar getContainerType = function getContainerType(media) {\n  // An initialization segment means the media playlist is an iframe\n  // playlist or is using the mp4 container. We don't currently\n  // support iframe playlists, so assume this is signalling mp4\n  // fragments.\n  if (media.segments && media.segments.length && media.segments[0].map) {\n    return 'mp4';\n  }\n  return 'mp2t';\n};\n\n/**\n * Returns a set of codec strings parsed from the playlist or the default\n * codec strings if no codecs were specified in the playlist\n * @param {Playlist} media the current media playlist\n * @return {Object} an object with the video and audio codecs\n */\nvar getCodecs = function getCodecs(media) {\n  // if the codecs were explicitly specified, use them instead of the\n  // defaults\n  var mediaAttributes = media.attributes || {};\n\n  if (mediaAttributes.CODECS) {\n    return (0, _utilCodecsJs.parseCodecs)(mediaAttributes.CODECS);\n  }\n  return defaultCodecs;\n};\n\n/**\n * Calculates the MIME type strings for a working configuration of\n * SourceBuffers to play variant streams in a master playlist. If\n * there is no possible working configuration, an empty array will be\n * returned.\n *\n * @param master {Object} the m3u8 object for the master playlist\n * @param media {Object} the m3u8 object for the variant playlist\n * @return {Array} the MIME type strings. If the array has more than\n * one entry, the first element should be applied to the video\n * SourceBuffer and the second to the audio SourceBuffer.\n *\n * @private\n */\nvar mimeTypesForPlaylist_ = function mimeTypesForPlaylist_(master, media) {\n  var containerType = getContainerType(media);\n  var codecInfo = getCodecs(media);\n  var mediaAttributes = media.attributes || {};\n  // Default condition for a traditional HLS (no demuxed audio/video)\n  var isMuxed = true;\n  var isMaat = false;\n\n  if (!media) {\n    // Not enough information\n    return [];\n  }\n\n  if (master.mediaGroups.AUDIO && mediaAttributes.AUDIO) {\n    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n\n    // Handle the case where we are in a multiple-audio track scenario\n    if (audioGroup) {\n      isMaat = true;\n      // Start with the everything demuxed then...\n      isMuxed = false;\n      // ...check to see if any audio group tracks are muxed (ie. lacking a uri)\n      for (var groupId in audioGroup) {\n        if (!audioGroup[groupId].uri) {\n          isMuxed = true;\n          break;\n        }\n      }\n    }\n  }\n\n  // HLS with multiple-audio tracks must always get an audio codec.\n  // Put another way, there is no way to have a video-only multiple-audio HLS!\n  if (isMaat && !codecInfo.audioProfile) {\n    _videoJs2['default'].log.warn('Multiple audio tracks present but no audio codec string is specified. ' + 'Attempting to use the default audio codec (mp4a.40.2)');\n    codecInfo.audioProfile = defaultCodecs.audioProfile;\n  }\n\n  // Generate the final codec strings from the codec object generated above\n  var codecStrings = {};\n\n  if (codecInfo.videoCodec) {\n    codecStrings.video = '' + codecInfo.videoCodec + codecInfo.videoObjectTypeIndicator;\n  }\n\n  if (codecInfo.audioProfile) {\n    codecStrings.audio = 'mp4a.40.' + codecInfo.audioProfile;\n  }\n\n  // Finally, make and return an array with proper mime-types depending on\n  // the configuration\n  var justAudio = makeMimeTypeString('audio', containerType, [codecStrings.audio]);\n  var justVideo = makeMimeTypeString('video', containerType, [codecStrings.video]);\n  var bothVideoAudio = makeMimeTypeString('video', containerType, [codecStrings.video, codecStrings.audio]);\n\n  if (isMaat) {\n    if (!isMuxed && codecStrings.video) {\n      return [justVideo, justAudio];\n    }\n    // There exists the possiblity that this will return a `video/container`\n    // mime-type for the first entry in the array even when there is only audio.\n    // This doesn't appear to be a problem and simplifies the code.\n    return [bothVideoAudio, justAudio];\n  }\n\n  // If there is ano video codec at all, always just return a single\n  // audio/<container> mime-type\n  if (!codecStrings.video) {\n    return [justAudio];\n  }\n\n  // When not using separate audio media groups, audio and video is\n  // *always* muxed\n  return [bothVideoAudio];\n};\n\nexports.mimeTypesForPlaylist_ = mimeTypesForPlaylist_;\n/**\n * the master playlist controller controls all interactons\n * between playlists and segmentloaders. At this time this mainly\n * involves a master playlist and a series of audio playlists\n * if they are available\n *\n * @class MasterPlaylistController\n * @extends videojs.EventTarget\n */\n\nvar MasterPlaylistController = (function (_videojs$EventTarget) {\n  _inherits(MasterPlaylistController, _videojs$EventTarget);\n\n  function MasterPlaylistController(options) {\n    var _this = this;\n\n    _classCallCheck(this, MasterPlaylistController);\n\n    _get(Object.getPrototypeOf(MasterPlaylistController.prototype), 'constructor', this).call(this);\n\n    var url = options.url;\n    var handleManifestRedirects = options.handleManifestRedirects;\n    var withCredentials = options.withCredentials;\n    var mode = options.mode;\n    var tech = options.tech;\n    var bandwidth = options.bandwidth;\n    var externHls = options.externHls;\n    var useCueTags = options.useCueTags;\n    var blacklistDuration = options.blacklistDuration;\n    var enableLowInitialPlaylist = options.enableLowInitialPlaylist;\n\n    if (!url) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    Hls = externHls;\n\n    this.tech_ = tech;\n    this.hls_ = tech.hls;\n    this.mode_ = mode;\n    this.useCueTags_ = useCueTags;\n    this.blacklistDuration = blacklistDuration;\n    this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n\n    if (this.useCueTags_) {\n      this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n      this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n    }\n\n    this.requestOptions_ = {\n      withCredentials: withCredentials,\n      handleManifestRedirects: handleManifestRedirects,\n      timeout: null\n    };\n\n    this.mediaTypes_ = (0, _mediaGroups.createMediaTypes)();\n\n    this.mediaSource = new _videoJs2['default'].MediaSource({ mode: mode });\n\n    // load the media source into the player\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_.bind(this));\n\n    this.seekable_ = _videoJs2['default'].createTimeRanges();\n    this.hasPlayed_ = function () {\n      return false;\n    };\n\n    this.syncController_ = new _syncController2['default'](options);\n    this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'segment-metadata'\n    }, false).track;\n\n    this.decrypter_ = (0, _webwackify2['default'])(_decrypterWorker2['default'], resolveDecrypterWorker());\n\n    var segmentLoaderSettings = {\n      hls: this.hls_,\n      mediaSource: this.mediaSource,\n      currentTime: this.tech_.currentTime.bind(this.tech_),\n      seekable: function seekable() {\n        return _this.seekable();\n      },\n      seeking: function seeking() {\n        return _this.tech_.seeking();\n      },\n      duration: function duration() {\n        return _this.mediaSource.duration;\n      },\n      hasPlayed: function hasPlayed() {\n        return _this.hasPlayed_();\n      },\n      goalBufferLength: function goalBufferLength() {\n        return _this.goalBufferLength();\n      },\n      bandwidth: bandwidth,\n      syncController: this.syncController_,\n      decrypter: this.decrypter_\n    };\n\n    // setup playlist loaders\n    this.masterPlaylistLoader_ = new _playlistLoader2['default'](url, this.hls_, this.requestOptions_);\n    this.setupMasterPlaylistLoaderListeners_();\n\n    // setup segment loaders\n    // combined audio/video or just video when alternate audio track is selected\n    this.mainSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      segmentMetadataTrack: this.segmentMetadataTrack_,\n      loaderType: 'main'\n    }), options);\n\n    // alternate audio track\n    this.audioSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'audio'\n    }), options);\n\n    this.subtitleSegmentLoader_ = new _vttSegmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'vtt'\n    }), options);\n\n    this.setupSegmentLoaderListeners_();\n\n    // Create SegmentLoader stat-getters\n    loaderStats.forEach(function (stat) {\n      _this[stat + '_'] = sumLoaderStat.bind(_this, stat);\n    });\n\n    this.masterPlaylistLoader_.load();\n  }\n\n  /**\n   * Register event handlers on the master playlist loader. A helper\n   * function for construction time.\n   *\n   * @private\n   */\n\n  _createClass(MasterPlaylistController, [{\n    key: 'setupMasterPlaylistLoaderListeners_',\n    value: function setupMasterPlaylistLoaderListeners_() {\n      var _this2 = this;\n\n      this.masterPlaylistLoader_.on('loadedmetadata', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // if this isn't a live video and preload permits, start\n        // downloading segments\n        if (media.endList && _this2.tech_.preload() !== 'none') {\n          _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n          _this2.mainSegmentLoader_.load();\n        }\n\n        (0, _mediaGroups.setupMediaGroups)({\n          segmentLoaders: {\n            AUDIO: _this2.audioSegmentLoader_,\n            SUBTITLES: _this2.subtitleSegmentLoader_,\n            main: _this2.mainSegmentLoader_\n          },\n          tech: _this2.tech_,\n          requestOptions: _this2.requestOptions_,\n          masterPlaylistLoader: _this2.masterPlaylistLoader_,\n          mode: _this2.mode_,\n          hls: _this2.hls_,\n          master: _this2.master(),\n          mediaTypes: _this2.mediaTypes_,\n          blacklistCurrentPlaylist: _this2.blacklistCurrentPlaylist.bind(_this2)\n        });\n\n        _this2.triggerPresenceUsage_(_this2.master(), media);\n\n        try {\n          _this2.setupSourceBuffers_();\n        } catch (e) {\n          _videoJs2['default'].log.warn('Failed to create SourceBuffers', e);\n          return _this2.mediaSource.endOfStream('decode');\n        }\n        _this2.setupFirstPlay();\n\n        _this2.trigger('selectedinitialmedia');\n      });\n\n      this.masterPlaylistLoader_.on('loadedplaylist', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n\n        if (!updatedPlaylist) {\n          var selectedMedia = undefined;\n\n          if (_this2.enableLowInitialPlaylist) {\n            selectedMedia = _this2.selectInitialPlaylist();\n          }\n\n          if (!selectedMedia) {\n            selectedMedia = _this2.selectPlaylist();\n          }\n\n          _this2.initialMedia_ = selectedMedia;\n          _this2.masterPlaylistLoader_.media(_this2.initialMedia_);\n          return;\n        }\n\n        if (_this2.useCueTags_) {\n          _this2.updateAdCues_(updatedPlaylist);\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `mediachange`\n        _this2.mainSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\n        _this2.updateDuration();\n\n        // If the player isn't paused, ensure that the segment loader is running,\n        // as it is possible that it was temporarily stopped while waiting for\n        // a playlist (e.g., in case the playlist errored and we re-requested it).\n        if (!_this2.tech_.paused()) {\n          _this2.mainSegmentLoader_.load();\n        }\n\n        if (!updatedPlaylist.endList) {\n          (function () {\n            var addSeekableRange = function addSeekableRange() {\n              var seekable = _this2.seekable();\n\n              if (seekable.length !== 0) {\n                _this2.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));\n              }\n            };\n\n            if (_this2.duration() !== Infinity) {\n              (function () {\n                var onDurationchange = function onDurationchange() {\n                  if (_this2.duration() === Infinity) {\n                    addSeekableRange();\n                  } else {\n                    _this2.tech_.one('durationchange', onDurationchange);\n                  }\n                };\n\n                _this2.tech_.one('durationchange', onDurationchange);\n              })();\n            } else {\n              addSeekableRange();\n            }\n          })();\n        }\n      });\n\n      this.masterPlaylistLoader_.on('error', function () {\n        _this2.blacklistCurrentPlaylist(_this2.masterPlaylistLoader_.error);\n      });\n\n      this.masterPlaylistLoader_.on('mediachanging', function () {\n        _this2.mainSegmentLoader_.abort();\n        _this2.mainSegmentLoader_.pause();\n      });\n\n      this.masterPlaylistLoader_.on('mediachange', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `loadedplaylist`\n        _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n        _this2.mainSegmentLoader_.load();\n\n        _this2.tech_.trigger({\n          type: 'mediachange',\n          bubbles: true\n        });\n      });\n\n      this.masterPlaylistLoader_.on('playlistunchanged', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n        var playlistOutdated = _this2.stuckAtPlaylistEnd_(updatedPlaylist);\n\n        if (playlistOutdated) {\n          // Playlist has stopped updating and we're stuck at its end. Try to\n          // blacklist it and switch to another playlist in the hope that that\n          // one is updating (and give the player a chance to re-adjust to the\n          // safe live point).\n          _this2.blacklistCurrentPlaylist({\n            message: 'Playlist no longer updating.'\n          });\n          // useful for monitoring QoS\n          _this2.tech_.trigger('playliststuck');\n        }\n      });\n\n      this.masterPlaylistLoader_.on('renditiondisabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-disabled' });\n      });\n      this.masterPlaylistLoader_.on('renditionenabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-enabled' });\n      });\n    }\n\n    /**\n     * A helper function for triggerring presence usage events once per source\n     *\n     * @private\n     */\n  }, {\n    key: 'triggerPresenceUsage_',\n    value: function triggerPresenceUsage_(master, media) {\n      var mediaGroups = master.mediaGroups || {};\n      var defaultDemuxed = true;\n      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n\n      for (var mediaGroup in mediaGroups.AUDIO) {\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\n\n          if (!properties.uri) {\n            defaultDemuxed = false;\n          }\n        }\n      }\n\n      if (defaultDemuxed) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-demuxed' });\n      }\n\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-webvtt' });\n      }\n\n      if (Hls.Playlist.isAes(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-aes' });\n      }\n\n      if (Hls.Playlist.isFmp4(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-fmp4' });\n      }\n\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-alternate-audio' });\n      }\n\n      if (this.useCueTags_) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-playlist-cue-tags' });\n      }\n    }\n\n    /**\n     * Register event handlers on the segment loaders. A helper function\n     * for construction time.\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSegmentLoaderListeners_',\n    value: function setupSegmentLoaderListeners_() {\n      var _this3 = this;\n\n      this.mainSegmentLoader_.on('bandwidthupdate', function () {\n        var nextPlaylist = _this3.selectPlaylist();\n        var currentPlaylist = _this3.masterPlaylistLoader_.media();\n        var buffered = _this3.tech_.buffered();\n        var forwardBuffer = buffered.length ? buffered.end(buffered.length - 1) - _this3.tech_.currentTime() : 0;\n\n        var bufferLowWaterLine = _this3.bufferLowWaterLine();\n\n        // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n        if (!currentPlaylist.endList ||\n        // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n        _this3.duration() < _config2['default'].MAX_BUFFER_LOW_WATER_LINE ||\n        // we want to switch down to lower resolutions quickly to continue playback, but\n        nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH ||\n        // ensure we have some buffer before we switch up to prevent us running out of\n        // buffer while loading a higher rendition.\n        forwardBuffer >= bufferLowWaterLine) {\n          _this3.masterPlaylistLoader_.media(nextPlaylist);\n        }\n\n        _this3.tech_.trigger('bandwidthupdate');\n      });\n      this.mainSegmentLoader_.on('progress', function () {\n        _this3.trigger('progress');\n      });\n\n      this.mainSegmentLoader_.on('error', function () {\n        _this3.blacklistCurrentPlaylist(_this3.mainSegmentLoader_.error());\n      });\n\n      this.mainSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('timestampoffset', function () {\n        _this3.tech_.trigger({ type: 'usage', name: 'hls-timestamp-offset' });\n      });\n      this.audioSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n\n      this.mainSegmentLoader_.on('earlyabort', function () {\n        _this3.blacklistCurrentPlaylist({\n          message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\n        }, ABORT_EARLY_BLACKLIST_SECONDS);\n      });\n\n      this.mainSegmentLoader_.on('reseteverything', function () {\n        // If playing an MTS stream, a videojs.MediaSource is listening for\n        // hls-reset to reset caption parsing state in the transmuxer\n        _this3.tech_.trigger('hls-reset');\n      });\n\n      this.mainSegmentLoader_.on('segmenttimemapping', function (event) {\n        // If playing an MTS stream in html, a videojs.MediaSource is listening for\n        // hls-segment-time-mapping update its internal mapping of stream to display time\n        _this3.tech_.trigger({\n          type: 'hls-segment-time-mapping',\n          mapping: event.mapping\n        });\n      });\n\n      this.audioSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n    }\n  }, {\n    key: 'mediaSecondsLoaded_',\n    value: function mediaSecondsLoaded_() {\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n    }\n\n    /**\n     * Call load on our SegmentLoaders\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      this.mainSegmentLoader_.load();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.load();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.load();\n      }\n    }\n\n    /**\n     * Re-tune playback quality level for the current player\n     * conditions. This method may perform destructive actions, like\n     * removing already buffered content, to readjust the currently\n     * active playlist quickly.\n     *\n     * @private\n     */\n  }, {\n    key: 'fastQualityChange_',\n    value: function fastQualityChange_() {\n      var media = this.selectPlaylist();\n\n      if (media !== this.masterPlaylistLoader_.media()) {\n        this.masterPlaylistLoader_.media(media);\n\n        this.mainSegmentLoader_.resetLoader();\n        // don't need to reset audio as it is reset when media changes\n      }\n    }\n\n    /**\n     * Begin playback.\n     */\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.setupFirstPlay()) {\n        return;\n      }\n\n      if (this.tech_.ended()) {\n        this.tech_.setCurrentTime(0);\n      }\n\n      if (this.hasPlayed_()) {\n        this.load();\n      }\n\n      var seekable = this.tech_.seekable();\n\n      // if the viewer has paused and we fell out of the live window,\n      // seek forward to the live point\n      if (this.tech_.duration() === Infinity) {\n        if (this.tech_.currentTime() < seekable.start(0)) {\n          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n        }\n      }\n    }\n\n    /**\n     * Seek to the latest media position if this is a live video and the\n     * player and video are loaded and initialized.\n     */\n  }, {\n    key: 'setupFirstPlay',\n    value: function setupFirstPlay() {\n      var _this4 = this;\n\n      var media = this.masterPlaylistLoader_.media();\n\n      // Check that everything is ready to begin buffering for the first call to play\n      //  If 1) there is no active media\n      //     2) the player is paused\n      //     3) the first play has already been setup\n      // then exit early\n      if (!media || this.tech_.paused() || this.hasPlayed_()) {\n        return false;\n      }\n\n      // when the video is a live stream\n      if (!media.endList) {\n        var _ret3 = (function () {\n          var seekable = _this4.seekable();\n\n          if (!seekable.length) {\n            // without a seekable range, the player cannot seek to begin buffering at the live\n            // point\n            return {\n              v: false\n            };\n          }\n\n          if (_videoJs2['default'].browser.IE_VERSION && _this4.mode_ === 'html5' && _this4.tech_.readyState() === 0) {\n            // IE11 throws an InvalidStateError if you try to set currentTime while the\n            // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n            _this4.tech_.one('loadedmetadata', function () {\n              _this4.trigger('firstplay');\n              _this4.tech_.setCurrentTime(seekable.end(0));\n              _this4.hasPlayed_ = function () {\n                return true;\n              };\n            });\n\n            return {\n              v: false\n            };\n          }\n\n          // trigger firstplay to inform the source handler to ignore the next seek event\n          _this4.trigger('firstplay');\n          // seek to the live point\n          _this4.tech_.setCurrentTime(seekable.end(0));\n        })();\n\n        if (typeof _ret3 === 'object') return _ret3.v;\n      }\n\n      this.hasPlayed_ = function () {\n        return true;\n      };\n      // we can begin loading now that everything is ready\n      this.load();\n      return true;\n    }\n\n    /**\n     * handle the sourceopen event on the MediaSource\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSourceOpen_',\n    value: function handleSourceOpen_() {\n      // Only attempt to create the source buffer if none already exist.\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n      // after `endOfStream` has been called (in response to a seek for instance)\n      try {\n        this.setupSourceBuffers_();\n      } catch (e) {\n        _videoJs2['default'].log.warn('Failed to create Source Buffers', e);\n        return this.mediaSource.endOfStream('decode');\n      }\n\n      // if autoplay is enabled, begin playback. This is duplicative of\n      // code in video.js but is required because play() must be invoked\n      // *after* the media source has opened.\n      if (this.tech_.autoplay()) {\n        var playPromise = this.tech_.play();\n\n        // Catch/silence error when a pause interrupts a play request\n        // on browsers which return a promise\n        if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n          playPromise.then(null, function (e) {});\n        }\n      }\n\n      this.trigger('sourceopen');\n    }\n\n    /**\n     * Calls endOfStream on the media source when all active stream types have called\n     * endOfStream\n     *\n     * @param {string} streamType\n     *        Stream type of the segment loader that called endOfStream\n     * @private\n     */\n  }, {\n    key: 'onEndOfStream',\n    value: function onEndOfStream() {\n      var isEndOfStream = this.mainSegmentLoader_.ended_;\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        // if the audio playlist loader exists, then alternate audio is active, so we need\n        // to wait for both the main and audio segment loaders to call endOfStream\n        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n      }\n\n      if (isEndOfStream) {\n        this.mediaSource.endOfStream();\n      }\n    }\n\n    /**\n     * Check if a playlist has stopped being updated\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist has stopped being updated or not\n     */\n  }, {\n    key: 'stuckAtPlaylistEnd_',\n    value: function stuckAtPlaylistEnd_(playlist) {\n      var seekable = this.seekable();\n\n      if (!seekable.length) {\n        // playlist doesn't have enough information to determine whether we are stuck\n        return false;\n      }\n\n      var expired = this.syncController_.getExpiredTime(playlist, this.mediaSource.duration);\n\n      if (expired === null) {\n        return false;\n      }\n\n      // does not use the safe live end to calculate playlist end, since we\n      // don't want to say we are stuck while there is still content\n      var absolutePlaylistEnd = Hls.Playlist.playlistEnd(playlist, expired);\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n\n      if (!buffered.length) {\n        // return true if the playhead reached the absolute end of the playlist\n        return absolutePlaylistEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA;\n      }\n      var bufferedEnd = buffered.end(buffered.length - 1);\n\n      // return true if there is too little buffer left and buffer has reached absolute\n      // end of playlist\n      return bufferedEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= _ranges2['default'].SAFE_TIME_DELTA;\n    }\n\n    /**\n     * Blacklists a playlist when an error occurs for a set amount of time\n     * making it unavailable for selection by the rendition selection algorithm\n     * and then forces a new playlist (rendition) selection.\n     *\n     * @param {Object=} error an optional error that may include the playlist\n     * to blacklist\n     * @param {Number=} blacklistDuration an optional number of seconds to blacklist the\n     * playlist\n     */\n  }, {\n    key: 'blacklistCurrentPlaylist',\n    value: function blacklistCurrentPlaylist(error, blacklistDuration) {\n      if (error === undefined) error = {};\n\n      var currentPlaylist = undefined;\n      var nextPlaylist = undefined;\n\n      // If the `error` was generated by the playlist loader, it will contain\n      // the playlist we were trying to load (but failed) and that should be\n      // blacklisted instead of the currently selected playlist which is likely\n      // out-of-date in this scenario\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n\n      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;\n\n      // If there is no current playlist, then an error occurred while we were\n      // trying to load the master OR while we were disposing of the tech\n      if (!currentPlaylist) {\n        this.error = error;\n\n        try {\n          return this.mediaSource.endOfStream('network');\n        } catch (e) {\n          return this.trigger('error');\n        }\n      }\n\n      var isFinalRendition = this.masterPlaylistLoader_.master.playlists.filter(_playlistJs.isEnabled).length === 1;\n\n      if (isFinalRendition) {\n        // Never blacklisting this playlist because it's final rendition\n        _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. Trying again since it is the final playlist.');\n\n        this.tech_.trigger('retryplaylist');\n        return this.masterPlaylistLoader_.load(isFinalRendition);\n      }\n      // Blacklist this playlist\n      currentPlaylist.excludeUntil = Date.now() + blacklistDuration * 1000;\n      this.tech_.trigger('blacklistplaylist');\n      this.tech_.trigger({ type: 'usage', name: 'hls-rendition-blacklisted' });\n\n      // Select a new playlist\n      nextPlaylist = this.selectPlaylist();\n      _videoJs2['default'].log.warn('Problem encountered with the current HLS playlist.' + (error.message ? ' ' + error.message : '') + ' Switching to another playlist.');\n\n      return this.masterPlaylistLoader_.media(nextPlaylist);\n    }\n\n    /**\n     * Pause all segment loaders\n     */\n  }, {\n    key: 'pauseLoading',\n    value: function pauseLoading() {\n      this.mainSegmentLoader_.pause();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.pause();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.pause();\n      }\n    }\n\n    /**\n     * set the current time on all segment loaders\n     *\n     * @param {TimeRange} currentTime the current time to set\n     * @return {TimeRange} the current time\n     */\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      var buffered = _ranges2['default'].findRange(this.tech_.buffered(), currentTime);\n\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\n        // return immediately if the metadata is not ready yet\n        return 0;\n      }\n\n      // it's clearly an edge-case but don't thrown an error if asked to\n      // seek within an empty playlist\n      if (!this.masterPlaylistLoader_.media().segments) {\n        return 0;\n      }\n\n      // In flash playback, the segment loaders should be reset on every seek, even\n      // in buffer seeks. If the seek location is already buffered, continue buffering as\n      // usual\n      if (buffered && buffered.length && this.mode_ !== 'flash') {\n        return currentTime;\n      }\n\n      // cancel outstanding requests so we begin buffering at the new\n      // location\n      this.mainSegmentLoader_.resetEverything();\n      this.mainSegmentLoader_.abort();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.resetEverything();\n        this.audioSegmentLoader_.abort();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.resetEverything();\n        this.subtitleSegmentLoader_.abort();\n      }\n\n      // start segment loader loading in case they are paused\n      this.load();\n    }\n\n    /**\n     * get the current duration\n     *\n     * @return {TimeRange} the duration\n     */\n  }, {\n    key: 'duration',\n    value: function duration() {\n      if (!this.masterPlaylistLoader_) {\n        return 0;\n      }\n\n      if (this.mediaSource) {\n        return this.mediaSource.duration;\n      }\n\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n    }\n\n    /**\n     * check the seekable range\n     *\n     * @return {TimeRange} the seekable range\n     */\n  }, {\n    key: 'seekable',\n    value: function seekable() {\n      return this.seekable_;\n    }\n  }, {\n    key: 'onSyncInfoUpdate_',\n    value: function onSyncInfoUpdate_() {\n      var mainSeekable = undefined;\n      var audioSeekable = undefined;\n\n      if (!this.masterPlaylistLoader_) {\n        return;\n      }\n\n      var media = this.masterPlaylistLoader_.media();\n\n      if (!media) {\n        return;\n      }\n\n      var expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n      if (expired === null) {\n        // not enough information to update seekable\n        return;\n      }\n\n      mainSeekable = Hls.Playlist.seekable(media, expired);\n\n      if (mainSeekable.length === 0) {\n        return;\n      }\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n        expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n        if (expired === null) {\n          return;\n        }\n\n        audioSeekable = Hls.Playlist.seekable(media, expired);\n\n        if (audioSeekable.length === 0) {\n          return;\n        }\n      }\n\n      if (!audioSeekable) {\n        // seekable has been calculated based on buffering video data so it\n        // can be returned directly\n        this.seekable_ = mainSeekable;\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n        // seekables are pretty far off, rely on main\n        this.seekable_ = mainSeekable;\n      } else {\n        this.seekable_ = _videoJs2['default'].createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n      }\n\n      this.tech_.trigger('seekablechanged');\n    }\n\n    /**\n     * Update the player duration\n     */\n  }, {\n    key: 'updateDuration',\n    value: function updateDuration() {\n      var _this5 = this;\n\n      var oldDuration = this.mediaSource.duration;\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n      var buffered = this.tech_.buffered();\n      var setDuration = function setDuration() {\n        _this5.mediaSource.duration = newDuration;\n        _this5.tech_.trigger('durationchange');\n\n        _this5.mediaSource.removeEventListener('sourceopen', setDuration);\n      };\n\n      if (buffered.length > 0) {\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\n      }\n\n      // if the duration has changed, invalidate the cached value\n      if (oldDuration !== newDuration) {\n        // update the duration\n        if (this.mediaSource.readyState !== 'open') {\n          this.mediaSource.addEventListener('sourceopen', setDuration);\n        } else {\n          setDuration();\n        }\n      }\n    }\n\n    /**\n     * dispose of the MasterPlaylistController and everything\n     * that it controls\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      var _this6 = this;\n\n      this.decrypter_.terminate();\n      this.masterPlaylistLoader_.dispose();\n      this.mainSegmentLoader_.dispose();\n\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n        var groups = _this6.mediaTypes_[type].groups;\n\n        for (var id in groups) {\n          groups[id].forEach(function (group) {\n            if (group.playlistLoader) {\n              group.playlistLoader.dispose();\n            }\n          });\n        }\n      });\n\n      this.audioSegmentLoader_.dispose();\n      this.subtitleSegmentLoader_.dispose();\n    }\n\n    /**\n     * return the master playlist object if we have one\n     *\n     * @return {Object} the master playlist object that we parsed\n     */\n  }, {\n    key: 'master',\n    value: function master() {\n      return this.masterPlaylistLoader_.master;\n    }\n\n    /**\n     * return the currently selected playlist\n     *\n     * @return {Object} the currently selected playlist object that we parsed\n     */\n  }, {\n    key: 'media',\n    value: function media() {\n      // playlist loader will not return media if it has not been fully loaded\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\n    }\n\n    /**\n     * setup our internal source buffers on our segment Loaders\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSourceBuffers_',\n    value: function setupSourceBuffers_() {\n      var media = this.masterPlaylistLoader_.media();\n      var mimeTypes = undefined;\n\n      // wait until a media playlist is available and the Media Source is\n      // attached\n      if (!media || this.mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      mimeTypes = mimeTypesForPlaylist_(this.masterPlaylistLoader_.master, media);\n      if (mimeTypes.length < 1) {\n        this.error = 'No compatible SourceBuffer configuration for the variant stream:' + media.resolvedUri;\n        return this.mediaSource.endOfStream('decode');\n      }\n      this.mainSegmentLoader_.mimeType(mimeTypes[0]);\n      if (mimeTypes[1]) {\n        this.audioSegmentLoader_.mimeType(mimeTypes[1]);\n      }\n\n      // exclude any incompatible variant streams from future playlist\n      // selection\n      this.excludeIncompatibleVariants_(media);\n    }\n\n    /**\n     * Blacklist playlists that are known to be codec or\n     * stream-incompatible with the SourceBuffer configuration. For\n     * instance, Media Source Extensions would cause the video element to\n     * stall waiting for video data if you switched from a variant with\n     * video and audio to an audio-only one.\n     *\n     * @param {Object} media a media playlist compatible with the current\n     * set of SourceBuffers. Variants in the current master playlist that\n     * do not appear to have compatible codec or stream configurations\n     * will be excluded from the default playlist selection algorithm\n     * indefinitely.\n     * @private\n     */\n  }, {\n    key: 'excludeIncompatibleVariants_',\n    value: function excludeIncompatibleVariants_(media) {\n      var master = this.masterPlaylistLoader_.master;\n      var codecCount = 2;\n      var videoCodec = null;\n      var codecs = undefined;\n\n      if (media.attributes.CODECS) {\n        codecs = (0, _utilCodecsJs.parseCodecs)(media.attributes.CODECS);\n        videoCodec = codecs.videoCodec;\n        codecCount = codecs.codecCount;\n      }\n      master.playlists.forEach(function (variant) {\n        var variantCodecs = {\n          codecCount: 2,\n          videoCodec: null\n        };\n\n        if (variant.attributes.CODECS) {\n          var codecString = variant.attributes.CODECS;\n\n          variantCodecs = (0, _utilCodecsJs.parseCodecs)(codecString);\n\n          if (window.MediaSource && window.MediaSource.isTypeSupported && !window.MediaSource.isTypeSupported('video/mp4; codecs=\"' + mapLegacyAvcCodecs_(codecString) + '\"')) {\n            variant.excludeUntil = Infinity;\n          }\n        }\n\n        // if the streams differ in the presence or absence of audio or\n        // video, they are incompatible\n        if (variantCodecs.codecCount !== codecCount) {\n          variant.excludeUntil = Infinity;\n        }\n\n        // if h.264 is specified on the current playlist, some flavor of\n        // it must be specified on all compatible variants\n        if (variantCodecs.videoCodec !== videoCodec) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n    }\n  }, {\n    key: 'updateAdCues_',\n    value: function updateAdCues_(media) {\n      var offset = 0;\n      var seekable = this.seekable();\n\n      if (seekable.length) {\n        offset = seekable.start(0);\n      }\n\n      _adCueTags2['default'].updateAdCues(media, this.cueTagsTrack_, offset);\n    }\n\n    /**\n     * Calculates the desired forward buffer length based on current time\n     *\n     * @return {Number} Desired forward buffer length in seconds\n     */\n  }, {\n    key: 'goalBufferLength',\n    value: function goalBufferLength() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].GOAL_BUFFER_LENGTH;\n      var rate = _config2['default'].GOAL_BUFFER_LENGTH_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_GOAL_BUFFER_LENGTH);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n\n    /**\n     * Calculates the desired buffer low water line based on current time\n     *\n     * @return {Number} Desired buffer low water line in seconds\n     */\n  }, {\n    key: 'bufferLowWaterLine',\n    value: function bufferLowWaterLine() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].BUFFER_LOW_WATER_LINE;\n      var rate = _config2['default'].BUFFER_LOW_WATER_LINE_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_BUFFER_LOW_WATER_LINE);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n  }]);\n\n  return MasterPlaylistController;\n})(_videoJs2['default'].EventTarget);\n\nexports.MasterPlaylistController = MasterPlaylistController;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}