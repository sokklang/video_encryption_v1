{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function () {\n  var i;\n  types = {\n    avc1: [],\n    // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [],\n    // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n    }\n  }\n  MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n  AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x00,\n  // pre_defined\n  0x76, 0x69, 0x64, 0x65,\n  // handler_type: 'vide'\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x00,\n  // pre_defined\n  0x73, 0x6f, 0x75, 0x6e,\n  // handler_type: 'soun'\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x01,\n  // entry_count\n  0x00, 0x00, 0x00, 0x0c,\n  // entry_size\n  0x75, 0x72, 0x6c, 0x20,\n  // 'url' type\n  0x00,\n  // version 0\n  0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([0x00,\n  // version\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00,\n  // balance, 0 means centered\n  0x00, 0x00 // reserved\n  ]);\n  STCO = new Uint8Array([0x00,\n  // version\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([0x00,\n  // version\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x00,\n  // sample_size\n  0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([0x00,\n  // version\n  0x00, 0x00, 0x01,\n  // flags\n  0x00, 0x00,\n  // graphicsmode\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n  ]);\n})();\nbox = function (type) {\n  var payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\ndinf = function () {\n  return box(types.dinf, box(types.dref, DREF));\n};\nesds = function (track) {\n  return box(types.esds, new Uint8Array([0x00,\n  // version\n  0x00, 0x00, 0x00,\n  // flags\n\n  // ES_Descriptor\n  0x03,\n  // tag, ES_DescrTag\n  0x19,\n  // length\n  0x00, 0x00,\n  // ES_ID\n  0x00,\n  // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n  // DecoderConfigDescriptor\n  0x04,\n  // tag, DecoderConfigDescrTag\n  0x11,\n  // length\n  0x40,\n  // object type\n  0x15,\n  // streamType\n  0x00, 0x06, 0x00,\n  // bufferSizeDB\n  0x00, 0x00, 0xda, 0xc0,\n  // maxBitrate\n  0x00, 0x00, 0xda, 0xc0,\n  // avgBitrate\n\n  // DecoderSpecificInfo\n  0x05,\n  // tag, DecoderSpecificInfoTag\n  0x02,\n  // length\n  // ISO/IEC 14496-3, AudioSpecificConfig\n  // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n  track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\nftyp = function () {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\nhdlr = function (type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function (data) {\n  return box(types.mdat, data);\n};\nmdhd = function (track) {\n  var result = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x02,\n  // creation_time\n  0x00, 0x00, 0x00, 0x03,\n  // modification_time\n  0x00, 0x01, 0x5f, 0x90,\n  // timescale, 90,000 \"ticks\" per second\n\n  track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF,\n  // duration\n  0x55, 0xc4,\n  // 'und' language (undetermined)\n  0x00, 0x00]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = track.samplerate >>> 24 & 0xFF;\n    result[13] = track.samplerate >>> 16 & 0xFF;\n    result[14] = track.samplerate >>> 8 & 0xFF;\n    result[15] = track.samplerate & 0xFF;\n  }\n  return box(types.mdhd, result);\n};\nmdia = function (track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function (sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n  // flags\n  (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function (track) {\n  return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n};\nmoof = function (sequenceNumber, tracks) {\n  var trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function (tracks) {\n  var i = tracks.length,\n    boxes = [];\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function (tracks) {\n  var i = tracks.length,\n    boxes = [];\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function (duration) {\n  var bytes = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  0x00, 0x00, 0x00, 0x01,\n  // creation_time\n  0x00, 0x00, 0x00, 0x02,\n  // modification_time\n  0x00, 0x01, 0x5f, 0x90,\n  // timescale, 90,000 \"ticks\" per second\n  (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF,\n  // duration\n  0x00, 0x01, 0x00, 0x00,\n  // 1.0 rate\n  0x01, 0x00,\n  // 1.0 volume\n  0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n  // transformation: unity matrix\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  // pre_defined\n  0xff, 0xff, 0xff, 0xff // next_track_ID\n  ]);\n  return box(types.mvhd, bytes);\n};\nsdtp = function (track) {\n  var samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n  }\n  return box(types.sdtp, bytes);\n};\nstbl = function (track) {\n  return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n};\n(function () {\n  var videoSample, audioSample;\n  stsd = function (track) {\n    return box(types.stsd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n  videoSample = function (track) {\n    var sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push(pps[i].byteLength & 0xFF);\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n    return box(types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    (track.width & 0xff00) >> 8, track.width & 0xff,\n    // width\n    (track.height & 0xff00) >> 8, track.height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([0x01,\n    // configurationVersion\n    track.profileIdc,\n    // AVCProfileIndication\n    track.profileCompatibility,\n    // profile_compatibility\n    track.levelIdc,\n    // AVCLevelIndication\n    0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))),\n    // \"PPS\"\n    box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate\n    );\n  };\n  audioSample = function (track) {\n    return box(types.mp4a, new Uint8Array([\n    // SampleEntry, ISO/IEC 14496-12\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n\n    // AudioSampleEntry, ISO/IEC 14496-12\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff,\n    // channelcount\n\n    (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff,\n    // samplesize\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n\n    (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n\n    // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n})();\ntkhd = function (track) {\n  var result = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x07,\n  // flags\n  0x00, 0x00, 0x00, 0x00,\n  // creation_time\n  0x00, 0x00, 0x00, 0x00,\n  // modification_time\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n  // track_ID\n  0x00, 0x00, 0x00, 0x00,\n  // reserved\n  (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF,\n  // duration\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  // reserved\n  0x00, 0x00,\n  // layer\n  0x00, 0x00,\n  // alternate_group\n  0x01, 0x00,\n  // non-audio track volume\n  0x00, 0x00,\n  // reserved\n  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n  // transformation: unity matrix\n  (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00,\n  // width\n  (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n  ]);\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function (track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x3a,\n  // flags\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n  // track_ID\n  0x00, 0x00, 0x00, 0x01,\n  // sample_description_index\n  0x00, 0x00, 0x00, 0x00,\n  // default_sample_duration\n  0x00, 0x00, 0x00, 0x00,\n  // default_sample_size\n  0x00, 0x00, 0x00, 0x00 // default_sample_flags\n  ]));\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01,\n  // version 1\n  0x00, 0x00, 0x00,\n  // flags\n  // baseMediaDecodeTime\n  upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = 32 +\n  // tfhd\n  20 +\n  // tfdt\n  8 +\n  // traf header\n  16 +\n  // mfhd\n  8 +\n  // moof header\n  8; // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track, sampleDependencyTable.length + dataOffset);\n  return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function (track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak, tkhd(track), mdia(track));\n};\ntrex = function (track) {\n  var result = new Uint8Array([0x00,\n  // version 0\n  0x00, 0x00, 0x00,\n  // flags\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n  // track_ID\n  0x00, 0x00, 0x00, 0x01,\n  // default_sample_description_index\n  0x00, 0x00, 0x00, 0x00,\n  // default_sample_duration\n  0x00, 0x00, 0x00, 0x00,\n  // default_sample_size\n  0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n  return box(types.trex, result);\n};\n(function () {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function (samples, offset) {\n    var durationPresent = 0,\n      sizePresent = 0,\n      flagsPresent = 0,\n      compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n    return [0x00,\n    // version 0\n    0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01,\n    // flags\n    (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF,\n    // sample_count\n    (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n    ];\n  };\n  videoTrun = function (track, offset) {\n    var bytes, samples, sample, i;\n    samples = track.samples || [];\n    offset += 8 + 12 + 16 * samples.length;\n    bytes = trunHeader(samples, offset);\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([(sample.duration & 0xFF000000) >>> 24, (sample.duration & 0xFF0000) >>> 16, (sample.duration & 0xFF00) >>> 8, sample.duration & 0xFF,\n      // sample_duration\n      (sample.size & 0xFF000000) >>> 24, (sample.size & 0xFF0000) >>> 16, (sample.size & 0xFF00) >>> 8, sample.size & 0xFF,\n      // sample_size\n      sample.flags.isLeading << 2 | sample.flags.dependsOn, sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample, sample.flags.degradationPriority & 0xF0 << 8, sample.flags.degradationPriority & 0x0F,\n      // sample_flags\n      (sample.compositionTimeOffset & 0xFF000000) >>> 24, (sample.compositionTimeOffset & 0xFF0000) >>> 16, (sample.compositionTimeOffset & 0xFF00) >>> 8, sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n  audioTrun = function (track, offset) {\n    var bytes, samples, sample, i;\n    samples = track.samples || [];\n    offset += 8 + 12 + 8 * samples.length;\n    bytes = trunHeader(samples, offset);\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([(sample.duration & 0xFF000000) >>> 24, (sample.duration & 0xFF0000) >>> 16, (sample.duration & 0xFF00) >>> 8, sample.duration & 0xFF,\n      // sample_duration\n      (sample.size & 0xFF000000) >>> 24, (sample.size & 0xFF0000) >>> 16, (sample.size & 0xFF00) >>> 8, sample.size & 0xFF]); // sample_size\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n  trun = function (track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n    return videoTrun(track, offset);\n  };\n})();\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function (tracks) {\n    var fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};","map":{"version":3,"names":["UINT32_MAX","Math","pow","box","dinf","esds","ftyp","mdat","mfhd","minf","moof","moov","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun","types","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","i","avc1","avcC","btrt","dref","mp4a","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","vmhd","Uint8Array","hasOwnProperty","charCodeAt","video","audio","type","payload","size","result","view","arguments","length","push","byteLength","DataView","buffer","byteOffset","setUint32","set","track","audioobjecttype","samplingfrequencyindex","channelcount","data","duration","samplerate","sequenceNumber","tracks","trackFragments","apply","concat","boxes","bytes","samples","flags","dependsOn","isDependedOn","hasRedundancy","videoSample","audioSample","sps","pps","sequenceParameterSets","pictureParameterSets","Array","prototype","slice","call","width","height","profileIdc","profileCompatibility","levelIdc","samplesize","id","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","dataOffset","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","floor","baseMediaDecodeTime","audioTrun","videoTrun","trunHeader","offset","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","undefined","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","module","exports","initSegment","fileType","movie"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}