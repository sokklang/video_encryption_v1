{"ast":null,"code":"/**\n * @file virtual-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x, _x2, _x3) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x,\n      property = _x2,\n      receiver = _x3;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x = parent;\n        _x2 = property;\n        _x3 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\nvar _addTextTrackData = require('./add-text-track-data');\nvar _webwackify = require('webwackify');\nvar _webwackify2 = _interopRequireDefault(_webwackify);\nvar _transmuxerWorker = require('./transmuxer-worker');\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\nvar _codecUtils = require('./codec-utils');\nvar resolveTransmuxWorker = function resolveTransmuxWorker() {\n  var result = undefined;\n  try {\n    result = require.resolve('./transmuxer-worker');\n  } catch (e) {\n    // no result\n  }\n  return result;\n};\n\n// We create a wrapper around the SourceBuffer so that we can manage the\n// state of the `updating` property manually. We have to do this because\n// Firefox changes `updating` to false long before triggering `updateend`\n// events and that was causing strange problems in videojs-contrib-hls\nvar makeWrappedSourceBuffer = function makeWrappedSourceBuffer(mediaSource, mimeType) {\n  var sourceBuffer = mediaSource.addSourceBuffer(mimeType);\n  var wrapper = Object.create(null);\n  wrapper.updating = false;\n  wrapper.realBuffer_ = sourceBuffer;\n  var _loop = function (key) {\n    if (typeof sourceBuffer[key] === 'function') {\n      wrapper[key] = function () {\n        return sourceBuffer[key].apply(sourceBuffer, arguments);\n      };\n    } else if (typeof wrapper[key] === 'undefined') {\n      Object.defineProperty(wrapper, key, {\n        get: function get() {\n          return sourceBuffer[key];\n        },\n        set: function set(v) {\n          return sourceBuffer[key] = v;\n        }\n      });\n    }\n  };\n  for (var key in sourceBuffer) {\n    _loop(key);\n  }\n  return wrapper;\n};\n\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Player} player\n *        The player instance\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, player, mapping) {\n  if (!player || !buffer.length) {\n    return [];\n  }\n\n  // pts value for current time + 3 seconds to give a bit more wiggle room\n  var currentTimePts = Math.ceil((player.currentTime() - mapping + 3) * 90000);\n  var i = undefined;\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n  return buffer.slice(i);\n};\nexports.gopsSafeToAlignWith = gopsSafeToAlignWith;\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n  var start = gops[0].pts;\n  var i = 0;\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n  return buffer.slice(0, i).concat(gops);\n};\nexports.updateGopBuffer = updateGopBuffer;\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * 90000);\n  var endPts = Math.ceil((end - mapping) * 90000);\n  var updatedBuffer = buffer.slice();\n  var i = buffer.length;\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n  var j = i + 1;\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  }\n\n  // clamp remove range start to 0 index\n  j = Math.max(j, 0);\n  updatedBuffer.splice(j, i - j + 1);\n  return updatedBuffer;\n};\nexports.removeGopBuffer = removeGopBuffer;\n/**\n * VirtualSourceBuffers exist so that we can transmux non native formats\n * into a native format, but keep the same api as a native source buffer.\n * It creates a transmuxer, that works in its own thread (a web worker) and\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\n * then send all of that data to the naive sourcebuffer so that it is\n * indestinguishable from a natively supported format.\n *\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\n * @param {Array} codecs array of codecs that we will be dealing with\n * @class VirtualSourceBuffer\n * @extends video.js.EventTarget\n */\n\nvar VirtualSourceBuffer = function (_videojs$EventTarget) {\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\n  function VirtualSourceBuffer(mediaSource, codecs) {\n    var _this = this;\n    _classCallCheck(this, VirtualSourceBuffer);\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\n    this.timestampOffset_ = 0;\n    this.pendingBuffers_ = [];\n    this.bufferUpdating_ = false;\n    this.mediaSource_ = mediaSource;\n    this.codecs_ = codecs;\n    this.audioCodec_ = null;\n    this.videoCodec_ = null;\n    this.audioDisabled_ = false;\n    this.appendAudioInitSegment_ = true;\n    this.gopBuffer_ = [];\n    this.timeMapping_ = 0;\n    this.safeAppend_ = _videoJs2['default'].browser.IE_VERSION >= 11;\n    var options = {\n      remux: false,\n      alignGopsAtEnd: this.safeAppend_\n    };\n    this.codecs_.forEach(function (codec) {\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\n        _this.audioCodec_ = codec;\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\n        _this.videoCodec_ = codec;\n      }\n    });\n\n    // append muxed segments to their respective native buffers as\n    // soon as they are available\n    this.transmuxer_ = (0, _webwackify2['default'])(_transmuxerWorker2['default'], resolveTransmuxWorker());\n    this.transmuxer_.postMessage({\n      action: 'init',\n      options: options\n    });\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        return _this.data_(event);\n      }\n      if (event.data.action === 'done') {\n        return _this.done_(event);\n      }\n      if (event.data.action === 'gopInfo') {\n        return _this.appendGopInfo_(event);\n      }\n    };\n\n    // this timestampOffset is a property with the side-effect of resetting\n    // baseMediaDecodeTime in the transmuxer on the setter\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          this.appendAudioInitSegment_ = true;\n\n          // reset gop buffer on timestampoffset as this signals a change in timeline\n          this.gopBuffer_.length = 0;\n          this.timeMapping_ = 0;\n\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\n          // the desired timestampOffset for the next segment\n          this.transmuxer_.postMessage({\n            action: 'setTimestampOffset',\n            timestampOffset: val\n          });\n        }\n      }\n    });\n\n    // setting the append window affects both source buffers\n    Object.defineProperty(this, 'appendWindowStart', {\n      get: function get() {\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\n      },\n      set: function set(start) {\n        if (this.videoBuffer_) {\n          this.videoBuffer_.appendWindowStart = start;\n        }\n        if (this.audioBuffer_) {\n          this.audioBuffer_.appendWindowStart = start;\n        }\n      }\n    });\n\n    // this buffer is \"updating\" if either of its native buffers are\n    Object.defineProperty(this, 'updating', {\n      get: function get() {\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\n      }\n    });\n\n    // the buffered property is the intersection of the buffered\n    // ranges of the native source buffers\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        var start = null;\n        var end = null;\n        var arity = 0;\n        var extents = [];\n        var ranges = [];\n\n        // neither buffer has been created yet\n        if (!this.videoBuffer_ && !this.audioBuffer_) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // only one buffer is configured\n        if (!this.videoBuffer_) {\n          return this.audioBuffer_.buffered;\n        }\n        if (!this.audioBuffer_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are configured\n        if (this.audioDisabled_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are empty\n        if (this.videoBuffer_.buffered.length === 0 && this.audioBuffer_.buffered.length === 0) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // Handle the case where we have both buffers and create an\n        // intersection of the two\n        var videoBuffered = this.videoBuffer_.buffered;\n        var audioBuffered = this.audioBuffer_.buffered;\n        var count = videoBuffered.length;\n\n        // A) Gather up all start and end times\n        while (count--) {\n          extents.push({\n            time: videoBuffered.start(count),\n            type: 'start'\n          });\n          extents.push({\n            time: videoBuffered.end(count),\n            type: 'end'\n          });\n        }\n        count = audioBuffered.length;\n        while (count--) {\n          extents.push({\n            time: audioBuffered.start(count),\n            type: 'start'\n          });\n          extents.push({\n            time: audioBuffered.end(count),\n            type: 'end'\n          });\n        }\n        // B) Sort them by time\n        extents.sort(function (a, b) {\n          return a.time - b.time;\n        });\n\n        // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n        for (count = 0; count < extents.length; count++) {\n          if (extents[count].type === 'start') {\n            arity++;\n\n            // D) If arity is ever incremented to 2 we are entering an\n            //    overlapping range\n            if (arity === 2) {\n              start = extents[count].time;\n            }\n          } else if (extents[count].type === 'end') {\n            arity--;\n\n            // E) If arity is ever decremented to 1 we leaving an\n            //    overlapping range\n            if (arity === 1) {\n              end = extents[count].time;\n            }\n          }\n\n          // F) Record overlapping ranges\n          if (start !== null && end !== null) {\n            ranges.push([start, end]);\n            start = null;\n            end = null;\n          }\n        }\n        return _videoJs2['default'].createTimeRanges(ranges);\n      }\n    });\n  }\n\n  /**\n   * When we get a data event from the transmuxer\n   * we call this function and handle the data that\n   * was sent to us\n   *\n   * @private\n   * @param {Event} event the data event from the transmuxer\n   */\n\n  _createClass(VirtualSourceBuffer, [{\n    key: 'data_',\n    value: function data_(event) {\n      var segment = event.data.segment;\n\n      // Cast ArrayBuffer to TypedArray\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\n      segment.initSegment = new Uint8Array(segment.initSegment.data, segment.initSegment.byteOffset, segment.initSegment.byteLength);\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n\n      // Add the segments to the pendingBuffers array\n      this.pendingBuffers_.push(segment);\n      return;\n    }\n\n    /**\n     * When we get a done event from the transmuxer\n     * we call this function and we process all\n     * of the pending data that we have been saving in the\n     * data_ function\n     *\n     * @private\n     * @param {Event} event the done event from the transmuxer\n     */\n  }, {\n    key: 'done_',\n    value: function done_(event) {\n      // Don't process and append data if the mediaSource is closed\n      if (this.mediaSource_.readyState === 'closed') {\n        this.pendingBuffers_.length = 0;\n        return;\n      }\n\n      // All buffers should have been flushed from the muxer\n      // start processing anything we have received\n      this.processPendingSegments_();\n      return;\n    }\n\n    /**\n     * Create our internal native audio/video source buffers and add\n     * event handlers to them with the following conditions:\n     * 1. they do not already exist on the mediaSource\n     * 2. this VSB has a codec for them\n     *\n     * @private\n     */\n  }, {\n    key: 'createRealSourceBuffers_',\n    value: function createRealSourceBuffers_() {\n      var _this2 = this;\n      var types = ['audio', 'video'];\n      types.forEach(function (type) {\n        // Don't create a SourceBuffer of this type if we don't have a\n        // codec for it\n        if (!_this2[type + 'Codec_']) {\n          return;\n        }\n\n        // Do nothing if a SourceBuffer of this type already exists\n        if (_this2[type + 'Buffer_']) {\n          return;\n        }\n        var buffer = null;\n\n        // If the mediasource already has a SourceBuffer for the codec\n        // use that\n        if (_this2.mediaSource_[type + 'Buffer_']) {\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\n          // In multiple audio track cases, the audio source buffer is disabled\n          // on the main VirtualSourceBuffer by the HTMLMediaSource much earlier\n          // than createRealSourceBuffers_ is called to create the second\n          // VirtualSourceBuffer because that happens as a side-effect of\n          // videojs-contrib-hls starting the audioSegmentLoader. As a result,\n          // the audioBuffer is essentially \"ownerless\" and no one will toggle\n          // the `updating` state back to false once the `updateend` event is received\n          //\n          // Setting `updating` to false manually will work around this\n          // situation and allow work to continue\n          buffer.updating = false;\n        } else {\n          var codecProperty = type + 'Codec_';\n          var mimeType = type + '/mp4;codecs=\"' + _this2[codecProperty] + '\"';\n          buffer = makeWrappedSourceBuffer(_this2.mediaSource_.nativeMediaSource_, mimeType);\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\n        }\n        _this2[type + 'Buffer_'] = buffer;\n\n        // Wire up the events to the SourceBuffer\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\n          buffer.addEventListener(event, function () {\n            // if audio is disabled\n            if (type === 'audio' && _this2.audioDisabled_) {\n              return;\n            }\n            if (event === 'updateend') {\n              _this2[type + 'Buffer_'].updating = false;\n            }\n            var shouldTrigger = types.every(function (t) {\n              // skip checking audio's updating status if audio\n              // is not enabled\n              if (t === 'audio' && _this2.audioDisabled_) {\n                return true;\n              }\n              // if the other type if updating we don't trigger\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\n                return false;\n              }\n              return true;\n            });\n            if (shouldTrigger) {\n              return _this2.trigger(event);\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Emulate the native mediasource function, but our function will\n     * send all of the proposed segments to the transmuxer so that we\n     * can transmux them before we append them to our internal\n     * native source buffers in the correct format.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n     * @param {Uint8Array} segment the segment to append to the buffer\n     */\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(segment) {\n      // Start the internal \"updating\" state\n      this.bufferUpdating_ = true;\n      if (this.audioBuffer_ && this.audioBuffer_.buffered.length) {\n        var audioBuffered = this.audioBuffer_.buffered;\n        this.transmuxer_.postMessage({\n          action: 'setAudioAppendStart',\n          appendStart: audioBuffered.end(audioBuffered.length - 1)\n        });\n      }\n      if (this.videoBuffer_) {\n        this.transmuxer_.postMessage({\n          action: 'alignGopsWith',\n          gopsToAlignWith: gopsSafeToAlignWith(this.gopBuffer_, this.mediaSource_.player_, this.timeMapping_)\n        });\n      }\n      this.transmuxer_.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: segment.buffer,\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset: segment.byteOffset,\n        byteLength: segment.byteLength\n      }, [segment.buffer]);\n      this.transmuxer_.postMessage({\n        action: 'flush'\n      });\n    }\n\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Event} event\n     *        The gopInfo event from the transmuxer\n     * @param {Array} event.data.gopInfo\n     *        List of gop info to append\n     */\n  }, {\n    key: 'appendGopInfo_',\n    value: function appendGopInfo_(event) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, event.data.gopInfo, this.safeAppend_);\n    }\n\n    /**\n     * Emulate the native mediasource function and remove parts\n     * of the buffer from any of our internal buffers that exist\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start position to start the remove at\n     * @param {Double} end position to end the remove at\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.updating = true;\n        this.videoBuffer_.remove(start, end);\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.updating = true;\n        this.audioBuffer_.remove(start, end);\n      }\n\n      // Remove Metadata Cues (id3)\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n\n      // Remove Any Captions\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n    }\n\n    /**\n     * Process any segments that the muxer has output\n     * Concatenate segments together based on type and append them into\n     * their respective sourceBuffers\n     *\n     * @private\n     */\n  }, {\n    key: 'processPendingSegments_',\n    value: function processPendingSegments_() {\n      var sortedSegments = {\n        video: {\n          segments: [],\n          bytes: 0\n        },\n        audio: {\n          segments: [],\n          bytes: 0\n        },\n        captions: [],\n        metadata: []\n      };\n\n      // Sort segments into separate video/audio arrays and\n      // keep track of their total byte lengths\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\n        var type = segment.type;\n        var data = segment.data;\n        var initSegment = segment.initSegment;\n        segmentObj[type].segments.push(data);\n        segmentObj[type].bytes += data.byteLength;\n        segmentObj[type].initSegment = initSegment;\n\n        // Gather any captions into a single array\n        if (segment.captions) {\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\n        }\n        if (segment.info) {\n          segmentObj[type].info = segment.info;\n        }\n\n        // Gather any metadata into a single array\n        if (segment.metadata) {\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\n        }\n        return segmentObj;\n      }, sortedSegments);\n\n      // Create the real source buffers if they don't exist by now since we\n      // finally are sure what tracks are contained in the source\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\n        // Remove any codecs that may have been specified by default but\n        // are no longer applicable now\n        if (sortedSegments.video.bytes === 0) {\n          this.videoCodec_ = null;\n        }\n        if (sortedSegments.audio.bytes === 0) {\n          this.audioCodec_ = null;\n        }\n        this.createRealSourceBuffers_();\n      }\n      if (sortedSegments.audio.info) {\n        this.mediaSource_.trigger({\n          type: 'audioinfo',\n          info: sortedSegments.audio.info\n        });\n      }\n      if (sortedSegments.video.info) {\n        this.mediaSource_.trigger({\n          type: 'videoinfo',\n          info: sortedSegments.video.info\n        });\n      }\n      if (this.appendAudioInitSegment_) {\n        if (!this.audioDisabled_ && this.audioBuffer_) {\n          sortedSegments.audio.segments.unshift(sortedSegments.audio.initSegment);\n          sortedSegments.audio.bytes += sortedSegments.audio.initSegment.byteLength;\n        }\n        this.appendAudioInitSegment_ = false;\n      }\n      var triggerUpdateend = false;\n\n      // Merge multiple video and audio segments into one and append\n      if (this.videoBuffer_ && sortedSegments.video.bytes) {\n        sortedSegments.video.segments.unshift(sortedSegments.video.initSegment);\n        sortedSegments.video.bytes += sortedSegments.video.initSegment.byteLength;\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\n        // TODO: are video tracks the only ones with text tracks?\n        (0, _addTextTrackData.addTextTrackData)(this, sortedSegments.captions, sortedSegments.metadata);\n      } else if (this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\n        // The transmuxer did not return any bytes of video, meaning it was all trimmed\n        // for gop alignment. Since we have a video buffer and audio is disabled, updateend\n        // will never be triggered by this source buffer, which will cause contrib-hls\n        // to be stuck forever waiting for updateend. If audio is not disabled, updateend\n        // will be triggered by the audio buffer, which will be sent upwards since the video\n        // buffer will not be in an updating state.\n        triggerUpdateend = true;\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\n      }\n      this.pendingBuffers_.length = 0;\n      if (triggerUpdateend) {\n        this.trigger('updateend');\n      }\n\n      // We are no longer in the internal \"updating\" state\n      this.bufferUpdating_ = false;\n    }\n\n    /**\n     * Combine all segments into a single Uint8Array and then append them\n     * to the destination buffer\n     *\n     * @param {Object} segmentObj\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\n     * @private\n     */\n  }, {\n    key: 'concatAndAppendSegments_',\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\n      var offset = 0;\n      var tempBuffer = undefined;\n      if (segmentObj.bytes) {\n        tempBuffer = new Uint8Array(segmentObj.bytes);\n\n        // Combine the individual segments into one large typed-array\n        segmentObj.segments.forEach(function (segment) {\n          tempBuffer.set(segment, offset);\n          offset += segment.byteLength;\n        });\n        try {\n          destinationBuffer.updating = true;\n          destinationBuffer.appendBuffer(tempBuffer);\n        } catch (error) {\n          if (this.mediaSource_.player_) {\n            this.mediaSource_.player_.error({\n              code: -3,\n              type: 'APPEND_BUFFER_ERR',\n              message: error.message,\n              originalError: error\n            });\n          }\n        }\n      }\n    }\n\n    /**\n     * Emulate the native mediasource function. abort any soureBuffer\n     * actions and throw out any un-appended data.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.abort();\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.abort();\n      }\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({\n          action: 'reset'\n        });\n      }\n      this.pendingBuffers_.length = 0;\n      this.bufferUpdating_ = false;\n    }\n  }]);\n  return VirtualSourceBuffer;\n}(_videoJs2['default'].EventTarget);\nexports['default'] = VirtualSourceBuffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x","_x2","_x3","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_videoJs","require","_videoJs2","_createTextTracksIfNecessary","_createTextTracksIfNecessary2","_removeCuesFromTrack","_removeCuesFromTrack2","_addTextTrackData","_webwackify","_webwackify2","_transmuxerWorker","_transmuxerWorker2","_codecUtils","resolveTransmuxWorker","result","resolve","e","makeWrappedSourceBuffer","mediaSource","mimeType","sourceBuffer","addSourceBuffer","wrapper","updating","realBuffer_","_loop","apply","arguments","set","v","gopsSafeToAlignWith","buffer","player","mapping","currentTimePts","Math","ceil","currentTime","pts","slice","updateGopBuffer","gops","replace","start","concat","removeGopBuffer","end","startPts","endPts","updatedBuffer","j","max","splice","VirtualSourceBuffer","_videojs$EventTarget","codecs","_this","EventTarget","timestampOffset_","pendingBuffers_","bufferUpdating_","mediaSource_","codecs_","audioCodec_","videoCodec_","audioDisabled_","appendAudioInitSegment_","gopBuffer_","timeMapping_","safeAppend_","browser","IE_VERSION","options","remux","alignGopsAtEnd","forEach","codec","isAudioCodec","isVideoCodec","transmuxer_","postMessage","action","onmessage","event","data","data_","done_","appendGopInfo_","val","timestampOffset","videoBuffer_","audioBuffer_","appendWindowStart","arity","extents","ranges","createTimeRange","buffered","videoBuffered","audioBuffered","count","push","time","type","sort","a","b","createTimeRanges","segment","Uint8Array","byteOffset","byteLength","initSegment","readyState","processPendingSegments_","createRealSourceBuffers_","_this2","types","codecProperty","nativeMediaSource_","addEventListener","shouldTrigger","every","t","trigger","appendBuffer","appendStart","gopsToAlignWith","player_","gopInfo","remove","metadataTrack_","inbandTextTracks_","track","sortedSegments","video","segments","bytes","audio","captions","metadata","reduce","segmentObj","info","unshift","triggerUpdateend","concatAndAppendSegments_","addTextTrackData","destinationBuffer","offset","tempBuffer","error","code","message","originalError","abort"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/es5/virtual-source-buffer.js"],"sourcesContent":["/**\n * @file virtual-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _addTextTrackData = require('./add-text-track-data');\n\nvar _webwackify = require('webwackify');\n\nvar _webwackify2 = _interopRequireDefault(_webwackify);\n\nvar _transmuxerWorker = require('./transmuxer-worker');\n\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\n\nvar _codecUtils = require('./codec-utils');\n\nvar resolveTransmuxWorker = function resolveTransmuxWorker() {\n  var result = undefined;\n\n  try {\n    result = require.resolve('./transmuxer-worker');\n  } catch (e) {\n    // no result\n  }\n\n  return result;\n};\n\n// We create a wrapper around the SourceBuffer so that we can manage the\n// state of the `updating` property manually. We have to do this because\n// Firefox changes `updating` to false long before triggering `updateend`\n// events and that was causing strange problems in videojs-contrib-hls\nvar makeWrappedSourceBuffer = function makeWrappedSourceBuffer(mediaSource, mimeType) {\n  var sourceBuffer = mediaSource.addSourceBuffer(mimeType);\n  var wrapper = Object.create(null);\n\n  wrapper.updating = false;\n  wrapper.realBuffer_ = sourceBuffer;\n\n  var _loop = function (key) {\n    if (typeof sourceBuffer[key] === 'function') {\n      wrapper[key] = function () {\n        return sourceBuffer[key].apply(sourceBuffer, arguments);\n      };\n    } else if (typeof wrapper[key] === 'undefined') {\n      Object.defineProperty(wrapper, key, {\n        get: function get() {\n          return sourceBuffer[key];\n        },\n        set: function set(v) {\n          return sourceBuffer[key] = v;\n        }\n      });\n    }\n  };\n\n  for (var key in sourceBuffer) {\n    _loop(key);\n  }\n\n  return wrapper;\n};\n\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Player} player\n *        The player instance\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, player, mapping) {\n  if (!player || !buffer.length) {\n    return [];\n  }\n\n  // pts value for current time + 3 seconds to give a bit more wiggle room\n  var currentTimePts = Math.ceil((player.currentTime() - mapping + 3) * 90000);\n\n  var i = undefined;\n\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n\n  return buffer.slice(i);\n};\n\nexports.gopsSafeToAlignWith = gopsSafeToAlignWith;\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n\n  var start = gops[0].pts;\n\n  var i = 0;\n\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n\n  return buffer.slice(0, i).concat(gops);\n};\n\nexports.updateGopBuffer = updateGopBuffer;\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * 90000);\n  var endPts = Math.ceil((end - mapping) * 90000);\n  var updatedBuffer = buffer.slice();\n\n  var i = buffer.length;\n\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n\n  var j = i + 1;\n\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  }\n\n  // clamp remove range start to 0 index\n  j = Math.max(j, 0);\n\n  updatedBuffer.splice(j, i - j + 1);\n\n  return updatedBuffer;\n};\n\nexports.removeGopBuffer = removeGopBuffer;\n/**\n * VirtualSourceBuffers exist so that we can transmux non native formats\n * into a native format, but keep the same api as a native source buffer.\n * It creates a transmuxer, that works in its own thread (a web worker) and\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\n * then send all of that data to the naive sourcebuffer so that it is\n * indestinguishable from a natively supported format.\n *\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\n * @param {Array} codecs array of codecs that we will be dealing with\n * @class VirtualSourceBuffer\n * @extends video.js.EventTarget\n */\n\nvar VirtualSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\n\n  function VirtualSourceBuffer(mediaSource, codecs) {\n    var _this = this;\n\n    _classCallCheck(this, VirtualSourceBuffer);\n\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\n    this.timestampOffset_ = 0;\n    this.pendingBuffers_ = [];\n    this.bufferUpdating_ = false;\n\n    this.mediaSource_ = mediaSource;\n    this.codecs_ = codecs;\n    this.audioCodec_ = null;\n    this.videoCodec_ = null;\n    this.audioDisabled_ = false;\n    this.appendAudioInitSegment_ = true;\n    this.gopBuffer_ = [];\n    this.timeMapping_ = 0;\n    this.safeAppend_ = _videoJs2['default'].browser.IE_VERSION >= 11;\n\n    var options = {\n      remux: false,\n      alignGopsAtEnd: this.safeAppend_\n    };\n\n    this.codecs_.forEach(function (codec) {\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\n        _this.audioCodec_ = codec;\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\n        _this.videoCodec_ = codec;\n      }\n    });\n\n    // append muxed segments to their respective native buffers as\n    // soon as they are available\n    this.transmuxer_ = (0, _webwackify2['default'])(_transmuxerWorker2['default'], resolveTransmuxWorker());\n    this.transmuxer_.postMessage({ action: 'init', options: options });\n\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        return _this.data_(event);\n      }\n\n      if (event.data.action === 'done') {\n        return _this.done_(event);\n      }\n\n      if (event.data.action === 'gopInfo') {\n        return _this.appendGopInfo_(event);\n      }\n    };\n\n    // this timestampOffset is a property with the side-effect of resetting\n    // baseMediaDecodeTime in the transmuxer on the setter\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          this.appendAudioInitSegment_ = true;\n\n          // reset gop buffer on timestampoffset as this signals a change in timeline\n          this.gopBuffer_.length = 0;\n          this.timeMapping_ = 0;\n\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\n          // the desired timestampOffset for the next segment\n          this.transmuxer_.postMessage({\n            action: 'setTimestampOffset',\n            timestampOffset: val\n          });\n        }\n      }\n    });\n\n    // setting the append window affects both source buffers\n    Object.defineProperty(this, 'appendWindowStart', {\n      get: function get() {\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\n      },\n      set: function set(start) {\n        if (this.videoBuffer_) {\n          this.videoBuffer_.appendWindowStart = start;\n        }\n        if (this.audioBuffer_) {\n          this.audioBuffer_.appendWindowStart = start;\n        }\n      }\n    });\n\n    // this buffer is \"updating\" if either of its native buffers are\n    Object.defineProperty(this, 'updating', {\n      get: function get() {\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\n      }\n    });\n\n    // the buffered property is the intersection of the buffered\n    // ranges of the native source buffers\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        var start = null;\n        var end = null;\n        var arity = 0;\n        var extents = [];\n        var ranges = [];\n\n        // neither buffer has been created yet\n        if (!this.videoBuffer_ && !this.audioBuffer_) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // only one buffer is configured\n        if (!this.videoBuffer_) {\n          return this.audioBuffer_.buffered;\n        }\n        if (!this.audioBuffer_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are configured\n        if (this.audioDisabled_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are empty\n        if (this.videoBuffer_.buffered.length === 0 && this.audioBuffer_.buffered.length === 0) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // Handle the case where we have both buffers and create an\n        // intersection of the two\n        var videoBuffered = this.videoBuffer_.buffered;\n        var audioBuffered = this.audioBuffer_.buffered;\n        var count = videoBuffered.length;\n\n        // A) Gather up all start and end times\n        while (count--) {\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\n        }\n        count = audioBuffered.length;\n        while (count--) {\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\n        }\n        // B) Sort them by time\n        extents.sort(function (a, b) {\n          return a.time - b.time;\n        });\n\n        // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n        for (count = 0; count < extents.length; count++) {\n          if (extents[count].type === 'start') {\n            arity++;\n\n            // D) If arity is ever incremented to 2 we are entering an\n            //    overlapping range\n            if (arity === 2) {\n              start = extents[count].time;\n            }\n          } else if (extents[count].type === 'end') {\n            arity--;\n\n            // E) If arity is ever decremented to 1 we leaving an\n            //    overlapping range\n            if (arity === 1) {\n              end = extents[count].time;\n            }\n          }\n\n          // F) Record overlapping ranges\n          if (start !== null && end !== null) {\n            ranges.push([start, end]);\n            start = null;\n            end = null;\n          }\n        }\n\n        return _videoJs2['default'].createTimeRanges(ranges);\n      }\n    });\n  }\n\n  /**\n   * When we get a data event from the transmuxer\n   * we call this function and handle the data that\n   * was sent to us\n   *\n   * @private\n   * @param {Event} event the data event from the transmuxer\n   */\n\n  _createClass(VirtualSourceBuffer, [{\n    key: 'data_',\n    value: function data_(event) {\n      var segment = event.data.segment;\n\n      // Cast ArrayBuffer to TypedArray\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\n\n      segment.initSegment = new Uint8Array(segment.initSegment.data, segment.initSegment.byteOffset, segment.initSegment.byteLength);\n\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n\n      // Add the segments to the pendingBuffers array\n      this.pendingBuffers_.push(segment);\n      return;\n    }\n\n    /**\n     * When we get a done event from the transmuxer\n     * we call this function and we process all\n     * of the pending data that we have been saving in the\n     * data_ function\n     *\n     * @private\n     * @param {Event} event the done event from the transmuxer\n     */\n  }, {\n    key: 'done_',\n    value: function done_(event) {\n      // Don't process and append data if the mediaSource is closed\n      if (this.mediaSource_.readyState === 'closed') {\n        this.pendingBuffers_.length = 0;\n        return;\n      }\n\n      // All buffers should have been flushed from the muxer\n      // start processing anything we have received\n      this.processPendingSegments_();\n      return;\n    }\n\n    /**\n     * Create our internal native audio/video source buffers and add\n     * event handlers to them with the following conditions:\n     * 1. they do not already exist on the mediaSource\n     * 2. this VSB has a codec for them\n     *\n     * @private\n     */\n  }, {\n    key: 'createRealSourceBuffers_',\n    value: function createRealSourceBuffers_() {\n      var _this2 = this;\n\n      var types = ['audio', 'video'];\n\n      types.forEach(function (type) {\n        // Don't create a SourceBuffer of this type if we don't have a\n        // codec for it\n        if (!_this2[type + 'Codec_']) {\n          return;\n        }\n\n        // Do nothing if a SourceBuffer of this type already exists\n        if (_this2[type + 'Buffer_']) {\n          return;\n        }\n\n        var buffer = null;\n\n        // If the mediasource already has a SourceBuffer for the codec\n        // use that\n        if (_this2.mediaSource_[type + 'Buffer_']) {\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\n          // In multiple audio track cases, the audio source buffer is disabled\n          // on the main VirtualSourceBuffer by the HTMLMediaSource much earlier\n          // than createRealSourceBuffers_ is called to create the second\n          // VirtualSourceBuffer because that happens as a side-effect of\n          // videojs-contrib-hls starting the audioSegmentLoader. As a result,\n          // the audioBuffer is essentially \"ownerless\" and no one will toggle\n          // the `updating` state back to false once the `updateend` event is received\n          //\n          // Setting `updating` to false manually will work around this\n          // situation and allow work to continue\n          buffer.updating = false;\n        } else {\n          var codecProperty = type + 'Codec_';\n          var mimeType = type + '/mp4;codecs=\"' + _this2[codecProperty] + '\"';\n\n          buffer = makeWrappedSourceBuffer(_this2.mediaSource_.nativeMediaSource_, mimeType);\n\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\n        }\n\n        _this2[type + 'Buffer_'] = buffer;\n\n        // Wire up the events to the SourceBuffer\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\n          buffer.addEventListener(event, function () {\n            // if audio is disabled\n            if (type === 'audio' && _this2.audioDisabled_) {\n              return;\n            }\n\n            if (event === 'updateend') {\n              _this2[type + 'Buffer_'].updating = false;\n            }\n\n            var shouldTrigger = types.every(function (t) {\n              // skip checking audio's updating status if audio\n              // is not enabled\n              if (t === 'audio' && _this2.audioDisabled_) {\n                return true;\n              }\n              // if the other type if updating we don't trigger\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\n                return false;\n              }\n              return true;\n            });\n\n            if (shouldTrigger) {\n              return _this2.trigger(event);\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Emulate the native mediasource function, but our function will\n     * send all of the proposed segments to the transmuxer so that we\n     * can transmux them before we append them to our internal\n     * native source buffers in the correct format.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n     * @param {Uint8Array} segment the segment to append to the buffer\n     */\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(segment) {\n      // Start the internal \"updating\" state\n      this.bufferUpdating_ = true;\n\n      if (this.audioBuffer_ && this.audioBuffer_.buffered.length) {\n        var audioBuffered = this.audioBuffer_.buffered;\n\n        this.transmuxer_.postMessage({\n          action: 'setAudioAppendStart',\n          appendStart: audioBuffered.end(audioBuffered.length - 1)\n        });\n      }\n\n      if (this.videoBuffer_) {\n        this.transmuxer_.postMessage({\n          action: 'alignGopsWith',\n          gopsToAlignWith: gopsSafeToAlignWith(this.gopBuffer_, this.mediaSource_.player_, this.timeMapping_)\n        });\n      }\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: segment.buffer,\n\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset: segment.byteOffset,\n        byteLength: segment.byteLength\n      }, [segment.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Event} event\n     *        The gopInfo event from the transmuxer\n     * @param {Array} event.data.gopInfo\n     *        List of gop info to append\n     */\n  }, {\n    key: 'appendGopInfo_',\n    value: function appendGopInfo_(event) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, event.data.gopInfo, this.safeAppend_);\n    }\n\n    /**\n     * Emulate the native mediasource function and remove parts\n     * of the buffer from any of our internal buffers that exist\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start position to start the remove at\n     * @param {Double} end position to end the remove at\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.updating = true;\n        this.videoBuffer_.remove(start, end);\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.updating = true;\n        this.audioBuffer_.remove(start, end);\n      }\n\n      // Remove Metadata Cues (id3)\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n\n      // Remove Any Captions\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n    }\n\n    /**\n     * Process any segments that the muxer has output\n     * Concatenate segments together based on type and append them into\n     * their respective sourceBuffers\n     *\n     * @private\n     */\n  }, {\n    key: 'processPendingSegments_',\n    value: function processPendingSegments_() {\n      var sortedSegments = {\n        video: {\n          segments: [],\n          bytes: 0\n        },\n        audio: {\n          segments: [],\n          bytes: 0\n        },\n        captions: [],\n        metadata: []\n      };\n\n      // Sort segments into separate video/audio arrays and\n      // keep track of their total byte lengths\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\n        var type = segment.type;\n        var data = segment.data;\n        var initSegment = segment.initSegment;\n\n        segmentObj[type].segments.push(data);\n        segmentObj[type].bytes += data.byteLength;\n\n        segmentObj[type].initSegment = initSegment;\n\n        // Gather any captions into a single array\n        if (segment.captions) {\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\n        }\n\n        if (segment.info) {\n          segmentObj[type].info = segment.info;\n        }\n\n        // Gather any metadata into a single array\n        if (segment.metadata) {\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\n        }\n\n        return segmentObj;\n      }, sortedSegments);\n\n      // Create the real source buffers if they don't exist by now since we\n      // finally are sure what tracks are contained in the source\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\n        // Remove any codecs that may have been specified by default but\n        // are no longer applicable now\n        if (sortedSegments.video.bytes === 0) {\n          this.videoCodec_ = null;\n        }\n        if (sortedSegments.audio.bytes === 0) {\n          this.audioCodec_ = null;\n        }\n\n        this.createRealSourceBuffers_();\n      }\n\n      if (sortedSegments.audio.info) {\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\n      }\n      if (sortedSegments.video.info) {\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\n      }\n\n      if (this.appendAudioInitSegment_) {\n        if (!this.audioDisabled_ && this.audioBuffer_) {\n          sortedSegments.audio.segments.unshift(sortedSegments.audio.initSegment);\n          sortedSegments.audio.bytes += sortedSegments.audio.initSegment.byteLength;\n        }\n        this.appendAudioInitSegment_ = false;\n      }\n\n      var triggerUpdateend = false;\n\n      // Merge multiple video and audio segments into one and append\n      if (this.videoBuffer_ && sortedSegments.video.bytes) {\n        sortedSegments.video.segments.unshift(sortedSegments.video.initSegment);\n        sortedSegments.video.bytes += sortedSegments.video.initSegment.byteLength;\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\n        // TODO: are video tracks the only ones with text tracks?\n        (0, _addTextTrackData.addTextTrackData)(this, sortedSegments.captions, sortedSegments.metadata);\n      } else if (this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\n        // The transmuxer did not return any bytes of video, meaning it was all trimmed\n        // for gop alignment. Since we have a video buffer and audio is disabled, updateend\n        // will never be triggered by this source buffer, which will cause contrib-hls\n        // to be stuck forever waiting for updateend. If audio is not disabled, updateend\n        // will be triggered by the audio buffer, which will be sent upwards since the video\n        // buffer will not be in an updating state.\n        triggerUpdateend = true;\n      }\n\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\n      }\n\n      this.pendingBuffers_.length = 0;\n\n      if (triggerUpdateend) {\n        this.trigger('updateend');\n      }\n\n      // We are no longer in the internal \"updating\" state\n      this.bufferUpdating_ = false;\n    }\n\n    /**\n     * Combine all segments into a single Uint8Array and then append them\n     * to the destination buffer\n     *\n     * @param {Object} segmentObj\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\n     * @private\n     */\n  }, {\n    key: 'concatAndAppendSegments_',\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\n      var offset = 0;\n      var tempBuffer = undefined;\n\n      if (segmentObj.bytes) {\n        tempBuffer = new Uint8Array(segmentObj.bytes);\n\n        // Combine the individual segments into one large typed-array\n        segmentObj.segments.forEach(function (segment) {\n          tempBuffer.set(segment, offset);\n          offset += segment.byteLength;\n        });\n\n        try {\n          destinationBuffer.updating = true;\n          destinationBuffer.appendBuffer(tempBuffer);\n        } catch (error) {\n          if (this.mediaSource_.player_) {\n            this.mediaSource_.player_.error({\n              code: -3,\n              type: 'APPEND_BUFFER_ERR',\n              message: error.message,\n              originalError: error\n            });\n          }\n        }\n      }\n    }\n\n    /**\n     * Emulate the native mediasource function. abort any soureBuffer\n     * actions and throw out any un-appended data.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.abort();\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.abort();\n      }\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({ action: 'reset' });\n      }\n      this.pendingBuffers_.length = 0;\n      this.bufferUpdating_ = false;\n    }\n  }]);\n\n  return VirtualSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = VirtualSourceBuffer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}