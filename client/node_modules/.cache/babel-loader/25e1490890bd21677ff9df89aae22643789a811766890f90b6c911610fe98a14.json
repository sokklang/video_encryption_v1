{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _config = require('./config');\nvar _config2 = _interopRequireDefault(_config);\nvar _playlist = require('./playlist');\nvar _playlist2 = _interopRequireDefault(_playlist);\nvar _utilCodecsJs = require('./util/codecs.js');\n\n// Utilities\n\n/**\n * Returns the CSS value for the specified property on an element\n * using `getComputedStyle`. Firefox has a long-standing issue where\n * getComputedStyle() may return null when running in an iframe with\n * `display: none`.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n * @param {HTMLElement} el the htmlelement to work on\n * @param {string} the proprety to get the style for\n */\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\n  var result = undefined;\n  if (!el) {\n    return '';\n  }\n  result = window.getComputedStyle(el);\n  if (!result) {\n    return '';\n  }\n  return result[property];\n};\n\n/**\n * Resuable stable sort function\n *\n * @param {Playlists} array\n * @param {Function} sortFn Different comparators\n * @function stableSort\n */\nvar stableSort = function stableSort(array, sortFn) {\n  var newArray = array.slice();\n  array.sort(function (left, right) {\n    var cmp = sortFn(left, right);\n    if (cmp === 0) {\n      return newArray.indexOf(left) - newArray.indexOf(right);\n    }\n    return cmp;\n  });\n};\n\n/**\n * A comparator function to sort two playlist object by bandwidth.\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the bandwidth attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the bandwidth of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\n  var leftBandwidth = undefined;\n  var rightBandwidth = undefined;\n  if (left.attributes.BANDWIDTH) {\n    leftBandwidth = left.attributes.BANDWIDTH;\n  }\n  leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n  if (right.attributes.BANDWIDTH) {\n    rightBandwidth = right.attributes.BANDWIDTH;\n  }\n  rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n  return leftBandwidth - rightBandwidth;\n};\nexports.comparePlaylistBandwidth = comparePlaylistBandwidth;\n/**\n * A comparator function to sort two playlist object by resolution (width).\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the resolution.width attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the resolution.width of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistResolution = function comparePlaylistResolution(left, right) {\n  var leftWidth = undefined;\n  var rightWidth = undefined;\n  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n    leftWidth = left.attributes.RESOLUTION.width;\n  }\n  leftWidth = leftWidth || window.Number.MAX_VALUE;\n  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n    rightWidth = right.attributes.RESOLUTION.width;\n  }\n  rightWidth = rightWidth || window.Number.MAX_VALUE;\n\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n  // have the same media dimensions/ resolution\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n  }\n  return leftWidth - rightWidth;\n};\nexports.comparePlaylistResolution = comparePlaylistResolution;\n/**\n * Chooses the appropriate media playlist based on bandwidth and player size\n *\n * @param {Object} master\n *        Object representation of the master manifest\n * @param {Number} playerBandwidth\n *        Current calculated bandwidth of the player\n * @param {Number} playerWidth\n *        Current width of the player element\n * @param {Number} playerHeight\n *        Current height of the player element\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight) {\n  // convert the playlists to an intermediary representation to make comparisons easier\n  var sortedPlaylistReps = master.playlists.map(function (playlist) {\n    var width = undefined;\n    var height = undefined;\n    var bandwidth = undefined;\n    width = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n    height = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n    bandwidth = playlist.attributes.BANDWIDTH;\n    bandwidth = bandwidth || window.Number.MAX_VALUE;\n    return {\n      bandwidth: bandwidth,\n      width: width,\n      height: height,\n      playlist: playlist\n    };\n  });\n  stableSort(sortedPlaylistReps, function (left, right) {\n    return left.bandwidth - right.bandwidth;\n  });\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return !_playlist2['default'].isIncompatible(rep.playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return _playlist2['default'].isEnabled(rep.playlist);\n  });\n  if (!enabledPlaylistReps.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n      return !_playlist2['default'].isDisabled(rep.playlist);\n    });\n  }\n\n  // filter out any variant that has greater effective bitrate\n  // than the current estimated bandwidth\n  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\n    return rep.bandwidth * _config2['default'].BANDWIDTH_VARIANCE < playerBandwidth;\n  });\n  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];\n\n  // get all of the renditions with the same (highest) bandwidth\n  // and then taking the very first element\n  var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  // filter out playlists without resolution information\n  var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.width && rep.height;\n  });\n\n  // sort variants by resolution\n  stableSort(haveResolution, function (left, right) {\n    return left.width - right.width;\n  });\n\n  // if we have the exact resolution as the player use it\n  var resolutionBestRepList = haveResolution.filter(function (rep) {\n    return rep.width === playerWidth && rep.height === playerHeight;\n  });\n  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];\n  // ensure that we pick the highest bandwidth variant that have exact resolution\n  var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n  var resolutionPlusOneList = undefined;\n  var resolutionPlusOneSmallest = undefined;\n  var resolutionPlusOneRep = undefined;\n\n  // find the smallest variant that is larger than the player\n  // if there is no match of exact resolution\n  if (!resolutionBestRep) {\n    resolutionPlusOneList = haveResolution.filter(function (rep) {\n      return rep.width > playerWidth || rep.height > playerHeight;\n    });\n\n    // find all the variants have the same smallest resolution\n    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\n      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\n    });\n\n    // ensure that we also pick the highest bandwidth variant that\n    // is just-larger-than the video player\n    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n    })[0];\n  }\n\n  // fallback chain of variants\n  var chosenRep = resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n  return chosenRep ? chosenRep.playlist : null;\n};\nexports.simpleSelector = simpleSelector;\n// Playlist Selectors\n\n/**\n * Chooses the appropriate media playlist based on the most recent\n * bandwidth estimate and the player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar lastBandwidthSelector = function lastBandwidthSelector() {\n  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n};\nexports.lastBandwidthSelector = lastBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on an\n * exponential-weighted moving average of the bandwidth after\n * filtering for player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @param {Number} decay - a number between 0 and 1. Higher values of\n * this parameter will cause previous bandwidth estimates to lose\n * significance more quickly.\n * @return {Function} a function which can be invoked to create a new\n * playlist selector function.\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n */\nvar movingAverageBandwidthSelector = function movingAverageBandwidthSelector(decay) {\n  var average = -1;\n  if (decay < 0 || decay > 1) {\n    throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n  }\n  return function () {\n    if (average < 0) {\n      average = this.systemBandwidth;\n    }\n    average = decay * this.systemBandwidth + (1 - decay) * average;\n    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n  };\n};\nexports.movingAverageBandwidthSelector = movingAverageBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on the potential to rebuffer\n *\n * @param {Object} settings\n *        Object of information required to use this selector\n * @param {Object} settings.master\n *        Object representation of the master manifest\n * @param {Number} settings.currentTime\n *        The current time of the player\n * @param {Number} settings.bandwidth\n *        Current measured bandwidth\n * @param {Number} settings.duration\n *        Duration of the media\n * @param {Number} settings.segmentDuration\n *        Segment duration to be used in round trip time calculations\n * @param {Number} settings.timeUntilRebuffer\n *        Time left in seconds until the player has to rebuffer\n * @param {Number} settings.currentTimeline\n *        The current timeline segments are being loaded from\n * @param {SyncController} settings.syncController\n *        SyncController for determining if we have a sync point for a given playlist\n * @return {Object|null}\n *         {Object} return.playlist\n *         The highest bandwidth playlist with the least amount of rebuffering\n *         {Number} return.rebufferingImpact\n *         The amount of time in seconds switching to this playlist will rebuffer. A\n *         negative value means that switching will cause zero rebuffering.\n */\nvar minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\n  var master = settings.master;\n  var currentTime = settings.currentTime;\n  var bandwidth = settings.bandwidth;\n  var duration = settings.duration;\n  var segmentDuration = settings.segmentDuration;\n  var timeUntilRebuffer = settings.timeUntilRebuffer;\n  var currentTimeline = settings.currentTimeline;\n  var syncController = settings.syncController;\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  var compatiblePlaylists = master.playlists.filter(function (playlist) {\n    return !_playlist2['default'].isIncompatible(playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylists = compatiblePlaylists.filter(_playlist2['default'].isEnabled);\n  if (!enabledPlaylists.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\n      return !_playlist2['default'].isDisabled(playlist);\n    });\n  }\n  var bandwidthPlaylists = enabledPlaylists.filter(_playlist2['default'].hasAttribute.bind(null, 'BANDWIDTH'));\n  var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\n    var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);\n    // If there is no sync point for this playlist, switching to it will require a\n    // sync request first. This will double the request time\n    var numRequests = syncPoint ? 1 : 2;\n    var requestTimeEstimate = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n    return {\n      playlist: playlist,\n      rebufferingImpact: rebufferingImpact\n    };\n  });\n  var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\n    return estimate.rebufferingImpact <= 0;\n  });\n\n  // Sort by bandwidth DESC\n  stableSort(noRebufferingPlaylists, function (a, b) {\n    return comparePlaylistBandwidth(b.playlist, a.playlist);\n  });\n  if (noRebufferingPlaylists.length) {\n    return noRebufferingPlaylists[0];\n  }\n  stableSort(rebufferingEstimates, function (a, b) {\n    return a.rebufferingImpact - b.rebufferingImpact;\n  });\n  return rebufferingEstimates[0] || null;\n};\nexports.minRebufferMaxBandwidthSelector = minRebufferMaxBandwidthSelector;\n/**\n * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n * one with video.  If no renditions with video exist, return the lowest audio rendition.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Object|null}\n *         {Object} return.playlist\n *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n *         exists pick the lowest audio rendition.\n */\nvar lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations or playback errors\n  var playlists = this.playlists.master.playlists.filter(_playlist2['default'].isEnabled);\n\n  // Sort ascending by bitrate\n  stableSort(playlists, function (a, b) {\n    return comparePlaylistBandwidth(a, b);\n  });\n\n  // Parse and assume that playlists with no video codec have no video\n  // (this is not necessarily true, although it is generally true).\n  //\n  // If an entire manifest has no valid videos everything will get filtered\n  // out.\n  var playlistsWithVideo = playlists.filter(function (playlist) {\n    return (0, _utilCodecsJs.parseCodecs)(playlist.attributes.CODECS).videoCodec;\n  });\n  return playlistsWithVideo[0] || null;\n};\nexports.lowestBitrateCompatibleVariantSelector = lowestBitrateCompatibleVariantSelector;","map":{"version":3,"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_config","require","_config2","_playlist","_playlist2","_utilCodecsJs","safeGetComputedStyle","el","property","result","undefined","window","getComputedStyle","stableSort","array","sortFn","newArray","slice","sort","left","right","cmp","indexOf","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","attributes","BANDWIDTH","Number","MAX_VALUE","comparePlaylistResolution","leftWidth","rightWidth","RESOLUTION","width","simpleSelector","master","playerBandwidth","playerWidth","playerHeight","sortedPlaylistReps","playlists","map","playlist","height","bandwidth","filter","rep","isIncompatible","enabledPlaylistReps","isEnabled","length","isDisabled","bandwidthPlaylistReps","BANDWIDTH_VARIANCE","highestRemainingBandwidthRep","bandwidthBestRep","haveResolution","resolutionBestRepList","resolutionBestRep","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","chosenRep","lastBandwidthSelector","systemBandwidth","parseInt","tech_","movingAverageBandwidthSelector","decay","average","Error","minRebufferMaxBandwidthSelector","settings","currentTime","duration","segmentDuration","timeUntilRebuffer","currentTimeline","syncController","compatiblePlaylists","enabledPlaylists","bandwidthPlaylists","hasAttribute","bind","rebufferingEstimates","syncPoint","getSyncPoint","numRequests","requestTimeEstimate","estimateSegmentRequestTime","rebufferingImpact","noRebufferingPlaylists","estimate","a","b","lowestBitrateCompatibleVariantSelector","playlistsWithVideo","parseCodecs","CODECS","videoCodec"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/playlist-selectors.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _playlist = require('./playlist');\n\nvar _playlist2 = _interopRequireDefault(_playlist);\n\nvar _utilCodecsJs = require('./util/codecs.js');\n\n// Utilities\n\n/**\n * Returns the CSS value for the specified property on an element\n * using `getComputedStyle`. Firefox has a long-standing issue where\n * getComputedStyle() may return null when running in an iframe with\n * `display: none`.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n * @param {HTMLElement} el the htmlelement to work on\n * @param {string} the proprety to get the style for\n */\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\n  var result = undefined;\n\n  if (!el) {\n    return '';\n  }\n\n  result = window.getComputedStyle(el);\n  if (!result) {\n    return '';\n  }\n\n  return result[property];\n};\n\n/**\n * Resuable stable sort function\n *\n * @param {Playlists} array\n * @param {Function} sortFn Different comparators\n * @function stableSort\n */\nvar stableSort = function stableSort(array, sortFn) {\n  var newArray = array.slice();\n\n  array.sort(function (left, right) {\n    var cmp = sortFn(left, right);\n\n    if (cmp === 0) {\n      return newArray.indexOf(left) - newArray.indexOf(right);\n    }\n    return cmp;\n  });\n};\n\n/**\n * A comparator function to sort two playlist object by bandwidth.\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the bandwidth attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the bandwidth of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\n  var leftBandwidth = undefined;\n  var rightBandwidth = undefined;\n\n  if (left.attributes.BANDWIDTH) {\n    leftBandwidth = left.attributes.BANDWIDTH;\n  }\n  leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n  if (right.attributes.BANDWIDTH) {\n    rightBandwidth = right.attributes.BANDWIDTH;\n  }\n  rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n\n  return leftBandwidth - rightBandwidth;\n};\n\nexports.comparePlaylistBandwidth = comparePlaylistBandwidth;\n/**\n * A comparator function to sort two playlist object by resolution (width).\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the resolution.width attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the resolution.width of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistResolution = function comparePlaylistResolution(left, right) {\n  var leftWidth = undefined;\n  var rightWidth = undefined;\n\n  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n    leftWidth = left.attributes.RESOLUTION.width;\n  }\n\n  leftWidth = leftWidth || window.Number.MAX_VALUE;\n\n  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n    rightWidth = right.attributes.RESOLUTION.width;\n  }\n\n  rightWidth = rightWidth || window.Number.MAX_VALUE;\n\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n  // have the same media dimensions/ resolution\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n  }\n  return leftWidth - rightWidth;\n};\n\nexports.comparePlaylistResolution = comparePlaylistResolution;\n/**\n * Chooses the appropriate media playlist based on bandwidth and player size\n *\n * @param {Object} master\n *        Object representation of the master manifest\n * @param {Number} playerBandwidth\n *        Current calculated bandwidth of the player\n * @param {Number} playerWidth\n *        Current width of the player element\n * @param {Number} playerHeight\n *        Current height of the player element\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight) {\n  // convert the playlists to an intermediary representation to make comparisons easier\n  var sortedPlaylistReps = master.playlists.map(function (playlist) {\n    var width = undefined;\n    var height = undefined;\n    var bandwidth = undefined;\n\n    width = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n    height = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n    bandwidth = playlist.attributes.BANDWIDTH;\n\n    bandwidth = bandwidth || window.Number.MAX_VALUE;\n\n    return {\n      bandwidth: bandwidth,\n      width: width,\n      height: height,\n      playlist: playlist\n    };\n  });\n\n  stableSort(sortedPlaylistReps, function (left, right) {\n    return left.bandwidth - right.bandwidth;\n  });\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return !_playlist2['default'].isIncompatible(rep.playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return _playlist2['default'].isEnabled(rep.playlist);\n  });\n\n  if (!enabledPlaylistReps.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n      return !_playlist2['default'].isDisabled(rep.playlist);\n    });\n  }\n\n  // filter out any variant that has greater effective bitrate\n  // than the current estimated bandwidth\n  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\n    return rep.bandwidth * _config2['default'].BANDWIDTH_VARIANCE < playerBandwidth;\n  });\n\n  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];\n\n  // get all of the renditions with the same (highest) bandwidth\n  // and then taking the very first element\n  var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  // filter out playlists without resolution information\n  var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.width && rep.height;\n  });\n\n  // sort variants by resolution\n  stableSort(haveResolution, function (left, right) {\n    return left.width - right.width;\n  });\n\n  // if we have the exact resolution as the player use it\n  var resolutionBestRepList = haveResolution.filter(function (rep) {\n    return rep.width === playerWidth && rep.height === playerHeight;\n  });\n\n  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];\n  // ensure that we pick the highest bandwidth variant that have exact resolution\n  var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  var resolutionPlusOneList = undefined;\n  var resolutionPlusOneSmallest = undefined;\n  var resolutionPlusOneRep = undefined;\n\n  // find the smallest variant that is larger than the player\n  // if there is no match of exact resolution\n  if (!resolutionBestRep) {\n    resolutionPlusOneList = haveResolution.filter(function (rep) {\n      return rep.width > playerWidth || rep.height > playerHeight;\n    });\n\n    // find all the variants have the same smallest resolution\n    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\n      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\n    });\n\n    // ensure that we also pick the highest bandwidth variant that\n    // is just-larger-than the video player\n    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n    })[0];\n  }\n\n  // fallback chain of variants\n  var chosenRep = resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n\n  return chosenRep ? chosenRep.playlist : null;\n};\n\nexports.simpleSelector = simpleSelector;\n// Playlist Selectors\n\n/**\n * Chooses the appropriate media playlist based on the most recent\n * bandwidth estimate and the player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar lastBandwidthSelector = function lastBandwidthSelector() {\n  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n};\n\nexports.lastBandwidthSelector = lastBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on an\n * exponential-weighted moving average of the bandwidth after\n * filtering for player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @param {Number} decay - a number between 0 and 1. Higher values of\n * this parameter will cause previous bandwidth estimates to lose\n * significance more quickly.\n * @return {Function} a function which can be invoked to create a new\n * playlist selector function.\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n */\nvar movingAverageBandwidthSelector = function movingAverageBandwidthSelector(decay) {\n  var average = -1;\n\n  if (decay < 0 || decay > 1) {\n    throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n  }\n\n  return function () {\n    if (average < 0) {\n      average = this.systemBandwidth;\n    }\n\n    average = decay * this.systemBandwidth + (1 - decay) * average;\n    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n  };\n};\n\nexports.movingAverageBandwidthSelector = movingAverageBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on the potential to rebuffer\n *\n * @param {Object} settings\n *        Object of information required to use this selector\n * @param {Object} settings.master\n *        Object representation of the master manifest\n * @param {Number} settings.currentTime\n *        The current time of the player\n * @param {Number} settings.bandwidth\n *        Current measured bandwidth\n * @param {Number} settings.duration\n *        Duration of the media\n * @param {Number} settings.segmentDuration\n *        Segment duration to be used in round trip time calculations\n * @param {Number} settings.timeUntilRebuffer\n *        Time left in seconds until the player has to rebuffer\n * @param {Number} settings.currentTimeline\n *        The current timeline segments are being loaded from\n * @param {SyncController} settings.syncController\n *        SyncController for determining if we have a sync point for a given playlist\n * @return {Object|null}\n *         {Object} return.playlist\n *         The highest bandwidth playlist with the least amount of rebuffering\n *         {Number} return.rebufferingImpact\n *         The amount of time in seconds switching to this playlist will rebuffer. A\n *         negative value means that switching will cause zero rebuffering.\n */\nvar minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\n  var master = settings.master;\n  var currentTime = settings.currentTime;\n  var bandwidth = settings.bandwidth;\n  var duration = settings.duration;\n  var segmentDuration = settings.segmentDuration;\n  var timeUntilRebuffer = settings.timeUntilRebuffer;\n  var currentTimeline = settings.currentTimeline;\n  var syncController = settings.syncController;\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  var compatiblePlaylists = master.playlists.filter(function (playlist) {\n    return !_playlist2['default'].isIncompatible(playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylists = compatiblePlaylists.filter(_playlist2['default'].isEnabled);\n\n  if (!enabledPlaylists.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\n      return !_playlist2['default'].isDisabled(playlist);\n    });\n  }\n\n  var bandwidthPlaylists = enabledPlaylists.filter(_playlist2['default'].hasAttribute.bind(null, 'BANDWIDTH'));\n\n  var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\n    var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);\n    // If there is no sync point for this playlist, switching to it will require a\n    // sync request first. This will double the request time\n    var numRequests = syncPoint ? 1 : 2;\n    var requestTimeEstimate = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n\n    return {\n      playlist: playlist,\n      rebufferingImpact: rebufferingImpact\n    };\n  });\n\n  var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\n    return estimate.rebufferingImpact <= 0;\n  });\n\n  // Sort by bandwidth DESC\n  stableSort(noRebufferingPlaylists, function (a, b) {\n    return comparePlaylistBandwidth(b.playlist, a.playlist);\n  });\n\n  if (noRebufferingPlaylists.length) {\n    return noRebufferingPlaylists[0];\n  }\n\n  stableSort(rebufferingEstimates, function (a, b) {\n    return a.rebufferingImpact - b.rebufferingImpact;\n  });\n\n  return rebufferingEstimates[0] || null;\n};\n\nexports.minRebufferMaxBandwidthSelector = minRebufferMaxBandwidthSelector;\n/**\n * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n * one with video.  If no renditions with video exist, return the lowest audio rendition.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Object|null}\n *         {Object} return.playlist\n *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n *         exists pick the lowest audio rendition.\n */\nvar lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations or playback errors\n  var playlists = this.playlists.master.playlists.filter(_playlist2['default'].isEnabled);\n\n  // Sort ascending by bitrate\n  stableSort(playlists, function (a, b) {\n    return comparePlaylistBandwidth(a, b);\n  });\n\n  // Parse and assume that playlists with no video codec have no video\n  // (this is not necessarily true, although it is generally true).\n  //\n  // If an entire manifest has no valid videos everything will get filtered\n  // out.\n  var playlistsWithVideo = playlists.filter(function (playlist) {\n    return (0, _utilCodecsJs.parseCodecs)(playlist.attributes.CODECS).videoCodec;\n  });\n\n  return playlistsWithVideo[0] || null;\n};\nexports.lowestBitrateCompatibleVariantSelector = lowestBitrateCompatibleVariantSelector;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}