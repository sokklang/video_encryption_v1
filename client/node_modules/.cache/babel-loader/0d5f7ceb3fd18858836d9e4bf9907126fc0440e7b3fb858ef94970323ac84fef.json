{"ast":null,"code":"/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\n\nvar Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function (bytes, start, end) {\n    var i,\n      result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function (bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function (bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function (data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  },\n  tagParsers = {\n    TXXX: function (tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function (tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function (tag) {\n      var i;\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\nMetadataStream = function (options) {\n  var settings = {\n      debug: !!(options && options.debug),\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n  this.push = function (chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n        // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var d = frame.data,\n            size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\nmodule.exports = MetadataStream;","map":{"version":3,"names":["Stream","require","StreamTypes","percentEncode","bytes","start","end","i","result","toString","slice","parseUtf8","decodeURIComponent","parseIso88591","unescape","parseSyncSafeInteger","data","tagParsers","TXXX","tag","length","description","value","replace","WXXX","url","PRIV","owner","privateData","subarray","MetadataStream","options","settings","debug","descriptor","tagSize","buffer","bufferSize","prototype","init","call","dispatchType","METADATA_STREAM_TYPE","push","chunk","frameStart","frameSize","frame","frameHeader","type","dataAlignmentIndicator","charCodeAt","console","log","byteLength","Uint8Array","frames","pts","dts","set","shift","String","fromCharCode","id","key","d","size","timeStamp","undefined","trigger","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/metadata-stream.js"],"sourcesContent":["/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\nvar\n  Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}