{"ast":null,"code":"/**\n * ranges\n *\n * Utilities for working with TimeRanges.\n *\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n// Fudge factor to account for TimeRanges rounding\nvar TIME_FUDGE_FACTOR = 1 / 30;\n// Comparisons between time values such as current time and the end of the buffered range\n// can be misleading because of precision differences or when the current media has poorly\n// aligned audio and video, which can cause values to be slightly off from what you would\n// expect. This value is what we consider to be safe to use in such comparisons to account\n// for these scenarios.\nvar SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n\n/**\n * Clamps a value to within a range\n * @param {Number} num - the value to clamp\n * @param {Number} start - the start of the range to clamp within, inclusive\n * @param {Number} end - the end of the range to clamp within, inclusive\n * @return {Number}\n */\nvar clamp = function clamp(num, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n  var start = _ref2[0];\n  var end = _ref2[1];\n  return Math.min(Math.max(start, num), end);\n};\nvar filterRanges = function filterRanges(timeRanges, predicate) {\n  var results = [];\n  var i = undefined;\n  if (timeRanges && timeRanges.length) {\n    // Search for ranges that match the predicate\n    for (i = 0; i < timeRanges.length; i++) {\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\n      }\n    }\n  }\n  return _videoJs2['default'].createTimeRanges(results);\n};\n\n/**\n * Attempts to find the buffered TimeRange that contains the specified\n * time.\n * @param {TimeRanges} buffered - the TimeRanges object to query\n * @param {number} time  - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object\n */\nvar findRange = function findRange(buffered, time) {\n  return filterRanges(buffered, function (start, end) {\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns the TimeRanges that begin later than the specified time.\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\n * @param {number} time - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object.\n */\nvar findNextRange = function findNextRange(timeRanges, time) {\n  return filterRanges(timeRanges, function (start) {\n    return start - TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns gaps within a list of TimeRanges\n * @param {TimeRanges} buffered - the TimeRanges object\n * @return {TimeRanges} a TimeRanges object of gaps\n */\nvar findGaps = function findGaps(buffered) {\n  if (buffered.length < 2) {\n    return _videoJs2['default'].createTimeRanges();\n  }\n  var ranges = [];\n  for (var i = 1; i < buffered.length; i++) {\n    var start = buffered.end(i - 1);\n    var end = buffered.start(i);\n    ranges.push([start, end]);\n  }\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Search for a likely end time for the segment that was just appened\n * based on the state of the `buffered` property before and after the\n * append. If we fin only one such uncommon end-point return it.\n * @param {TimeRanges} original - the buffered time ranges before the update\n * @param {TimeRanges} update - the buffered time ranges after the update\n * @returns {Number|null} the end time added between `original` and `update`,\n * or null if one cannot be unambiguously determined.\n */\nvar findSoleUncommonTimeRangesEnd = function findSoleUncommonTimeRangesEnd(original, update) {\n  var i = undefined;\n  var start = undefined;\n  var end = undefined;\n  var result = [];\n  var edges = [];\n\n  // In order to qualify as a possible candidate, the end point must:\n  //  1) Not have already existed in the `original` ranges\n  //  2) Not result from the shrinking of a range that already existed\n  //     in the `original` ranges\n  //  3) Not be contained inside of a range that existed in `original`\n  var overlapsCurrentEnd = function overlapsCurrentEnd(span) {\n    return span[0] <= end && span[1] >= end;\n  };\n  if (original) {\n    // Save all the edges in the `original` TimeRanges object\n    for (i = 0; i < original.length; i++) {\n      start = original.start(i);\n      end = original.end(i);\n      edges.push([start, end]);\n    }\n  }\n  if (update) {\n    // Save any end-points in `update` that are not in the `original`\n    // TimeRanges object\n    for (i = 0; i < update.length; i++) {\n      start = update.start(i);\n      end = update.end(i);\n      if (edges.some(overlapsCurrentEnd)) {\n        continue;\n      }\n\n      // at this point it must be a unique non-shrinking end edge\n      result.push(end);\n    }\n  }\n\n  // we err on the side of caution and return null if didn't find\n  // exactly *one* differing end edge in the search above\n  if (result.length !== 1) {\n    return null;\n  }\n  return result[0];\n};\n\n/**\n * Calculate the intersection of two TimeRanges\n * @param {TimeRanges} bufferA\n * @param {TimeRanges} bufferB\n * @returns {TimeRanges} The interesection of `bufferA` with `bufferB`\n */\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\n  var start = null;\n  var end = null;\n  var arity = 0;\n  var extents = [];\n  var ranges = [];\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n    return _videoJs2['default'].createTimeRange();\n  }\n\n  // Handle the case where we have both buffers and create an\n  // intersection of the two\n  var count = bufferA.length;\n\n  // A) Gather up all start and end times\n  while (count--) {\n    extents.push({\n      time: bufferA.start(count),\n      type: 'start'\n    });\n    extents.push({\n      time: bufferA.end(count),\n      type: 'end'\n    });\n  }\n  count = bufferB.length;\n  while (count--) {\n    extents.push({\n      time: bufferB.start(count),\n      type: 'start'\n    });\n    extents.push({\n      time: bufferB.end(count),\n      type: 'end'\n    });\n  }\n  // B) Sort them by time\n  extents.sort(function (a, b) {\n    return a.time - b.time;\n  });\n\n  // C) Go along one by one incrementing arity for start and decrementing\n  //    arity for ends\n  for (count = 0; count < extents.length; count++) {\n    if (extents[count].type === 'start') {\n      arity++;\n\n      // D) If arity is ever incremented to 2 we are entering an\n      //    overlapping range\n      if (arity === 2) {\n        start = extents[count].time;\n      }\n    } else if (extents[count].type === 'end') {\n      arity--;\n\n      // E) If arity is ever decremented to 1 we leaving an\n      //    overlapping range\n      if (arity === 1) {\n        end = extents[count].time;\n      }\n    }\n\n    // F) Record overlapping ranges\n    if (start !== null && end !== null) {\n      ranges.push([start, end]);\n      start = null;\n      end = null;\n    }\n  }\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Calculates the percentage of `segmentRange` that overlaps the\n * `buffered` time ranges.\n * @param {TimeRanges} segmentRange - the time range that the segment\n * covers adjusted according to currentTime\n * @param {TimeRanges} referenceRange - the original time range that the\n * segment covers\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the currently buffered time ranges\n * @returns {Number} percent of the segment currently buffered\n */\nvar calculateBufferedPercent = function calculateBufferedPercent(adjustedRange, referenceRange, currentTime, buffered) {\n  var referenceDuration = referenceRange.end(0) - referenceRange.start(0);\n  var adjustedDuration = adjustedRange.end(0) - adjustedRange.start(0);\n  var bufferMissingFromAdjusted = referenceDuration - adjustedDuration;\n  var adjustedIntersection = bufferIntersection(adjustedRange, buffered);\n  var referenceIntersection = bufferIntersection(referenceRange, buffered);\n  var adjustedOverlap = 0;\n  var referenceOverlap = 0;\n  var count = adjustedIntersection.length;\n  while (count--) {\n    adjustedOverlap += adjustedIntersection.end(count) - adjustedIntersection.start(count);\n\n    // If the current overlap segment starts at currentTime, then increase the\n    // overlap duration so that it actually starts at the beginning of referenceRange\n    // by including the difference between the two Range's durations\n    // This is a work around for the way Flash has no buffer before currentTime\n    if (adjustedIntersection.start(count) === currentTime) {\n      adjustedOverlap += bufferMissingFromAdjusted;\n    }\n  }\n  count = referenceIntersection.length;\n  while (count--) {\n    referenceOverlap += referenceIntersection.end(count) - referenceIntersection.start(count);\n  }\n\n  // Use whichever value is larger for the percentage-buffered since that value\n  // is likely more accurate because the only way\n  return Math.max(adjustedOverlap, referenceOverlap) / referenceDuration * 100;\n};\n\n/**\n * Return the amount of a range specified by the startOfSegment and segmentDuration\n * overlaps the current buffered content.\n *\n * @param {Number} startOfSegment - the time where the segment begins\n * @param {Number} segmentDuration - the duration of the segment in seconds\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the state of the buffer\n * @returns {Number} percentage of the segment's time range that is\n * already in `buffered`\n */\nvar getSegmentBufferedPercent = function getSegmentBufferedPercent(startOfSegment, segmentDuration, currentTime, buffered) {\n  var endOfSegment = startOfSegment + segmentDuration;\n\n  // The entire time range of the segment\n  var originalSegmentRange = _videoJs2['default'].createTimeRanges([[startOfSegment, endOfSegment]]);\n\n  // The adjusted segment time range that is setup such that it starts\n  // no earlier than currentTime\n  // Flash has no notion of a back-buffer so adjustedSegmentRange adjusts\n  // for that and the function will still return 100% if a only half of a\n  // segment is actually in the buffer as long as the currentTime is also\n  // half-way through the segment\n  var adjustedSegmentRange = _videoJs2['default'].createTimeRanges([[clamp(startOfSegment, [currentTime, endOfSegment]), endOfSegment]]);\n\n  // This condition happens when the currentTime is beyond the segment's\n  // end time\n  if (adjustedSegmentRange.start(0) === adjustedSegmentRange.end(0)) {\n    return 0;\n  }\n  var percent = calculateBufferedPercent(adjustedSegmentRange, originalSegmentRange, currentTime, buffered);\n\n  // If the segment is reported as having a zero duration, return 0%\n  // since it is likely that we will need to fetch the segment\n  if (isNaN(percent) || percent === Infinity || percent === -Infinity) {\n    return 0;\n  }\n  return percent;\n};\n\n/**\n * Gets a human readable string for a TimeRange\n *\n * @param {TimeRange} range\n * @returns {String} a human readable string\n */\nvar printableRange = function printableRange(range) {\n  var strArr = [];\n  if (!range || !range.length) {\n    return '';\n  }\n  for (var i = 0; i < range.length; i++) {\n    strArr.push(range.start(i) + ' => ' + range.end(i));\n  }\n  return strArr.join(', ');\n};\n\n/**\n * Calculates the amount of time left in seconds until the player hits the end of the\n * buffer and causes a rebuffer\n *\n * @param {TimeRange} buffered\n *        The state of the buffer\n * @param {Numnber} currentTime\n *        The current time of the player\n * @param {Number} playbackRate\n *        The current playback rate of the player. Defaults to 1.\n * @return {Number}\n *         Time until the player has to start rebuffering in seconds.\n * @function timeUntilRebuffer\n */\nvar timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime) {\n  var playbackRate = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n  return (bufferedEnd - currentTime) / playbackRate;\n};\nexports['default'] = {\n  findRange: findRange,\n  findNextRange: findNextRange,\n  findGaps: findGaps,\n  findSoleUncommonTimeRangesEnd: findSoleUncommonTimeRangesEnd,\n  getSegmentBufferedPercent: getSegmentBufferedPercent,\n  TIME_FUDGE_FACTOR: TIME_FUDGE_FACTOR,\n  SAFE_TIME_DELTA: SAFE_TIME_DELTA,\n  printableRange: printableRange,\n  timeUntilRebuffer: timeUntilRebuffer\n};\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_interopRequireDefault","obj","__esModule","_videoJs","require","_videoJs2","TIME_FUDGE_FACTOR","SAFE_TIME_DELTA","clamp","num","_ref","_ref2","start","end","Math","min","max","filterRanges","timeRanges","predicate","results","createTimeRanges","findRange","buffered","time","findNextRange","findGaps","ranges","findSoleUncommonTimeRangesEnd","original","update","result","edges","overlapsCurrentEnd","span","some","bufferIntersection","bufferA","bufferB","arity","extents","createTimeRange","count","type","sort","a","b","calculateBufferedPercent","adjustedRange","referenceRange","currentTime","referenceDuration","adjustedDuration","bufferMissingFromAdjusted","adjustedIntersection","referenceIntersection","adjustedOverlap","referenceOverlap","getSegmentBufferedPercent","startOfSegment","segmentDuration","endOfSegment","originalSegmentRange","adjustedSegmentRange","percent","isNaN","Infinity","printableRange","range","strArr","join","timeUntilRebuffer","playbackRate","arguments","bufferedEnd","module"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/ranges.js"],"sourcesContent":["/**\n * ranges\n *\n * Utilities for working with TimeRanges.\n *\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n// Fudge factor to account for TimeRanges rounding\nvar TIME_FUDGE_FACTOR = 1 / 30;\n// Comparisons between time values such as current time and the end of the buffered range\n// can be misleading because of precision differences or when the current media has poorly\n// aligned audio and video, which can cause values to be slightly off from what you would\n// expect. This value is what we consider to be safe to use in such comparisons to account\n// for these scenarios.\nvar SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n\n/**\n * Clamps a value to within a range\n * @param {Number} num - the value to clamp\n * @param {Number} start - the start of the range to clamp within, inclusive\n * @param {Number} end - the end of the range to clamp within, inclusive\n * @return {Number}\n */\nvar clamp = function clamp(num, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var start = _ref2[0];\n  var end = _ref2[1];\n\n  return Math.min(Math.max(start, num), end);\n};\nvar filterRanges = function filterRanges(timeRanges, predicate) {\n  var results = [];\n  var i = undefined;\n\n  if (timeRanges && timeRanges.length) {\n    // Search for ranges that match the predicate\n    for (i = 0; i < timeRanges.length; i++) {\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\n      }\n    }\n  }\n\n  return _videoJs2['default'].createTimeRanges(results);\n};\n\n/**\n * Attempts to find the buffered TimeRange that contains the specified\n * time.\n * @param {TimeRanges} buffered - the TimeRanges object to query\n * @param {number} time  - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object\n */\nvar findRange = function findRange(buffered, time) {\n  return filterRanges(buffered, function (start, end) {\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns the TimeRanges that begin later than the specified time.\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\n * @param {number} time - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object.\n */\nvar findNextRange = function findNextRange(timeRanges, time) {\n  return filterRanges(timeRanges, function (start) {\n    return start - TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns gaps within a list of TimeRanges\n * @param {TimeRanges} buffered - the TimeRanges object\n * @return {TimeRanges} a TimeRanges object of gaps\n */\nvar findGaps = function findGaps(buffered) {\n  if (buffered.length < 2) {\n    return _videoJs2['default'].createTimeRanges();\n  }\n\n  var ranges = [];\n\n  for (var i = 1; i < buffered.length; i++) {\n    var start = buffered.end(i - 1);\n    var end = buffered.start(i);\n\n    ranges.push([start, end]);\n  }\n\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Search for a likely end time for the segment that was just appened\n * based on the state of the `buffered` property before and after the\n * append. If we fin only one such uncommon end-point return it.\n * @param {TimeRanges} original - the buffered time ranges before the update\n * @param {TimeRanges} update - the buffered time ranges after the update\n * @returns {Number|null} the end time added between `original` and `update`,\n * or null if one cannot be unambiguously determined.\n */\nvar findSoleUncommonTimeRangesEnd = function findSoleUncommonTimeRangesEnd(original, update) {\n  var i = undefined;\n  var start = undefined;\n  var end = undefined;\n  var result = [];\n  var edges = [];\n\n  // In order to qualify as a possible candidate, the end point must:\n  //  1) Not have already existed in the `original` ranges\n  //  2) Not result from the shrinking of a range that already existed\n  //     in the `original` ranges\n  //  3) Not be contained inside of a range that existed in `original`\n  var overlapsCurrentEnd = function overlapsCurrentEnd(span) {\n    return span[0] <= end && span[1] >= end;\n  };\n\n  if (original) {\n    // Save all the edges in the `original` TimeRanges object\n    for (i = 0; i < original.length; i++) {\n      start = original.start(i);\n      end = original.end(i);\n\n      edges.push([start, end]);\n    }\n  }\n\n  if (update) {\n    // Save any end-points in `update` that are not in the `original`\n    // TimeRanges object\n    for (i = 0; i < update.length; i++) {\n      start = update.start(i);\n      end = update.end(i);\n\n      if (edges.some(overlapsCurrentEnd)) {\n        continue;\n      }\n\n      // at this point it must be a unique non-shrinking end edge\n      result.push(end);\n    }\n  }\n\n  // we err on the side of caution and return null if didn't find\n  // exactly *one* differing end edge in the search above\n  if (result.length !== 1) {\n    return null;\n  }\n\n  return result[0];\n};\n\n/**\n * Calculate the intersection of two TimeRanges\n * @param {TimeRanges} bufferA\n * @param {TimeRanges} bufferB\n * @returns {TimeRanges} The interesection of `bufferA` with `bufferB`\n */\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\n  var start = null;\n  var end = null;\n  var arity = 0;\n  var extents = [];\n  var ranges = [];\n\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n    return _videoJs2['default'].createTimeRange();\n  }\n\n  // Handle the case where we have both buffers and create an\n  // intersection of the two\n  var count = bufferA.length;\n\n  // A) Gather up all start and end times\n  while (count--) {\n    extents.push({ time: bufferA.start(count), type: 'start' });\n    extents.push({ time: bufferA.end(count), type: 'end' });\n  }\n  count = bufferB.length;\n  while (count--) {\n    extents.push({ time: bufferB.start(count), type: 'start' });\n    extents.push({ time: bufferB.end(count), type: 'end' });\n  }\n  // B) Sort them by time\n  extents.sort(function (a, b) {\n    return a.time - b.time;\n  });\n\n  // C) Go along one by one incrementing arity for start and decrementing\n  //    arity for ends\n  for (count = 0; count < extents.length; count++) {\n    if (extents[count].type === 'start') {\n      arity++;\n\n      // D) If arity is ever incremented to 2 we are entering an\n      //    overlapping range\n      if (arity === 2) {\n        start = extents[count].time;\n      }\n    } else if (extents[count].type === 'end') {\n      arity--;\n\n      // E) If arity is ever decremented to 1 we leaving an\n      //    overlapping range\n      if (arity === 1) {\n        end = extents[count].time;\n      }\n    }\n\n    // F) Record overlapping ranges\n    if (start !== null && end !== null) {\n      ranges.push([start, end]);\n      start = null;\n      end = null;\n    }\n  }\n\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Calculates the percentage of `segmentRange` that overlaps the\n * `buffered` time ranges.\n * @param {TimeRanges} segmentRange - the time range that the segment\n * covers adjusted according to currentTime\n * @param {TimeRanges} referenceRange - the original time range that the\n * segment covers\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the currently buffered time ranges\n * @returns {Number} percent of the segment currently buffered\n */\nvar calculateBufferedPercent = function calculateBufferedPercent(adjustedRange, referenceRange, currentTime, buffered) {\n  var referenceDuration = referenceRange.end(0) - referenceRange.start(0);\n  var adjustedDuration = adjustedRange.end(0) - adjustedRange.start(0);\n  var bufferMissingFromAdjusted = referenceDuration - adjustedDuration;\n  var adjustedIntersection = bufferIntersection(adjustedRange, buffered);\n  var referenceIntersection = bufferIntersection(referenceRange, buffered);\n  var adjustedOverlap = 0;\n  var referenceOverlap = 0;\n\n  var count = adjustedIntersection.length;\n\n  while (count--) {\n    adjustedOverlap += adjustedIntersection.end(count) - adjustedIntersection.start(count);\n\n    // If the current overlap segment starts at currentTime, then increase the\n    // overlap duration so that it actually starts at the beginning of referenceRange\n    // by including the difference between the two Range's durations\n    // This is a work around for the way Flash has no buffer before currentTime\n    if (adjustedIntersection.start(count) === currentTime) {\n      adjustedOverlap += bufferMissingFromAdjusted;\n    }\n  }\n\n  count = referenceIntersection.length;\n\n  while (count--) {\n    referenceOverlap += referenceIntersection.end(count) - referenceIntersection.start(count);\n  }\n\n  // Use whichever value is larger for the percentage-buffered since that value\n  // is likely more accurate because the only way\n  return Math.max(adjustedOverlap, referenceOverlap) / referenceDuration * 100;\n};\n\n/**\n * Return the amount of a range specified by the startOfSegment and segmentDuration\n * overlaps the current buffered content.\n *\n * @param {Number} startOfSegment - the time where the segment begins\n * @param {Number} segmentDuration - the duration of the segment in seconds\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the state of the buffer\n * @returns {Number} percentage of the segment's time range that is\n * already in `buffered`\n */\nvar getSegmentBufferedPercent = function getSegmentBufferedPercent(startOfSegment, segmentDuration, currentTime, buffered) {\n  var endOfSegment = startOfSegment + segmentDuration;\n\n  // The entire time range of the segment\n  var originalSegmentRange = _videoJs2['default'].createTimeRanges([[startOfSegment, endOfSegment]]);\n\n  // The adjusted segment time range that is setup such that it starts\n  // no earlier than currentTime\n  // Flash has no notion of a back-buffer so adjustedSegmentRange adjusts\n  // for that and the function will still return 100% if a only half of a\n  // segment is actually in the buffer as long as the currentTime is also\n  // half-way through the segment\n  var adjustedSegmentRange = _videoJs2['default'].createTimeRanges([[clamp(startOfSegment, [currentTime, endOfSegment]), endOfSegment]]);\n\n  // This condition happens when the currentTime is beyond the segment's\n  // end time\n  if (adjustedSegmentRange.start(0) === adjustedSegmentRange.end(0)) {\n    return 0;\n  }\n\n  var percent = calculateBufferedPercent(adjustedSegmentRange, originalSegmentRange, currentTime, buffered);\n\n  // If the segment is reported as having a zero duration, return 0%\n  // since it is likely that we will need to fetch the segment\n  if (isNaN(percent) || percent === Infinity || percent === -Infinity) {\n    return 0;\n  }\n\n  return percent;\n};\n\n/**\n * Gets a human readable string for a TimeRange\n *\n * @param {TimeRange} range\n * @returns {String} a human readable string\n */\nvar printableRange = function printableRange(range) {\n  var strArr = [];\n\n  if (!range || !range.length) {\n    return '';\n  }\n\n  for (var i = 0; i < range.length; i++) {\n    strArr.push(range.start(i) + ' => ' + range.end(i));\n  }\n\n  return strArr.join(', ');\n};\n\n/**\n * Calculates the amount of time left in seconds until the player hits the end of the\n * buffer and causes a rebuffer\n *\n * @param {TimeRange} buffered\n *        The state of the buffer\n * @param {Numnber} currentTime\n *        The current time of the player\n * @param {Number} playbackRate\n *        The current playback rate of the player. Defaults to 1.\n * @return {Number}\n *         Time until the player has to start rebuffering in seconds.\n * @function timeUntilRebuffer\n */\nvar timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime) {\n  var playbackRate = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n\n  return (bufferedEnd - currentTime) / playbackRate;\n};\n\nexports['default'] = {\n  findRange: findRange,\n  findNextRange: findNextRange,\n  findGaps: findGaps,\n  findSoleUncommonTimeRangesEnd: findSoleUncommonTimeRangesEnd,\n  getSegmentBufferedPercent: getSegmentBufferedPercent,\n  TIME_FUDGE_FACTOR: TIME_FUDGE_FACTOR,\n  SAFE_TIME_DELTA: SAFE_TIME_DELTA,\n  printableRange: printableRange,\n  timeUntilRebuffer: timeUntilRebuffer\n};\nmodule.exports = exports['default'];"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}