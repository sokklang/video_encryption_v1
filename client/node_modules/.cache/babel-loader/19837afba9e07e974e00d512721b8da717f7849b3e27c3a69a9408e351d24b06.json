{"ast":null,"code":"/**\n * @module playlist-loader\n *\n * @file A state machine that manages the loading, caching, and updating of\n * M3U8 playlists.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x, _x2, _x3) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x,\n      property = _x2,\n      receiver = _x3;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x = parent;\n        _x2 = property;\n        _x3 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _resolveUrl = require('./resolve-url');\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\nvar _videoJs = require('video.js');\nvar _m3u8Parser = require('m3u8-parser');\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\nvar _globalWindow = require('global/window');\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * Returns a new array of segments that is the result of merging\n * properties from an older list of segments onto an updated\n * list. No properties on the updated playlist will be overridden.\n *\n * @param {Array} original the outdated list of segments\n * @param {Array} update the updated list of segments\n * @param {Number=} offset the index of the first update\n * segment in the original segment list. For non-live playlists,\n * this should always be zero and does not need to be\n * specified. For live playlists, it should be the difference\n * between the media sequence numbers in the original and updated\n * playlists.\n * @return a list of merged segment objects\n */\nvar updateSegments = function updateSegments(original, update, offset) {\n  var result = update.slice();\n  offset = offset || 0;\n  var length = Math.min(original.length, update.length + offset);\n  for (var i = offset; i < length; i++) {\n    result[i - offset] = (0, _videoJs.mergeOptions)(original[i], result[i - offset]);\n  }\n  return result;\n};\nexports.updateSegments = updateSegments;\nvar resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\n  if (!segment.resolvedUri) {\n    segment.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.uri);\n  }\n  if (segment.key && !segment.key.resolvedUri) {\n    segment.key.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.key.uri);\n  }\n  if (segment.map && !segment.map.resolvedUri) {\n    segment.map.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.map.uri);\n  }\n};\nexports.resolveSegmentUris = resolveSegmentUris;\n/**\n  * Returns a new master playlist that is the result of merging an\n  * updated media playlist into the original version. If the\n  * updated media playlist does not match any of the playlist\n  * entries in the original master playlist, null is returned.\n  *\n  * @param {Object} master a parsed master M3U8 object\n  * @param {Object} media a parsed media M3U8 object\n  * @return {Object} a new object that represents the original\n  * master playlist with the updated media playlist merged in, or\n  * null if the merge produced no change.\n  */\nvar updateMaster = function updateMaster(master, media) {\n  var result = (0, _videoJs.mergeOptions)(master, {});\n  var playlist = result.playlists.filter(function (p) {\n    return p.uri === media.uri;\n  })[0];\n  if (!playlist) {\n    return null;\n  }\n\n  // consider the playlist unchanged if the number of segments is equal and the media\n  // sequence number is unchanged\n  if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\n    return null;\n  }\n  var mergedPlaylist = (0, _videoJs.mergeOptions)(playlist, media);\n\n  // if the update could overlap existing segment information, merge the two segment lists\n  if (playlist.segments) {\n    mergedPlaylist.segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\n  }\n\n  // resolve any segment URIs to prevent us from having to do it later\n  mergedPlaylist.segments.forEach(function (segment) {\n    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n  });\n\n  // TODO Right now in the playlists array there are two references to each playlist, one\n  // that is referenced by index, and one by URI. The index reference may no longer be\n  // necessary.\n  for (var i = 0; i < result.playlists.length; i++) {\n    if (result.playlists[i].uri === media.uri) {\n      result.playlists[i] = mergedPlaylist;\n    }\n  }\n  result.playlists[media.uri] = mergedPlaylist;\n  return result;\n};\nexports.updateMaster = updateMaster;\nvar setupMediaPlaylists = function setupMediaPlaylists(master) {\n  // setup by-URI lookups and resolve media playlist URIs\n  var i = master.playlists.length;\n  while (i--) {\n    var playlist = master.playlists[i];\n    master.playlists[playlist.uri] = playlist;\n    playlist.resolvedUri = (0, _resolveUrl2['default'])(master.uri, playlist.uri);\n    if (!playlist.attributes) {\n      // Although the spec states an #EXT-X-STREAM-INF tag MUST have a\n      // BANDWIDTH attribute, we can play the stream without it. This means a poorly\n      // formatted master playlist may not have an attribute list. An attributes\n      // property is added here to prevent undefined references when we encounter\n      // this scenario.\n      playlist.attributes = {};\n      _videoJs.log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n    }\n  }\n};\nexports.setupMediaPlaylists = setupMediaPlaylists;\nvar resolveMediaGroupUris = function resolveMediaGroupUris(master) {\n  ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n        if (mediaProperties.uri) {\n          mediaProperties.resolvedUri = (0, _resolveUrl2['default'])(master.uri, mediaProperties.uri);\n        }\n      }\n    }\n  });\n};\nexports.resolveMediaGroupUris = resolveMediaGroupUris;\n/**\n * Calculates the time to wait before refreshing a live playlist\n *\n * @param {Object} media\n *        The current media\n * @param {Boolean} update\n *        True if there were any updates from the last refresh, false otherwise\n * @return {Number}\n *         The time in ms to wait before refreshing the live playlist\n */\nvar refreshDelay = function refreshDelay(media, update) {\n  var lastSegment = media.segments[media.segments.length - 1];\n  var delay = undefined;\n  if (update && lastSegment && lastSegment.duration) {\n    delay = lastSegment.duration * 1000;\n  } else {\n    // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n    delay = (media.targetDuration || 10) * 500;\n  }\n  return delay;\n};\nexports.refreshDelay = refreshDelay;\n/**\n * Load a playlist from a remote location\n *\n * @class PlaylistLoader\n * @extends videojs.EventTarget\n * @param {String} srcUrl the url to start with\n * @param {Object} hls\n * @param {Object} [options]\n * @param {Boolean} [options.withCredentials=false] the withCredentials xhr option\n * @param {Boolean} [options.handleManifestRedirects=false] whether to follow redirects, when any\n *        playlist request was redirected\n */\n\nvar PlaylistLoader = function (_EventTarget) {\n  _inherits(PlaylistLoader, _EventTarget);\n  function PlaylistLoader(srcUrl, hls, options) {\n    var _this = this;\n    _classCallCheck(this, PlaylistLoader);\n    _get(Object.getPrototypeOf(PlaylistLoader.prototype), 'constructor', this).call(this);\n    options = options || {};\n    this.srcUrl = srcUrl;\n    this.hls_ = hls;\n    this.withCredentials = !!options.withCredentials;\n    this.handleManifestRedirects = !!options.handleManifestRedirects;\n    if (!this.srcUrl) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    // initialize the loader state\n    this.state = 'HAVE_NOTHING';\n\n    // live playlist staleness timeout\n    this.on('mediaupdatetimeout', function () {\n      if (_this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n      _this.state = 'HAVE_CURRENT_METADATA';\n      _this.request = _this.hls_.xhr({\n        uri: (0, _resolveUrl2['default'])(_this.master.uri, _this.media().uri),\n        withCredentials: _this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this.request) {\n          return;\n        }\n        if (error) {\n          return _this.playlistRequestError(_this.request, _this.media().uri, 'HAVE_METADATA');\n        }\n        _this.haveMetadata(_this.request, _this.media().uri);\n      });\n    });\n  }\n  _createClass(PlaylistLoader, [{\n    key: 'playlistRequestError',\n    value: function playlistRequestError(xhr, url, startingState) {\n      // any in-flight request is now finished\n      this.request = null;\n      if (startingState) {\n        this.state = startingState;\n      }\n      this.error = {\n        playlist: this.master.playlists[url],\n        status: xhr.status,\n        message: 'HLS playlist request error at URL: ' + url,\n        responseText: xhr.responseText,\n        code: xhr.status >= 500 ? 4 : 2\n      };\n      this.trigger('error');\n    }\n\n    // update the playlist loader's state in response to a new or\n    // updated playlist.\n  }, {\n    key: 'haveMetadata',\n    value: function haveMetadata(xhr, url) {\n      var _this2 = this;\n\n      // any in-flight request is now finished\n      this.request = null;\n      this.state = 'HAVE_METADATA';\n      var parser = new _m3u8Parser2['default'].Parser();\n      parser.push(xhr.responseText);\n      parser.end();\n      parser.manifest.uri = url;\n      // m3u8-parser does not attach an attributes property to media playlists so make\n      // sure that the property is attached to avoid undefined reference errors\n      parser.manifest.attributes = parser.manifest.attributes || {};\n\n      // merge this playlist into the master\n      var update = updateMaster(this.master, parser.manifest);\n      this.targetDuration = parser.manifest.targetDuration;\n      if (update) {\n        this.master = update;\n        this.media_ = this.master.playlists[parser.manifest.uri];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n\n      // refresh live playlists after a target duration passes\n      if (!this.media().endList) {\n        _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          _this2.trigger('mediaupdatetimeout');\n        }, refreshDelay(this.media(), !!update));\n      }\n      this.trigger('loadedplaylist');\n    }\n\n    /**\n     * Abort any outstanding work and clean up.\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n    }\n  }, {\n    key: 'stopRequest',\n    value: function stopRequest() {\n      if (this.request) {\n        var oldRequest = this.request;\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n\n    /**\n     * When called without any arguments, returns the currently\n     * active media playlist. When called with a single argument,\n     * triggers the playlist loader to asynchronously switch to the\n     * specified media playlist. Calling this method while the\n     * loader is in the HAVE_NOTHING causes an error to be emitted\n     * but otherwise has no effect.\n     *\n     * @param {Object=} playlist the parsed media playlist\n     * object to switch to\n     * @return {Playlist} the current loaded media\n     */\n  }, {\n    key: 'media',\n    value: function media(playlist) {\n      var _this3 = this;\n\n      // getter\n      if (!playlist) {\n        return this.media_;\n      }\n\n      // setter\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n      var startingState = this.state;\n\n      // find the playlist object if the target playlist has been\n      // specified by URI\n      if (typeof playlist === 'string') {\n        if (!this.master.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.master.playlists[playlist];\n      }\n      var mediaChange = !this.media_ || playlist.uri !== this.media_.uri;\n\n      // switch to fully loaded playlists immediately\n      if (this.master.playlists[playlist.uri].endList) {\n        // abort outstanding playlist requests\n        if (this.request) {\n          this.request.onreadystatechange = null;\n          this.request.abort();\n          this.request = null;\n        }\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist;\n\n        // trigger media change if the active media has been updated\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          this.trigger('mediachange');\n        }\n        return;\n      }\n\n      // switching to the active playlist is a no-op\n      if (!mediaChange) {\n        return;\n      }\n      this.state = 'SWITCHING_MEDIA';\n\n      // there is already an outstanding playlist request\n      if (this.request) {\n        if (playlist.resolvedUri === this.request.url) {\n          // requesting to switch to the same playlist multiple times\n          // has no effect after the first\n          return;\n        }\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      }\n\n      // request the new playlist\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n      this.request = this.hls_.xhr({\n        uri: playlist.resolvedUri,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this3.request) {\n          return;\n        }\n        playlist.resolvedUri = _this3.resolveManifestRedirect(playlist.resolvedUri, req);\n        if (error) {\n          return _this3.playlistRequestError(_this3.request, playlist.uri, startingState);\n        }\n        _this3.haveMetadata(req, playlist.uri);\n\n        // fire loadedmetadata the first time a media playlist is loaded\n        if (startingState === 'HAVE_MASTER') {\n          _this3.trigger('loadedmetadata');\n        } else {\n          _this3.trigger('mediachange');\n        }\n      });\n    }\n\n    /**\n     * Checks whether xhr request was redirected and returns correct url depending\n     * on `handleManifestRedirects` option\n     *\n     * @api private\n     *\n     * @param  {String} url - an url being requested\n     * @param  {XMLHttpRequest} req - xhr request result\n     *\n     * @return {String}\n     */\n  }, {\n    key: 'resolveManifestRedirect',\n    value: function resolveManifestRedirect(url, req) {\n      if (this.handleManifestRedirects && req.responseURL && url !== req.responseURL) {\n        return req.responseURL;\n      }\n      return url;\n    }\n\n    /**\n     * pause loading of the playlist\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n      // Need to restore state now that no activity is happening\n      if (this.state === 'SWITCHING_MEDIA') {\n        // if the loader was in the process of switching media, it should either return to\n        // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\n        // playlist yet. This is determined by the existence of loader.media_\n        if (this.media_) {\n          this.state = 'HAVE_METADATA';\n        } else {\n          this.state = 'HAVE_MASTER';\n        }\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\n        this.state = 'HAVE_METADATA';\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'load',\n    value: function load(isFinalRendition) {\n      var _this4 = this;\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n      var media = this.media();\n      if (isFinalRendition) {\n        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          return _this4.load();\n        }, delay);\n        return;\n      }\n      if (!this.started) {\n        this.start();\n        return;\n      }\n      if (media && !media.endList) {\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this5 = this;\n      this.started = true;\n\n      // request the specified URL\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this5.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this5.request = null;\n        if (error) {\n          _this5.error = {\n            status: req.status,\n            message: 'HLS playlist request error at URL: ' + _this5.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this5.state === 'HAVE_NOTHING') {\n            _this5.started = false;\n          }\n          return _this5.trigger('error');\n        }\n        var parser = new _m3u8Parser2['default'].Parser();\n        parser.push(req.responseText);\n        parser.end();\n        _this5.state = 'HAVE_MASTER';\n        _this5.srcUrl = _this5.resolveManifestRedirect(_this5.srcUrl, req);\n        parser.manifest.uri = _this5.srcUrl;\n\n        // loaded a master playlist\n        if (parser.manifest.playlists) {\n          _this5.master = parser.manifest;\n          setupMediaPlaylists(_this5.master);\n          resolveMediaGroupUris(_this5.master);\n          _this5.trigger('loadedplaylist');\n          if (!_this5.request) {\n            // no media playlist was specifically selected so start\n            // from the first listed one\n            _this5.media(parser.manifest.playlists[0]);\n          }\n          return;\n        }\n\n        // loaded a media playlist\n        // infer a master playlist if none was previously requested\n        _this5.master = {\n          mediaGroups: {\n            'AUDIO': {},\n            'VIDEO': {},\n            'CLOSED-CAPTIONS': {},\n            'SUBTITLES': {}\n          },\n          uri: _globalWindow2['default'].location.href,\n          playlists: [{\n            uri: _this5.srcUrl,\n            resolvedUri: _this5.srcUrl,\n            // m3u8-parser does not attach an attributes property to media playlists so make\n            // sure that the property is attached to avoid undefined reference errors\n            attributes: {}\n          }]\n        };\n        _this5.master.playlists[_this5.srcUrl] = _this5.master.playlists[0];\n        _this5.haveMetadata(req, _this5.srcUrl);\n        return _this5.trigger('loadedmetadata');\n      });\n    }\n  }]);\n  return PlaylistLoader;\n}(_videoJs.EventTarget);\nexports['default'] = PlaylistLoader;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x","_x2","_x3","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_resolveUrl","require","_resolveUrl2","_videoJs","_m3u8Parser","_m3u8Parser2","_globalWindow","_globalWindow2","updateSegments","original","update","offset","result","slice","Math","min","mergeOptions","resolveSegmentUris","segment","baseUri","resolvedUri","uri","map","updateMaster","master","media","playlist","playlists","filter","p","segments","mediaSequence","mergedPlaylist","forEach","setupMediaPlaylists","attributes","log","warn","resolveMediaGroupUris","mediaType","groupKey","mediaGroups","labelKey","mediaProperties","refreshDelay","lastSegment","delay","duration","targetDuration","PlaylistLoader","_EventTarget","srcUrl","hls","options","_this","hls_","withCredentials","handleManifestRedirects","Error","state","on","request","xhr","error","req","playlistRequestError","haveMetadata","url","startingState","status","message","responseText","code","trigger","_this2","parser","Parser","push","end","manifest","media_","endList","clearTimeout","mediaUpdateTimeout","setTimeout","dispose","stopRequest","oldRequest","onreadystatechange","abort","_this3","mediaChange","resolveManifestRedirect","responseURL","pause","started","load","isFinalRendition","_this4","start","_this5","location","href","EventTarget"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/playlist-loader.js"],"sourcesContent":["/**\n * @module playlist-loader\n *\n * @file A state machine that manages the loading, caching, and updating of\n * M3U8 playlists.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _resolveUrl = require('./resolve-url');\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nvar _videoJs = require('video.js');\n\nvar _m3u8Parser = require('m3u8-parser');\n\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * Returns a new array of segments that is the result of merging\n * properties from an older list of segments onto an updated\n * list. No properties on the updated playlist will be overridden.\n *\n * @param {Array} original the outdated list of segments\n * @param {Array} update the updated list of segments\n * @param {Number=} offset the index of the first update\n * segment in the original segment list. For non-live playlists,\n * this should always be zero and does not need to be\n * specified. For live playlists, it should be the difference\n * between the media sequence numbers in the original and updated\n * playlists.\n * @return a list of merged segment objects\n */\nvar updateSegments = function updateSegments(original, update, offset) {\n  var result = update.slice();\n\n  offset = offset || 0;\n  var length = Math.min(original.length, update.length + offset);\n\n  for (var i = offset; i < length; i++) {\n    result[i - offset] = (0, _videoJs.mergeOptions)(original[i], result[i - offset]);\n  }\n  return result;\n};\n\nexports.updateSegments = updateSegments;\nvar resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\n  if (!segment.resolvedUri) {\n    segment.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.uri);\n  }\n  if (segment.key && !segment.key.resolvedUri) {\n    segment.key.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.key.uri);\n  }\n  if (segment.map && !segment.map.resolvedUri) {\n    segment.map.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.map.uri);\n  }\n};\n\nexports.resolveSegmentUris = resolveSegmentUris;\n/**\n  * Returns a new master playlist that is the result of merging an\n  * updated media playlist into the original version. If the\n  * updated media playlist does not match any of the playlist\n  * entries in the original master playlist, null is returned.\n  *\n  * @param {Object} master a parsed master M3U8 object\n  * @param {Object} media a parsed media M3U8 object\n  * @return {Object} a new object that represents the original\n  * master playlist with the updated media playlist merged in, or\n  * null if the merge produced no change.\n  */\nvar updateMaster = function updateMaster(master, media) {\n  var result = (0, _videoJs.mergeOptions)(master, {});\n  var playlist = result.playlists.filter(function (p) {\n    return p.uri === media.uri;\n  })[0];\n\n  if (!playlist) {\n    return null;\n  }\n\n  // consider the playlist unchanged if the number of segments is equal and the media\n  // sequence number is unchanged\n  if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\n    return null;\n  }\n\n  var mergedPlaylist = (0, _videoJs.mergeOptions)(playlist, media);\n\n  // if the update could overlap existing segment information, merge the two segment lists\n  if (playlist.segments) {\n    mergedPlaylist.segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\n  }\n\n  // resolve any segment URIs to prevent us from having to do it later\n  mergedPlaylist.segments.forEach(function (segment) {\n    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n  });\n\n  // TODO Right now in the playlists array there are two references to each playlist, one\n  // that is referenced by index, and one by URI. The index reference may no longer be\n  // necessary.\n  for (var i = 0; i < result.playlists.length; i++) {\n    if (result.playlists[i].uri === media.uri) {\n      result.playlists[i] = mergedPlaylist;\n    }\n  }\n  result.playlists[media.uri] = mergedPlaylist;\n\n  return result;\n};\n\nexports.updateMaster = updateMaster;\nvar setupMediaPlaylists = function setupMediaPlaylists(master) {\n  // setup by-URI lookups and resolve media playlist URIs\n  var i = master.playlists.length;\n\n  while (i--) {\n    var playlist = master.playlists[i];\n\n    master.playlists[playlist.uri] = playlist;\n    playlist.resolvedUri = (0, _resolveUrl2['default'])(master.uri, playlist.uri);\n\n    if (!playlist.attributes) {\n      // Although the spec states an #EXT-X-STREAM-INF tag MUST have a\n      // BANDWIDTH attribute, we can play the stream without it. This means a poorly\n      // formatted master playlist may not have an attribute list. An attributes\n      // property is added here to prevent undefined references when we encounter\n      // this scenario.\n      playlist.attributes = {};\n\n      _videoJs.log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n    }\n  }\n};\n\nexports.setupMediaPlaylists = setupMediaPlaylists;\nvar resolveMediaGroupUris = function resolveMediaGroupUris(master) {\n  ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n\n        if (mediaProperties.uri) {\n          mediaProperties.resolvedUri = (0, _resolveUrl2['default'])(master.uri, mediaProperties.uri);\n        }\n      }\n    }\n  });\n};\n\nexports.resolveMediaGroupUris = resolveMediaGroupUris;\n/**\n * Calculates the time to wait before refreshing a live playlist\n *\n * @param {Object} media\n *        The current media\n * @param {Boolean} update\n *        True if there were any updates from the last refresh, false otherwise\n * @return {Number}\n *         The time in ms to wait before refreshing the live playlist\n */\nvar refreshDelay = function refreshDelay(media, update) {\n  var lastSegment = media.segments[media.segments.length - 1];\n  var delay = undefined;\n\n  if (update && lastSegment && lastSegment.duration) {\n    delay = lastSegment.duration * 1000;\n  } else {\n    // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n    delay = (media.targetDuration || 10) * 500;\n  }\n  return delay;\n};\n\nexports.refreshDelay = refreshDelay;\n/**\n * Load a playlist from a remote location\n *\n * @class PlaylistLoader\n * @extends videojs.EventTarget\n * @param {String} srcUrl the url to start with\n * @param {Object} hls\n * @param {Object} [options]\n * @param {Boolean} [options.withCredentials=false] the withCredentials xhr option\n * @param {Boolean} [options.handleManifestRedirects=false] whether to follow redirects, when any\n *        playlist request was redirected\n */\n\nvar PlaylistLoader = (function (_EventTarget) {\n  _inherits(PlaylistLoader, _EventTarget);\n\n  function PlaylistLoader(srcUrl, hls, options) {\n    var _this = this;\n\n    _classCallCheck(this, PlaylistLoader);\n\n    _get(Object.getPrototypeOf(PlaylistLoader.prototype), 'constructor', this).call(this);\n\n    options = options || {};\n\n    this.srcUrl = srcUrl;\n    this.hls_ = hls;\n    this.withCredentials = !!options.withCredentials;\n    this.handleManifestRedirects = !!options.handleManifestRedirects;\n\n    if (!this.srcUrl) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    // initialize the loader state\n    this.state = 'HAVE_NOTHING';\n\n    // live playlist staleness timeout\n    this.on('mediaupdatetimeout', function () {\n      if (_this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n\n      _this.state = 'HAVE_CURRENT_METADATA';\n\n      _this.request = _this.hls_.xhr({\n        uri: (0, _resolveUrl2['default'])(_this.master.uri, _this.media().uri),\n        withCredentials: _this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this.request) {\n          return;\n        }\n\n        if (error) {\n          return _this.playlistRequestError(_this.request, _this.media().uri, 'HAVE_METADATA');\n        }\n\n        _this.haveMetadata(_this.request, _this.media().uri);\n      });\n    });\n  }\n\n  _createClass(PlaylistLoader, [{\n    key: 'playlistRequestError',\n    value: function playlistRequestError(xhr, url, startingState) {\n      // any in-flight request is now finished\n      this.request = null;\n\n      if (startingState) {\n        this.state = startingState;\n      }\n\n      this.error = {\n        playlist: this.master.playlists[url],\n        status: xhr.status,\n        message: 'HLS playlist request error at URL: ' + url,\n        responseText: xhr.responseText,\n        code: xhr.status >= 500 ? 4 : 2\n      };\n\n      this.trigger('error');\n    }\n\n    // update the playlist loader's state in response to a new or\n    // updated playlist.\n  }, {\n    key: 'haveMetadata',\n    value: function haveMetadata(xhr, url) {\n      var _this2 = this;\n\n      // any in-flight request is now finished\n      this.request = null;\n      this.state = 'HAVE_METADATA';\n\n      var parser = new _m3u8Parser2['default'].Parser();\n\n      parser.push(xhr.responseText);\n      parser.end();\n      parser.manifest.uri = url;\n      // m3u8-parser does not attach an attributes property to media playlists so make\n      // sure that the property is attached to avoid undefined reference errors\n      parser.manifest.attributes = parser.manifest.attributes || {};\n\n      // merge this playlist into the master\n      var update = updateMaster(this.master, parser.manifest);\n\n      this.targetDuration = parser.manifest.targetDuration;\n\n      if (update) {\n        this.master = update;\n        this.media_ = this.master.playlists[parser.manifest.uri];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n\n      // refresh live playlists after a target duration passes\n      if (!this.media().endList) {\n        _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          _this2.trigger('mediaupdatetimeout');\n        }, refreshDelay(this.media(), !!update));\n      }\n\n      this.trigger('loadedplaylist');\n    }\n\n    /**\n     * Abort any outstanding work and clean up.\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n    }\n  }, {\n    key: 'stopRequest',\n    value: function stopRequest() {\n      if (this.request) {\n        var oldRequest = this.request;\n\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n\n    /**\n     * When called without any arguments, returns the currently\n     * active media playlist. When called with a single argument,\n     * triggers the playlist loader to asynchronously switch to the\n     * specified media playlist. Calling this method while the\n     * loader is in the HAVE_NOTHING causes an error to be emitted\n     * but otherwise has no effect.\n     *\n     * @param {Object=} playlist the parsed media playlist\n     * object to switch to\n     * @return {Playlist} the current loaded media\n     */\n  }, {\n    key: 'media',\n    value: function media(playlist) {\n      var _this3 = this;\n\n      // getter\n      if (!playlist) {\n        return this.media_;\n      }\n\n      // setter\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n\n      var startingState = this.state;\n\n      // find the playlist object if the target playlist has been\n      // specified by URI\n      if (typeof playlist === 'string') {\n        if (!this.master.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.master.playlists[playlist];\n      }\n\n      var mediaChange = !this.media_ || playlist.uri !== this.media_.uri;\n\n      // switch to fully loaded playlists immediately\n      if (this.master.playlists[playlist.uri].endList) {\n        // abort outstanding playlist requests\n        if (this.request) {\n          this.request.onreadystatechange = null;\n          this.request.abort();\n          this.request = null;\n        }\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist;\n\n        // trigger media change if the active media has been updated\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          this.trigger('mediachange');\n        }\n        return;\n      }\n\n      // switching to the active playlist is a no-op\n      if (!mediaChange) {\n        return;\n      }\n\n      this.state = 'SWITCHING_MEDIA';\n\n      // there is already an outstanding playlist request\n      if (this.request) {\n        if (playlist.resolvedUri === this.request.url) {\n          // requesting to switch to the same playlist multiple times\n          // has no effect after the first\n          return;\n        }\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      }\n\n      // request the new playlist\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n\n      this.request = this.hls_.xhr({\n        uri: playlist.resolvedUri,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this3.request) {\n          return;\n        }\n\n        playlist.resolvedUri = _this3.resolveManifestRedirect(playlist.resolvedUri, req);\n\n        if (error) {\n          return _this3.playlistRequestError(_this3.request, playlist.uri, startingState);\n        }\n\n        _this3.haveMetadata(req, playlist.uri);\n\n        // fire loadedmetadata the first time a media playlist is loaded\n        if (startingState === 'HAVE_MASTER') {\n          _this3.trigger('loadedmetadata');\n        } else {\n          _this3.trigger('mediachange');\n        }\n      });\n    }\n\n    /**\n     * Checks whether xhr request was redirected and returns correct url depending\n     * on `handleManifestRedirects` option\n     *\n     * @api private\n     *\n     * @param  {String} url - an url being requested\n     * @param  {XMLHttpRequest} req - xhr request result\n     *\n     * @return {String}\n     */\n  }, {\n    key: 'resolveManifestRedirect',\n    value: function resolveManifestRedirect(url, req) {\n      if (this.handleManifestRedirects && req.responseURL && url !== req.responseURL) {\n        return req.responseURL;\n      }\n\n      return url;\n    }\n\n    /**\n     * pause loading of the playlist\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n      // Need to restore state now that no activity is happening\n      if (this.state === 'SWITCHING_MEDIA') {\n        // if the loader was in the process of switching media, it should either return to\n        // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\n        // playlist yet. This is determined by the existence of loader.media_\n        if (this.media_) {\n          this.state = 'HAVE_METADATA';\n        } else {\n          this.state = 'HAVE_MASTER';\n        }\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\n        this.state = 'HAVE_METADATA';\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'load',\n    value: function load(isFinalRendition) {\n      var _this4 = this;\n\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n\n      var media = this.media();\n\n      if (isFinalRendition) {\n        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          return _this4.load();\n        }, delay);\n        return;\n      }\n\n      if (!this.started) {\n        this.start();\n        return;\n      }\n\n      if (media && !media.endList) {\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this5 = this;\n\n      this.started = true;\n\n      // request the specified URL\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this5.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this5.request = null;\n\n        if (error) {\n          _this5.error = {\n            status: req.status,\n            message: 'HLS playlist request error at URL: ' + _this5.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this5.state === 'HAVE_NOTHING') {\n            _this5.started = false;\n          }\n          return _this5.trigger('error');\n        }\n\n        var parser = new _m3u8Parser2['default'].Parser();\n\n        parser.push(req.responseText);\n        parser.end();\n\n        _this5.state = 'HAVE_MASTER';\n\n        _this5.srcUrl = _this5.resolveManifestRedirect(_this5.srcUrl, req);\n\n        parser.manifest.uri = _this5.srcUrl;\n\n        // loaded a master playlist\n        if (parser.manifest.playlists) {\n          _this5.master = parser.manifest;\n\n          setupMediaPlaylists(_this5.master);\n          resolveMediaGroupUris(_this5.master);\n\n          _this5.trigger('loadedplaylist');\n          if (!_this5.request) {\n            // no media playlist was specifically selected so start\n            // from the first listed one\n            _this5.media(parser.manifest.playlists[0]);\n          }\n          return;\n        }\n\n        // loaded a media playlist\n        // infer a master playlist if none was previously requested\n        _this5.master = {\n          mediaGroups: {\n            'AUDIO': {},\n            'VIDEO': {},\n            'CLOSED-CAPTIONS': {},\n            'SUBTITLES': {}\n          },\n          uri: _globalWindow2['default'].location.href,\n          playlists: [{\n            uri: _this5.srcUrl,\n            resolvedUri: _this5.srcUrl,\n            // m3u8-parser does not attach an attributes property to media playlists so make\n            // sure that the property is attached to avoid undefined reference errors\n            attributes: {}\n          }]\n        };\n        _this5.master.playlists[_this5.srcUrl] = _this5.master.playlists[0];\n        _this5.haveMetadata(req, _this5.srcUrl);\n        return _this5.trigger('loadedmetadata');\n      });\n    }\n  }]);\n\n  return PlaylistLoader;\n})(_videoJs.EventTarget);\n\nexports['default'] = PlaylistLoader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}