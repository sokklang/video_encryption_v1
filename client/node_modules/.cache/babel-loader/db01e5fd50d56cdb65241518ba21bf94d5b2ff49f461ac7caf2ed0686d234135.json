{"ast":null,"code":"/**\n * @file segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x4, _x5, _x6) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x4,\n      property = _x5,\n      receiver = _x6;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x4 = parent;\n        _x5 = property;\n        _x6 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _playlist = require('./playlist');\nvar _playlist2 = _interopRequireDefault(_playlist);\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _sourceUpdater = require('./source-updater');\nvar _sourceUpdater2 = _interopRequireDefault(_sourceUpdater);\nvar _config = require('./config');\nvar _config2 = _interopRequireDefault(_config);\nvar _globalWindow = require('global/window');\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\nvar _binUtils = require('./bin-utils');\nvar _mediaSegmentRequest = require('./media-segment-request');\nvar _ranges = require('./ranges');\nvar _playlistSelectors = require('./playlist-selectors');\n\n// in ms\nvar CHECK_BUFFER_DELAY = 500;\n\n/**\n * Determines if we should call endOfStream on the media source based\n * on the state of the buffer or if appened segment was the final\n * segment in the playlist.\n *\n * @param {Object} playlist a media playlist object\n * @param {Object} mediaSource the MediaSource object\n * @param {Number} segmentIndex the index of segment we last appended\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\n */\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex) {\n  if (!playlist || !mediaSource) {\n    return false;\n  }\n  var segments = playlist.segments;\n\n  // determine a few boolean values to help make the branch below easier\n  // to read\n  var appendedLastSegment = segmentIndex === segments.length;\n\n  // if we've buffered to the end of the video, we need to call endOfStream\n  // so that MediaSources can trigger the `ended` event when it runs out of\n  // buffered data instead of waiting for me\n  return playlist.endList && mediaSource.readyState === 'open' && appendedLastSegment;\n};\nvar finite = function finite(num) {\n  return typeof num === 'number' && isFinite(num);\n};\nvar illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, newSegmentMedia) {\n  // Although these checks should most likely cover non 'main' types, for now it narrows\n  // the scope of our checks.\n  if (loaderType !== 'main' || !startingMedia || !newSegmentMedia) {\n    return null;\n  }\n  if (!newSegmentMedia.containsAudio && !newSegmentMedia.containsVideo) {\n    return 'Neither audio nor video found in segment.';\n  }\n  if (startingMedia.containsVideo && !newSegmentMedia.containsVideo) {\n    return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n  if (!startingMedia.containsVideo && newSegmentMedia.containsVideo) {\n    return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n  return null;\n};\nexports.illegalMediaSwitch = illegalMediaSwitch;\n/**\n * Calculates a time value that is safe to remove from the back buffer without interupting\n * playback.\n *\n * @param {TimeRange} seekable\n *        The current seekable range\n * @param {Number} currentTime\n *        The current time of the player\n * @param {Number} targetDuration\n *        The target duration of the current playlist\n * @return {Number}\n *         Time that is safe to remove from the back buffer without interupting playback\n */\nvar safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {\n  var removeToTime = undefined;\n  if (seekable.length && seekable.start(0) > 0 && seekable.start(0) < currentTime) {\n    // If we have a seekable range use that as the limit for what can be removed safely\n    removeToTime = seekable.start(0);\n  } else {\n    // otherwise remove anything older than 30 seconds before the current play head\n    removeToTime = currentTime - 30;\n  }\n\n  // Don't allow removing from the buffer within target duration of current time\n  // to avoid the possibility of removing the GOP currently being played which could\n  // cause playback stalls.\n  return Math.min(removeToTime, currentTime - targetDuration);\n};\nexports.safeBackBufferTrimTime = safeBackBufferTrimTime;\n/**\n * An object that manages segment loading and appending.\n *\n * @class SegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar SegmentLoader = function (_videojs$EventTarget) {\n  _inherits(SegmentLoader, _videojs$EventTarget);\n  function SegmentLoader(settings) {\n    var _this = this;\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    _classCallCheck(this, SegmentLoader);\n    _get(Object.getPrototypeOf(SegmentLoader.prototype), 'constructor', this).call(this);\n    // check pre-conditions\n    if (!settings) {\n      throw new TypeError('Initialization settings are required');\n    }\n    if (typeof settings.currentTime !== 'function') {\n      throw new TypeError('No currentTime getter specified');\n    }\n    if (!settings.mediaSource) {\n      throw new TypeError('No MediaSource specified');\n    }\n    // public properties\n    this.state = 'INIT';\n    this.bandwidth = settings.bandwidth;\n    this.throughput = {\n      rate: 0,\n      count: 0\n    };\n    this.roundTrip = NaN;\n    this.resetStats_();\n    this.mediaIndex = null;\n\n    // private settings\n    this.hasPlayed_ = settings.hasPlayed;\n    this.currentTime_ = settings.currentTime;\n    this.seekable_ = settings.seekable;\n    this.seeking_ = settings.seeking;\n    this.duration_ = settings.duration;\n    this.mediaSource_ = settings.mediaSource;\n    this.hls_ = settings.hls;\n    this.loaderType_ = settings.loaderType;\n    this.startingMedia_ = void 0;\n    this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n    this.goalBufferLength_ = settings.goalBufferLength;\n\n    // private instance variables\n    this.checkBufferTimeout_ = null;\n    this.error_ = void 0;\n    this.currentTimeline_ = -1;\n    this.pendingSegment_ = null;\n    this.mimeType_ = null;\n    this.sourceUpdater_ = null;\n    this.xhrOptions_ = null;\n\n    // Fragmented mp4 playback\n    this.activeInitSegmentId_ = null;\n    this.initSegments_ = {};\n    this.decrypter_ = settings.decrypter;\n\n    // Manages the tracking and generation of sync-points, mappings\n    // between a time in the display time and a segment index within\n    // a playlist\n    this.syncController_ = settings.syncController;\n    this.syncPoint_ = {\n      segmentIndex: 0,\n      time: 0\n    };\n    this.syncController_.on('syncinfoupdate', function () {\n      return _this.trigger('syncinfoupdate');\n    });\n    this.mediaSource_.addEventListener('sourceopen', function () {\n      return _this.ended_ = false;\n    });\n\n    // ...for determining the fetch location\n    this.fetchAtBuffer_ = false;\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'segment-loader', this.loaderType_, '->');\n    }\n  }\n\n  /**\n   * reset all of our media stats\n   *\n   * @private\n   */\n\n  _createClass(SegmentLoader, [{\n    key: 'resetStats_',\n    value: function resetStats_() {\n      this.mediaBytesTransferred = 0;\n      this.mediaRequests = 0;\n      this.mediaRequestsAborted = 0;\n      this.mediaRequestsTimedout = 0;\n      this.mediaRequestsErrored = 0;\n      this.mediaTransferDuration = 0;\n      this.mediaSecondsLoaded = 0;\n    }\n\n    /**\n     * dispose of the SegmentLoader and reset to the default state\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.state = 'DISPOSED';\n      this.pause();\n      this.abort_();\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.dispose();\n      }\n      this.resetStats_();\n    }\n\n    /**\n     * abort anything that is currently doing on with the SegmentLoader\n     * and reset to a default state\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.state !== 'WAITING') {\n        if (this.pendingSegment_) {\n          this.pendingSegment_ = null;\n        }\n        return;\n      }\n      this.abort_();\n\n      // We aborted the requests we were waiting on, so reset the loader's state to READY\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n      // when the request is aborted. This will prevent the loader from being stuck in the\n      // WAITING state indefinitely.\n      this.state = 'READY';\n\n      // don't wait for buffer check timeouts to begin fetching the\n      // next segment\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * abort all pending xhr requests and null any pending segements\n     *\n     * @private\n     */\n  }, {\n    key: 'abort_',\n    value: function abort_() {\n      if (this.pendingSegment_) {\n        this.pendingSegment_.abortRequests();\n      }\n\n      // clear out the segment being processed\n      this.pendingSegment_ = null;\n    }\n\n    /**\n     * set an error on the segment loader and null out any pending segements\n     *\n     * @param {Error} error the error to set on the SegmentLoader\n     * @return {Error} the error that was set or that is currently set\n     */\n  }, {\n    key: 'error',\n    value: function error(_error) {\n      if (typeof _error !== 'undefined') {\n        this.error_ = _error;\n      }\n      this.pendingSegment_ = null;\n      return this.error_;\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      this.ended_ = true;\n      this.pause();\n      this.trigger('ended');\n    }\n\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n  }, {\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.sourceUpdater_) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n      return this.sourceUpdater_.buffered();\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      if (!map) {\n        return null;\n      }\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n      if (set && !storedMap && map.bytes) {\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: map.bytes\n        };\n      }\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && (\n      // the source updater is created when init_ is called, so either having a\n      // source updater or being in the INIT state with a mimeType is enough\n      // to say we have all the needed configuration to start loading.\n      this.sourceUpdater_ || this.mimeType_ && this.state === 'INIT') && !this.paused();\n    }\n\n    /**\n     * load a playlist and start to fill the buffer\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      // un-pause\n      this.monitorBuffer_();\n\n      // if we don't have a playlist yet, keep waiting for one to be\n      // specified\n      if (!this.playlist_) {\n        return;\n      }\n\n      // not sure if this is the best place for this\n      this.syncController_.setDateTimeMapping(this.playlist_);\n\n      // if all the configuration is ready, initialize and begin loading\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      // if we're in the middle of processing a segment already, don't\n      // kick off an additional segment request\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n        return;\n      }\n      this.state = 'READY';\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.sourceUpdater_ = new _sourceUpdater2['default'](this.mediaSource_, this.mimeType_);\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * set a playlist on the segment loader\n     *\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\n     */\n  }, {\n    key: 'playlist',\n    value: function playlist(newPlaylist) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n      if (!newPlaylist) {\n        return;\n      }\n      var oldPlaylist = this.playlist_;\n      var segmentInfo = this.pendingSegment_;\n      this.playlist_ = newPlaylist;\n      this.xhrOptions_ = options;\n\n      // when we haven't started playing yet, the start of a live playlist\n      // is always our zero-time so force a sync update each time the playlist\n      // is refreshed from the server\n      if (!this.hasPlayed_()) {\n        newPlaylist.syncInfo = {\n          mediaSequence: newPlaylist.mediaSequence,\n          time: 0\n        };\n      }\n\n      // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n      // in LIVE, we always want to update with new playlists (including refreshes)\n      this.trigger('syncinfoupdate');\n\n      // if we were unpaused but waiting for a playlist, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n        if (this.mediaIndex !== null) {\n          // we must \"resync\" the segment loader when we switch renditions and\n          // the segment loader is already synced to the previous rendition\n          this.resyncLoader();\n        }\n\n        // the rest of this function depends on `oldPlaylist` being defined\n        return;\n      }\n\n      // we reloaded the same playlist so we are in a live scenario\n      // and we will likely need to adjust the mediaIndex\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n      this.logger_('mediaSequenceDiff', mediaSequenceDiff);\n\n      // update the mediaIndex on the SegmentLoader\n      // this is important because we can abort a request and this value must be\n      // equal to the last appended mediaIndex\n      if (this.mediaIndex !== null) {\n        this.mediaIndex -= mediaSequenceDiff;\n      }\n\n      // update the mediaIndex on the SegmentInfo object\n      // this is important because we will update this.mediaIndex with this value\n      // in `handleUpdateEnd_` after the segment has been successfully appended\n      if (segmentInfo) {\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\n\n        // we need to update the referenced segment so that timing information is\n        // saved for the new playlist's segment, however, if the segment fell off the\n        // playlist, we can leave the old reference and just lose the timing info\n        if (segmentInfo.mediaIndex >= 0) {\n          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n        }\n      }\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n    }\n\n    /**\n     * Prevent the loader from fetching additional segments. If there\n     * is a segment request outstanding, it will finish processing\n     * before the loader halts. A segment loader can be unpaused by\n     * calling load().\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n        this.checkBufferTimeout_ = null;\n      }\n    }\n\n    /**\n     * Returns whether the segment loader is fetching additional\n     * segments when given the opportunity. This property can be\n     * modified through calls to pause() and load().\n     */\n  }, {\n    key: 'paused',\n    value: function paused() {\n      return this.checkBufferTimeout_ === null;\n    }\n\n    /**\n     * create/set the following mimetype on the SourceBuffer through a\n     * SourceUpdater\n     *\n     * @param {String} mimeType the mime type string to use\n     */\n  }, {\n    key: 'mimeType',\n    value: function mimeType(_mimeType) {\n      if (this.mimeType_) {\n        return;\n      }\n      this.mimeType_ = _mimeType;\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n    }\n\n    /**\n     * Delete all the buffered data and reset the SegmentLoader\n     */\n  }, {\n    key: 'resetEverything',\n    value: function resetEverything() {\n      this.ended_ = false;\n      this.resetLoader();\n      this.remove(0, this.duration_());\n      this.trigger('reseteverything');\n    }\n\n    /**\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\n     * of starting at the end of the buffer\n     *\n     * Useful for fast quality changes\n     */\n  }, {\n    key: 'resetLoader',\n    value: function resetLoader() {\n      this.fetchAtBuffer_ = false;\n      this.resyncLoader();\n    }\n\n    /**\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\n     * before returning to the simple walk-forward method\n     */\n  }, {\n    key: 'resyncLoader',\n    value: function resyncLoader() {\n      this.mediaIndex = null;\n      this.syncPoint_ = null;\n      this.abort();\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.remove(start, end);\n      }\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n    }\n\n    /**\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBuffer_',\n    value: function monitorBuffer_() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), 1);\n    }\n\n    /**\n     * As long as the SegmentLoader is in the READY state, periodically\n     * invoke fillBuffer_().\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBufferTick_',\n    value: function monitorBufferTick_() {\n      if (this.state === 'READY') {\n        this.fillBuffer_();\n      }\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      if (this.sourceUpdater_.updating()) {\n        return;\n      }\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n      if (!segmentInfo) {\n        return;\n      }\n      var isEndOfStream = detectEndOfStream(this.playlist_, this.mediaSource_, segmentInfo.mediaIndex);\n      if (isEndOfStream) {\n        this.endOfStream();\n        return;\n      }\n      if (segmentInfo.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\n        return;\n      }\n\n      // We will need to change timestampOffset of the sourceBuffer if either of\n      // the following conditions are true:\n      // - The segment.timeline !== this.currentTimeline\n      //   (we are crossing a discontinuity somehow)\n      // - The \"timestampOffset\" for the start of this segment is less than\n      //   the currently set timestampOffset\n      if (segmentInfo.timeline !== this.currentTimeline_ || segmentInfo.startOfSegment !== null && segmentInfo.startOfSegment < this.sourceUpdater_.timestampOffset()) {\n        this.syncController_.reset();\n        segmentInfo.timestampOffset = segmentInfo.startOfSegment;\n      }\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Determines what segment request should be made, given current playback\n     * state.\n     *\n     * @param {TimeRanges} buffered - the state of the buffer\n     * @param {Object} playlist - the playlist object to fetch segments from\n     * @param {Number} mediaIndex - the previous mediaIndex fetched or null\n     * @param {Boolean} hasPlayed - a flag indicating whether we have played or not\n     * @param {Number} currentTime - the playback position in seconds\n     * @param {Object} syncPoint - a segment info object that describes the\n     * @returns {Object} a segment request object that describes the segment to load\n     */\n  }, {\n    key: 'checkBuffer_',\n    value: function checkBuffer_(buffered, playlist, mediaIndex, hasPlayed, currentTime, syncPoint) {\n      var lastBufferedEnd = 0;\n      var startOfSegment = undefined;\n      if (buffered.length) {\n        lastBufferedEnd = buffered.end(buffered.length - 1);\n      }\n      var bufferedTime = Math.max(0, lastBufferedEnd - currentTime);\n      if (!playlist.segments.length) {\n        return null;\n      }\n\n      // if there is plenty of content buffered, and the video has\n      // been played before relax for awhile\n      if (bufferedTime >= this.goalBufferLength_()) {\n        return null;\n      }\n\n      // if the video has not yet played once, and we already have\n      // one segment downloaded do nothing\n      if (!hasPlayed && bufferedTime >= 1) {\n        return null;\n      }\n      this.logger_('checkBuffer_', 'mediaIndex:', mediaIndex, 'hasPlayed:', hasPlayed, 'currentTime:', currentTime, 'syncPoint:', syncPoint, 'fetchAtBuffer:', this.fetchAtBuffer_, 'bufferedTime:', bufferedTime);\n\n      // When the syncPoint is null, there is no way of determining a good\n      // conservative segment index to fetch from\n      // The best thing to do here is to get the kind of sync-point data by\n      // making a request\n      if (syncPoint === null) {\n        mediaIndex = this.getSyncSegmentCandidate_(playlist);\n        this.logger_('getSync', 'mediaIndex:', mediaIndex);\n        return this.generateSegmentInfo_(playlist, mediaIndex, null, true);\n      }\n\n      // Under normal playback conditions fetching is a simple walk forward\n      if (mediaIndex !== null) {\n        this.logger_('walkForward', 'mediaIndex:', mediaIndex + 1);\n        var segment = playlist.segments[mediaIndex];\n        if (segment && segment.end) {\n          startOfSegment = segment.end;\n        } else {\n          startOfSegment = lastBufferedEnd;\n        }\n        return this.generateSegmentInfo_(playlist, mediaIndex + 1, startOfSegment, false);\n      }\n\n      // There is a sync-point but the lack of a mediaIndex indicates that\n      // we need to make a good conservative guess about which segment to\n      // fetch\n      if (this.fetchAtBuffer_) {\n        // Find the segment containing the end of the buffer\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, lastBufferedEnd, syncPoint.segmentIndex, syncPoint.time);\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      } else {\n        // Find the segment containing currentTime\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, currentTime, syncPoint.segmentIndex, syncPoint.time);\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      }\n      this.logger_('getMediaIndexForTime', 'mediaIndex:', mediaIndex, 'startOfSegment:', startOfSegment);\n      return this.generateSegmentInfo_(playlist, mediaIndex, startOfSegment, false);\n    }\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Object} playlist - the playlist object to look for a\n     * @returns {Number} An index of a segment from the playlist to load\n     */\n  }, {\n    key: 'getSyncSegmentCandidate_',\n    value: function getSyncSegmentCandidate_(playlist) {\n      var _this2 = this;\n      if (this.currentTimeline_ === -1) {\n        return 0;\n      }\n      var segmentIndexArray = playlist.segments.map(function (s, i) {\n        return {\n          timeline: s.timeline,\n          segmentIndex: i\n        };\n      }).filter(function (s) {\n        return s.timeline === _this2.currentTimeline_;\n      });\n      if (segmentIndexArray.length) {\n        return segmentIndexArray[Math.min(segmentIndexArray.length - 1, 1)].segmentIndex;\n      }\n      return Math.max(playlist.segments.length - 1, 0);\n    }\n  }, {\n    key: 'generateSegmentInfo_',\n    value: function generateSegmentInfo_(playlist, mediaIndex, startOfSegment, isSyncRequest) {\n      if (mediaIndex < 0 || mediaIndex >= playlist.segments.length) {\n        return null;\n      }\n      var segment = playlist.segments[mediaIndex];\n      return {\n        requestId: 'segment-loader-' + Math.random(),\n        // resolve the segment URL relative to the playlist\n        uri: segment.resolvedUri,\n        // the segment's mediaIndex at the time it was requested\n        mediaIndex: mediaIndex,\n        // whether or not to update the SegmentLoader's state with this\n        // segment's mediaIndex\n        isSyncRequest: isSyncRequest,\n        startOfSegment: startOfSegment,\n        // the segment's playlist\n        playlist: playlist,\n        // unencrypted bytes of the segment\n        bytes: null,\n        // when a key is defined for this segment, the encrypted bytes\n        encryptedBytes: null,\n        // The target timestampOffset for this segment when we append it\n        // to the source buffer\n        timestampOffset: null,\n        // The timeline that the segment is in\n        timeline: segment.timeline,\n        // The expected duration of the segment in seconds\n        duration: segment.duration,\n        // retain the segment in case the playlist updates while doing an async process\n        segment: segment\n      };\n    }\n\n    /**\n     * Determines if the network has enough bandwidth to complete the current segment\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\n     * updated to trigger a playlist switch.\n     *\n     * @param {Object} stats\n     *        Object containing stats about the request timing and size\n     * @return {Boolean} True if the request was aborted, false otherwise\n     * @private\n     */\n  }, {\n    key: 'abortRequestEarly_',\n    value: function abortRequestEarly_(stats) {\n      if (this.hls_.tech_.paused() ||\n      // Don't abort if the current playlist is on the lowestEnabledRendition\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\n      //       the lowestEnabledRendition.\n      !this.xhrOptions_.timeout ||\n      // Don't abort if we have no bandwidth information to estimate segment sizes\n      !this.playlist_.attributes.BANDWIDTH) {\n        return false;\n      }\n\n      // Wait at least 1 second since the first byte of data has been received before\n      // using the calculated bandwidth from the progress event to allow the bitrate\n      // to stabilize\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n        return false;\n      }\n      var currentTime = this.currentTime_();\n      var measuredBandwidth = stats.bandwidth;\n      var segmentDuration = this.pendingSegment_.duration;\n      var requestTimeRemaining = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);\n\n      // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n      // if we are only left with less than 1 second when the request completes.\n      // A negative timeUntilRebuffering indicates we are already rebuffering\n      var timeUntilRebuffer = (0, _ranges.timeUntilRebuffer)(this.buffered_(), currentTime, this.hls_.tech_.playbackRate()) - 1;\n\n      // Only consider aborting early if the estimated time to finish the download\n      // is larger than the estimated time until the player runs out of forward buffer\n      if (requestTimeRemaining <= timeUntilRebuffer) {\n        return false;\n      }\n      var switchCandidate = (0, _playlistSelectors.minRebufferMaxBandwidthSelector)({\n        master: this.hls_.playlists.master,\n        currentTime: currentTime,\n        bandwidth: measuredBandwidth,\n        duration: this.duration_(),\n        segmentDuration: segmentDuration,\n        timeUntilRebuffer: timeUntilRebuffer,\n        currentTimeline: this.currentTimeline_,\n        syncController: this.syncController_\n      });\n      if (!switchCandidate) {\n        return;\n      }\n      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer;\n      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n      var minimumTimeSaving = 0.5;\n\n      // If we are already rebuffering, increase the amount of variance we add to the\n      // potential round trip time of the new request so that we are not too aggressive\n      // with switching to a playlist that might save us a fraction of a second.\n      if (timeUntilRebuffer <= _ranges.TIME_FUDGE_FACTOR) {\n        minimumTimeSaving = 1;\n      }\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n        return false;\n      }\n\n      // set the bandwidth to that of the desired playlist being sure to scale by\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * _config2['default'].BANDWIDTH_VARIANCE + 1;\n      this.abort();\n      this.trigger('earlyabort');\n      return true;\n    }\n\n    /**\n     * XHR `progress` event handler\n     *\n     * @param {Event}\n     *        The XHR `progress` event\n     * @param {Object} simpleSegment\n     *        A simplified segment object copy\n     * @private\n     */\n  }, {\n    key: 'handleProgress_',\n    value: function handleProgress_(event, simpleSegment) {\n      if (!this.pendingSegment_ || simpleSegment.requestId !== this.pendingSegment_.requestId || this.abortRequestEarly_(simpleSegment.stats)) {\n        return;\n      }\n      this.trigger('progress');\n    }\n\n    /**\n     * load a specific segment from a request into the buffer\n     *\n     * @private\n     */\n  }, {\n    key: 'loadSegment_',\n    value: function loadSegment_(segmentInfo) {\n      this.state = 'WAITING';\n      this.pendingSegment_ = segmentInfo;\n      this.trimBackBuffer_(segmentInfo);\n      segmentInfo.abortRequests = (0, _mediaSegmentRequest.mediaSegmentRequest)(this.hls_.xhr, this.xhrOptions_, this.decrypter_, this.createSimplifiedSegmentObj_(segmentInfo),\n      // progress callback\n      this.handleProgress_.bind(this), this.segmentRequestFinished_.bind(this));\n    }\n\n    /**\n     * trim the back buffer so that we don't have too much data\n     * in the source buffer\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     */\n  }, {\n    key: 'trimBackBuffer_',\n    value: function trimBackBuffer_(segmentInfo) {\n      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);\n\n      // Chrome has a hard limit of 150MB of\n      // buffer and a very conservative \"garbage collector\"\n      // We manually clear out the old buffer to ensure\n      // we don't trigger the QuotaExceeded error\n      // on the source buffer during subsequent appends\n\n      if (removeToTime > 0) {\n        this.remove(0, removeToTime);\n      }\n    }\n\n    /**\n     * created a simplified copy of the segment object with just the\n     * information necessary to perform the XHR and decryption\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     * @returns {Object} a simplified segment object copy\n     */\n  }, {\n    key: 'createSimplifiedSegmentObj_',\n    value: function createSimplifiedSegmentObj_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var simpleSegment = {\n        resolvedUri: segment.resolvedUri,\n        byterange: segment.byterange,\n        requestId: segmentInfo.requestId\n      };\n      if (segment.key) {\n        // if the media sequence is greater than 2^32, the IV will be incorrect\n        // assuming 10s segments, that would be about 1300 years\n        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n        simpleSegment.key = {\n          resolvedUri: segment.key.resolvedUri,\n          iv: iv\n        };\n      }\n      if (segment.map) {\n        simpleSegment.map = this.initSegment(segment.map);\n      }\n      return simpleSegment;\n    }\n\n    /**\n     * Handle the callback from the segmentRequest function and set the\n     * associated SegmentLoader state and errors if necessary\n     *\n     * @private\n     */\n  }, {\n    key: 'segmentRequestFinished_',\n    value: function segmentRequestFinished_(error, simpleSegment) {\n      // every request counts as a media request even if it has been aborted\n      // or canceled due to a timeout\n      this.mediaRequests += 1;\n      if (simpleSegment.stats) {\n        this.mediaBytesTransferred += simpleSegment.stats.bytesReceived;\n        this.mediaTransferDuration += simpleSegment.stats.roundTripTime;\n      }\n\n      // The request was aborted and the SegmentLoader has already been reset\n      if (!this.pendingSegment_) {\n        this.mediaRequestsAborted += 1;\n        return;\n      }\n\n      // the request was aborted and the SegmentLoader has already started\n      // another request. this can happen when the timeout for an aborted\n      // request triggers due to a limitation in the XHR library\n      // do not count this as any sort of request or we risk double-counting\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n        return;\n      }\n\n      // an error occurred from the active pendingSegment_ so reset everything\n      if (error) {\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n\n        // the requests were aborted just record the aborted stat and exit\n        // this is not a true error condition and nothing corrective needs\n        // to be done\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.ABORTED) {\n          this.mediaRequestsAborted += 1;\n          return;\n        }\n        this.pause();\n\n        // the error is really just that at least one of the requests timed-out\n        // set the bandwidth to a very low value and trigger an ABR switch to\n        // take emergency action\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.TIMEOUT) {\n          this.mediaRequestsTimedout += 1;\n          this.bandwidth = 1;\n          this.roundTrip = NaN;\n          this.trigger('bandwidthupdate');\n          return;\n        }\n\n        // if control-flow has arrived here, then the error is real\n        // emit an error event to blacklist the current playlist\n        this.mediaRequestsErrored += 1;\n        this.error(error);\n        this.trigger('error');\n        return;\n      }\n\n      // the response was a success so set any bandwidth stats the request\n      // generated for ABR purposes\n      this.bandwidth = simpleSegment.stats.bandwidth;\n      this.roundTrip = simpleSegment.stats.roundTripTime;\n\n      // if this request included an initialization segment, save that data\n      // to the initSegment cache\n      if (simpleSegment.map) {\n        simpleSegment.map = this.initSegment(simpleSegment.map, true);\n      }\n      this.processSegmentResponse_(simpleSegment);\n    }\n\n    /**\n     * Move any important data from the simplified segment object\n     * back to the real segment object for future phases\n     *\n     * @private\n     */\n  }, {\n    key: 'processSegmentResponse_',\n    value: function processSegmentResponse_(simpleSegment) {\n      var segmentInfo = this.pendingSegment_;\n      segmentInfo.bytes = simpleSegment.bytes;\n      if (simpleSegment.map) {\n        segmentInfo.segment.map.bytes = simpleSegment.map.bytes;\n      }\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n      this.handleSegment_();\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this3 = this;\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        return;\n      }\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var timingInfo = this.syncController_.probeSegmentInfo(segmentInfo);\n\n      // When we have our first timing info, determine what media types this loader is\n      // dealing with. Although we're maintaining extra state, it helps to preserve the\n      // separation of segment loader from the actual source buffers.\n      if (typeof this.startingMedia_ === 'undefined' && timingInfo && (\n      // Guard against cases where we're not getting timing info at all until we are\n      // certain that all streams will provide it.\n      timingInfo.containsAudio || timingInfo.containsVideo)) {\n        this.startingMedia_ = {\n          containsAudio: timingInfo.containsAudio,\n          containsVideo: timingInfo.containsVideo\n        };\n      }\n      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.startingMedia_, timingInfo);\n      if (illegalMediaSwitchError) {\n        this.error({\n          message: illegalMediaSwitchError,\n          blacklistDuration: Infinity\n        });\n        this.trigger('error');\n        return;\n      }\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n      if (segmentInfo.timestampOffset !== null && segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\n        // fired when a timestamp offset is set in HLS (can also identify discontinuities)\n        this.trigger('timestampoffset');\n      }\n      var timelineMapping = this.syncController_.mappingForTimeline(segmentInfo.timeline);\n      if (timelineMapping !== null) {\n        this.trigger({\n          type: 'segmenttimemapping',\n          mapping: timelineMapping\n        });\n      }\n      this.state = 'APPENDING';\n\n      // if the media initialization segment is changing, append it\n      // before the content segment\n      if (segment.map) {\n        (function () {\n          var initId = (0, _binUtils.initSegmentId)(segment.map);\n          if (!_this3.activeInitSegmentId_ || _this3.activeInitSegmentId_ !== initId) {\n            var initSegment = _this3.initSegment(segment.map);\n            _this3.sourceUpdater_.appendBuffer(initSegment.bytes, function () {\n              _this3.activeInitSegmentId_ = initId;\n            });\n          }\n        })();\n      }\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n        this.mediaSecondsLoaded += segment.end - segment.start;\n      } else {\n        this.mediaSecondsLoaded += segment.duration;\n      }\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\n    }\n\n    /**\n     * callback to run when appendBuffer is finished. detects if we are\n     * in a good state to do things with the data we got, or if we need\n     * to wait for more\n     *\n     * @private\n     */\n  }, {\n    key: 'handleUpdateEnd_',\n    value: function handleUpdateEnd_() {\n      this.logger_('handleUpdateEnd_', 'segmentInfo:', this.pendingSegment_);\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        if (!this.paused()) {\n          this.monitorBuffer_();\n        }\n        return;\n      }\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var isWalkingForward = this.mediaIndex !== null;\n      this.pendingSegment_ = null;\n      this.recordThroughput_(segmentInfo);\n      this.addSegmentMetadataCue_(segmentInfo);\n      this.state = 'READY';\n      this.mediaIndex = segmentInfo.mediaIndex;\n      this.fetchAtBuffer_ = true;\n      this.currentTimeline_ = segmentInfo.timeline;\n\n      // We must update the syncinfo to recalculate the seekable range before\n      // the following conditional otherwise it may consider this a bad \"guess\"\n      // and attempt to resync when the post-update seekable window and live\n      // point would mean that this was the perfect segment to fetch\n      this.trigger('syncinfoupdate');\n\n      // If we previously appended a segment that ends more than 3 targetDurations before\n      // the currentTime_ that means that our conservative guess was too conservative.\n      // In that case, reset the loader state so that we try to use any information gained\n      // from the previous request to create a new, more accurate, sync-point.\n      if (segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3) {\n        this.resetEverything();\n        return;\n      }\n\n      // Don't do a rendition switch unless we have enough time to get a sync segment\n      // and conservatively guess\n      if (isWalkingForward) {\n        this.trigger('bandwidthupdate');\n      }\n      this.trigger('progress');\n\n      // any time an update finishes and the last segment is in the\n      // buffer, end the stream. this ensures the \"ended\" event will\n      // fire if playback reaches that point.\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, segmentInfo.mediaIndex + 1);\n      if (isEndOfStream) {\n        this.endOfStream();\n      }\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * Records the current throughput of the decrypt, transmux, and append\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n     * moving average of the throughput. `throughput.count` is the number of\n     * data points in the average.\n     *\n     * @private\n     * @param {Object} segmentInfo the object returned by loadSegment\n     */\n  }, {\n    key: 'recordThroughput_',\n    value: function recordThroughput_(segmentInfo) {\n      var rate = this.throughput.rate;\n      // Add one to the time to ensure that we don't accidentally attempt to divide\n      // by zero in the case where the throughput is ridiculously high\n      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;\n      // Multiply by 8000 to convert from bytes/millisecond to bits/second\n      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000);\n\n      // This is just a cumulative moving average calculation:\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n\n    /**\n     * Adds a cue to the segment-metadata track with some metadata information about the\n     * segment\n     *\n     * @private\n     * @param {Object} segmentInfo\n     *        the object returned by loadSegment\n     * @method addSegmentMetadataCue_\n     */\n  }, {\n    key: 'addSegmentMetadataCue_',\n    value: function addSegmentMetadataCue_(segmentInfo) {\n      if (!this.segmentMetadataTrack_) {\n        return;\n      }\n      var segment = segmentInfo.segment;\n      var start = segment.start;\n      var end = segment.end;\n\n      // Do not try adding the cue if the start and end times are invalid.\n      if (!finite(start) || !finite(end)) {\n        return;\n      }\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n      var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\n      var value = {\n        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n        resolution: segmentInfo.playlist.attributes.RESOLUTION,\n        codecs: segmentInfo.playlist.attributes.CODECS,\n        byteLength: segmentInfo.byteLength,\n        uri: segmentInfo.uri,\n        timeline: segmentInfo.timeline,\n        playlist: segmentInfo.playlist.uri,\n        start: start,\n        end: end\n      };\n      var data = JSON.stringify(value);\n      var cue = new Cue(start, end, data);\n\n      // Attach the metadata to the value property of the cue to keep consistency between\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\n      cue.value = value;\n      this.segmentMetadataTrack_.addCue(cue);\n    }\n  }]);\n  return SegmentLoader;\n}(_videoJs2['default'].EventTarget);\nexports['default'] = SegmentLoader;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x4","_x5","_x6","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_playlist","require","_playlist2","_videoJs","_videoJs2","_sourceUpdater","_sourceUpdater2","_config","_config2","_globalWindow","_globalWindow2","_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs","_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2","_binUtils","_mediaSegmentRequest","_ranges","_playlistSelectors","CHECK_BUFFER_DELAY","detectEndOfStream","playlist","mediaSource","segmentIndex","segments","appendedLastSegment","endList","readyState","finite","num","isFinite","illegalMediaSwitch","loaderType","startingMedia","newSegmentMedia","containsAudio","containsVideo","safeBackBufferTrimTime","seekable","currentTime","targetDuration","removeToTime","start","Math","min","SegmentLoader","_videojs$EventTarget","settings","_this","options","arguments","state","bandwidth","throughput","rate","count","roundTrip","NaN","resetStats_","mediaIndex","hasPlayed_","hasPlayed","currentTime_","seekable_","seeking_","seeking","duration_","duration","mediaSource_","hls_","hls","loaderType_","startingMedia_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","checkBufferTimeout_","error_","currentTimeline_","pendingSegment_","mimeType_","sourceUpdater_","xhrOptions_","activeInitSegmentId_","initSegments_","decrypter_","decrypter","syncController_","syncController","syncPoint_","time","on","trigger","addEventListener","ended_","fetchAtBuffer_","debug","logger_","log","bind","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","dispose","pause","abort_","abort","paused","monitorBuffer_","abortRequests","error","_error","endOfStream","buffered_","createTimeRanges","buffered","initSegment","map","set","id","initSegmentId","storedMap","bytes","resolvedUri","byterange","couldBeginLoading_","playlist_","load","setDateTimeMapping","init_","resetEverything","newPlaylist","oldPlaylist","segmentInfo","syncInfo","mediaSequence","uri","resyncLoader","mediaSequenceDiff","segment","saveExpiredSegmentInfo","clearTimeout","mimeType","_mimeType","resetLoader","remove","end","setTimeout","monitorBufferTick_","fillBuffer_","updating","getSyncPoint","checkBuffer_","isEndOfStream","timeline","startOfSegment","timestampOffset","reset","loadSegment_","syncPoint","lastBufferedEnd","bufferedTime","max","getSyncSegmentCandidate_","generateSegmentInfo_","mediaSourceInfo","getMediaInfoForTime","startTime","_this2","segmentIndexArray","s","filter","isSyncRequest","requestId","random","encryptedBytes","abortRequestEarly_","stats","tech_","timeout","attributes","BANDWIDTH","Date","now","firstBytesReceivedAt","measuredBandwidth","segmentDuration","requestTimeRemaining","estimateSegmentRequestTime","bytesReceived","timeUntilRebuffer","playbackRate","switchCandidate","minRebufferMaxBandwidthSelector","master","playlists","currentTimeline","rebufferingImpact","timeSavedBySwitching","minimumTimeSaving","TIME_FUDGE_FACTOR","BANDWIDTH_VARIANCE","handleProgress_","event","simpleSegment","trimBackBuffer_","mediaSegmentRequest","xhr","createSimplifiedSegmentObj_","segmentRequestFinished_","iv","Uint32Array","roundTripTime","code","REQUEST_ERRORS","ABORTED","TIMEOUT","processSegmentResponse_","endOfAllRequests","handleSegment_","_this3","timingInfo","probeSegmentInfo","illegalMediaSwitchError","message","blacklistDuration","Infinity","timelineMapping","mappingForTimeline","type","mapping","initId","appendBuffer","byteLength","handleUpdateEnd_","isWalkingForward","recordThroughput_","addSegmentMetadataCue_","segmentProcessingTime","segmentProcessingThroughput","floor","Cue","WebKitDataCue","VTTCue","resolution","RESOLUTION","codecs","CODECS","data","JSON","stringify","cue","addCue","EventTarget"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/segment-loader.js"],"sourcesContent":["/**\n * @file segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _playlist = require('./playlist');\n\nvar _playlist2 = _interopRequireDefault(_playlist);\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _sourceUpdater = require('./source-updater');\n\nvar _sourceUpdater2 = _interopRequireDefault(_sourceUpdater);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar _mediaSegmentRequest = require('./media-segment-request');\n\nvar _ranges = require('./ranges');\n\nvar _playlistSelectors = require('./playlist-selectors');\n\n// in ms\nvar CHECK_BUFFER_DELAY = 500;\n\n/**\n * Determines if we should call endOfStream on the media source based\n * on the state of the buffer or if appened segment was the final\n * segment in the playlist.\n *\n * @param {Object} playlist a media playlist object\n * @param {Object} mediaSource the MediaSource object\n * @param {Number} segmentIndex the index of segment we last appended\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\n */\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex) {\n  if (!playlist || !mediaSource) {\n    return false;\n  }\n\n  var segments = playlist.segments;\n\n  // determine a few boolean values to help make the branch below easier\n  // to read\n  var appendedLastSegment = segmentIndex === segments.length;\n\n  // if we've buffered to the end of the video, we need to call endOfStream\n  // so that MediaSources can trigger the `ended` event when it runs out of\n  // buffered data instead of waiting for me\n  return playlist.endList && mediaSource.readyState === 'open' && appendedLastSegment;\n};\n\nvar finite = function finite(num) {\n  return typeof num === 'number' && isFinite(num);\n};\n\nvar illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, newSegmentMedia) {\n  // Although these checks should most likely cover non 'main' types, for now it narrows\n  // the scope of our checks.\n  if (loaderType !== 'main' || !startingMedia || !newSegmentMedia) {\n    return null;\n  }\n\n  if (!newSegmentMedia.containsAudio && !newSegmentMedia.containsVideo) {\n    return 'Neither audio nor video found in segment.';\n  }\n\n  if (startingMedia.containsVideo && !newSegmentMedia.containsVideo) {\n    return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  if (!startingMedia.containsVideo && newSegmentMedia.containsVideo) {\n    return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  return null;\n};\n\nexports.illegalMediaSwitch = illegalMediaSwitch;\n/**\n * Calculates a time value that is safe to remove from the back buffer without interupting\n * playback.\n *\n * @param {TimeRange} seekable\n *        The current seekable range\n * @param {Number} currentTime\n *        The current time of the player\n * @param {Number} targetDuration\n *        The target duration of the current playlist\n * @return {Number}\n *         Time that is safe to remove from the back buffer without interupting playback\n */\nvar safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {\n  var removeToTime = undefined;\n\n  if (seekable.length && seekable.start(0) > 0 && seekable.start(0) < currentTime) {\n    // If we have a seekable range use that as the limit for what can be removed safely\n    removeToTime = seekable.start(0);\n  } else {\n    // otherwise remove anything older than 30 seconds before the current play head\n    removeToTime = currentTime - 30;\n  }\n\n  // Don't allow removing from the buffer within target duration of current time\n  // to avoid the possibility of removing the GOP currently being played which could\n  // cause playback stalls.\n  return Math.min(removeToTime, currentTime - targetDuration);\n};\n\nexports.safeBackBufferTrimTime = safeBackBufferTrimTime;\n/**\n * An object that manages segment loading and appending.\n *\n * @class SegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar SegmentLoader = (function (_videojs$EventTarget) {\n  _inherits(SegmentLoader, _videojs$EventTarget);\n\n  function SegmentLoader(settings) {\n    var _this = this;\n\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, SegmentLoader);\n\n    _get(Object.getPrototypeOf(SegmentLoader.prototype), 'constructor', this).call(this);\n    // check pre-conditions\n    if (!settings) {\n      throw new TypeError('Initialization settings are required');\n    }\n    if (typeof settings.currentTime !== 'function') {\n      throw new TypeError('No currentTime getter specified');\n    }\n    if (!settings.mediaSource) {\n      throw new TypeError('No MediaSource specified');\n    }\n    // public properties\n    this.state = 'INIT';\n    this.bandwidth = settings.bandwidth;\n    this.throughput = { rate: 0, count: 0 };\n    this.roundTrip = NaN;\n    this.resetStats_();\n    this.mediaIndex = null;\n\n    // private settings\n    this.hasPlayed_ = settings.hasPlayed;\n    this.currentTime_ = settings.currentTime;\n    this.seekable_ = settings.seekable;\n    this.seeking_ = settings.seeking;\n    this.duration_ = settings.duration;\n    this.mediaSource_ = settings.mediaSource;\n    this.hls_ = settings.hls;\n    this.loaderType_ = settings.loaderType;\n    this.startingMedia_ = void 0;\n    this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n    this.goalBufferLength_ = settings.goalBufferLength;\n\n    // private instance variables\n    this.checkBufferTimeout_ = null;\n    this.error_ = void 0;\n    this.currentTimeline_ = -1;\n    this.pendingSegment_ = null;\n    this.mimeType_ = null;\n    this.sourceUpdater_ = null;\n    this.xhrOptions_ = null;\n\n    // Fragmented mp4 playback\n    this.activeInitSegmentId_ = null;\n    this.initSegments_ = {};\n\n    this.decrypter_ = settings.decrypter;\n\n    // Manages the tracking and generation of sync-points, mappings\n    // between a time in the display time and a segment index within\n    // a playlist\n    this.syncController_ = settings.syncController;\n    this.syncPoint_ = {\n      segmentIndex: 0,\n      time: 0\n    };\n\n    this.syncController_.on('syncinfoupdate', function () {\n      return _this.trigger('syncinfoupdate');\n    });\n\n    this.mediaSource_.addEventListener('sourceopen', function () {\n      return _this.ended_ = false;\n    });\n\n    // ...for determining the fetch location\n    this.fetchAtBuffer_ = false;\n\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'segment-loader', this.loaderType_, '->');\n    }\n  }\n\n  /**\n   * reset all of our media stats\n   *\n   * @private\n   */\n\n  _createClass(SegmentLoader, [{\n    key: 'resetStats_',\n    value: function resetStats_() {\n      this.mediaBytesTransferred = 0;\n      this.mediaRequests = 0;\n      this.mediaRequestsAborted = 0;\n      this.mediaRequestsTimedout = 0;\n      this.mediaRequestsErrored = 0;\n      this.mediaTransferDuration = 0;\n      this.mediaSecondsLoaded = 0;\n    }\n\n    /**\n     * dispose of the SegmentLoader and reset to the default state\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.state = 'DISPOSED';\n      this.pause();\n      this.abort_();\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.dispose();\n      }\n      this.resetStats_();\n    }\n\n    /**\n     * abort anything that is currently doing on with the SegmentLoader\n     * and reset to a default state\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.state !== 'WAITING') {\n        if (this.pendingSegment_) {\n          this.pendingSegment_ = null;\n        }\n        return;\n      }\n\n      this.abort_();\n\n      // We aborted the requests we were waiting on, so reset the loader's state to READY\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n      // when the request is aborted. This will prevent the loader from being stuck in the\n      // WAITING state indefinitely.\n      this.state = 'READY';\n\n      // don't wait for buffer check timeouts to begin fetching the\n      // next segment\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * abort all pending xhr requests and null any pending segements\n     *\n     * @private\n     */\n  }, {\n    key: 'abort_',\n    value: function abort_() {\n      if (this.pendingSegment_) {\n        this.pendingSegment_.abortRequests();\n      }\n\n      // clear out the segment being processed\n      this.pendingSegment_ = null;\n    }\n\n    /**\n     * set an error on the segment loader and null out any pending segements\n     *\n     * @param {Error} error the error to set on the SegmentLoader\n     * @return {Error} the error that was set or that is currently set\n     */\n  }, {\n    key: 'error',\n    value: function error(_error) {\n      if (typeof _error !== 'undefined') {\n        this.error_ = _error;\n      }\n\n      this.pendingSegment_ = null;\n      return this.error_;\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      this.ended_ = true;\n      this.pause();\n      this.trigger('ended');\n    }\n\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n  }, {\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.sourceUpdater_) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n\n      return this.sourceUpdater_.buffered();\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      if (!map) {\n        return null;\n      }\n\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set && !storedMap && map.bytes) {\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: map.bytes\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && (\n      // the source updater is created when init_ is called, so either having a\n      // source updater or being in the INIT state with a mimeType is enough\n      // to say we have all the needed configuration to start loading.\n      this.sourceUpdater_ || this.mimeType_ && this.state === 'INIT') && !this.paused();\n    }\n\n    /**\n     * load a playlist and start to fill the buffer\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      // un-pause\n      this.monitorBuffer_();\n\n      // if we don't have a playlist yet, keep waiting for one to be\n      // specified\n      if (!this.playlist_) {\n        return;\n      }\n\n      // not sure if this is the best place for this\n      this.syncController_.setDateTimeMapping(this.playlist_);\n\n      // if all the configuration is ready, initialize and begin loading\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      // if we're in the middle of processing a segment already, don't\n      // kick off an additional segment request\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n        return;\n      }\n\n      this.state = 'READY';\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.sourceUpdater_ = new _sourceUpdater2['default'](this.mediaSource_, this.mimeType_);\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * set a playlist on the segment loader\n     *\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\n     */\n  }, {\n    key: 'playlist',\n    value: function playlist(newPlaylist) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      if (!newPlaylist) {\n        return;\n      }\n\n      var oldPlaylist = this.playlist_;\n      var segmentInfo = this.pendingSegment_;\n\n      this.playlist_ = newPlaylist;\n      this.xhrOptions_ = options;\n\n      // when we haven't started playing yet, the start of a live playlist\n      // is always our zero-time so force a sync update each time the playlist\n      // is refreshed from the server\n      if (!this.hasPlayed_()) {\n        newPlaylist.syncInfo = {\n          mediaSequence: newPlaylist.mediaSequence,\n          time: 0\n        };\n      }\n\n      // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n      // in LIVE, we always want to update with new playlists (including refreshes)\n      this.trigger('syncinfoupdate');\n\n      // if we were unpaused but waiting for a playlist, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n        if (this.mediaIndex !== null) {\n          // we must \"resync\" the segment loader when we switch renditions and\n          // the segment loader is already synced to the previous rendition\n          this.resyncLoader();\n        }\n\n        // the rest of this function depends on `oldPlaylist` being defined\n        return;\n      }\n\n      // we reloaded the same playlist so we are in a live scenario\n      // and we will likely need to adjust the mediaIndex\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      this.logger_('mediaSequenceDiff', mediaSequenceDiff);\n\n      // update the mediaIndex on the SegmentLoader\n      // this is important because we can abort a request and this value must be\n      // equal to the last appended mediaIndex\n      if (this.mediaIndex !== null) {\n        this.mediaIndex -= mediaSequenceDiff;\n      }\n\n      // update the mediaIndex on the SegmentInfo object\n      // this is important because we will update this.mediaIndex with this value\n      // in `handleUpdateEnd_` after the segment has been successfully appended\n      if (segmentInfo) {\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\n\n        // we need to update the referenced segment so that timing information is\n        // saved for the new playlist's segment, however, if the segment fell off the\n        // playlist, we can leave the old reference and just lose the timing info\n        if (segmentInfo.mediaIndex >= 0) {\n          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n        }\n      }\n\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n    }\n\n    /**\n     * Prevent the loader from fetching additional segments. If there\n     * is a segment request outstanding, it will finish processing\n     * before the loader halts. A segment loader can be unpaused by\n     * calling load().\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n\n        this.checkBufferTimeout_ = null;\n      }\n    }\n\n    /**\n     * Returns whether the segment loader is fetching additional\n     * segments when given the opportunity. This property can be\n     * modified through calls to pause() and load().\n     */\n  }, {\n    key: 'paused',\n    value: function paused() {\n      return this.checkBufferTimeout_ === null;\n    }\n\n    /**\n     * create/set the following mimetype on the SourceBuffer through a\n     * SourceUpdater\n     *\n     * @param {String} mimeType the mime type string to use\n     */\n  }, {\n    key: 'mimeType',\n    value: function mimeType(_mimeType) {\n      if (this.mimeType_) {\n        return;\n      }\n\n      this.mimeType_ = _mimeType;\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n    }\n\n    /**\n     * Delete all the buffered data and reset the SegmentLoader\n     */\n  }, {\n    key: 'resetEverything',\n    value: function resetEverything() {\n      this.ended_ = false;\n      this.resetLoader();\n      this.remove(0, this.duration_());\n      this.trigger('reseteverything');\n    }\n\n    /**\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\n     * of starting at the end of the buffer\n     *\n     * Useful for fast quality changes\n     */\n  }, {\n    key: 'resetLoader',\n    value: function resetLoader() {\n      this.fetchAtBuffer_ = false;\n      this.resyncLoader();\n    }\n\n    /**\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\n     * before returning to the simple walk-forward method\n     */\n  }, {\n    key: 'resyncLoader',\n    value: function resyncLoader() {\n      this.mediaIndex = null;\n      this.syncPoint_ = null;\n      this.abort();\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.remove(start, end);\n      }\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n    }\n\n    /**\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBuffer_',\n    value: function monitorBuffer_() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), 1);\n    }\n\n    /**\n     * As long as the SegmentLoader is in the READY state, periodically\n     * invoke fillBuffer_().\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBufferTick_',\n    value: function monitorBufferTick_() {\n      if (this.state === 'READY') {\n        this.fillBuffer_();\n      }\n\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      if (this.sourceUpdater_.updating()) {\n        return;\n      }\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      var isEndOfStream = detectEndOfStream(this.playlist_, this.mediaSource_, segmentInfo.mediaIndex);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n        return;\n      }\n\n      if (segmentInfo.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\n        return;\n      }\n\n      // We will need to change timestampOffset of the sourceBuffer if either of\n      // the following conditions are true:\n      // - The segment.timeline !== this.currentTimeline\n      //   (we are crossing a discontinuity somehow)\n      // - The \"timestampOffset\" for the start of this segment is less than\n      //   the currently set timestampOffset\n      if (segmentInfo.timeline !== this.currentTimeline_ || segmentInfo.startOfSegment !== null && segmentInfo.startOfSegment < this.sourceUpdater_.timestampOffset()) {\n        this.syncController_.reset();\n        segmentInfo.timestampOffset = segmentInfo.startOfSegment;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Determines what segment request should be made, given current playback\n     * state.\n     *\n     * @param {TimeRanges} buffered - the state of the buffer\n     * @param {Object} playlist - the playlist object to fetch segments from\n     * @param {Number} mediaIndex - the previous mediaIndex fetched or null\n     * @param {Boolean} hasPlayed - a flag indicating whether we have played or not\n     * @param {Number} currentTime - the playback position in seconds\n     * @param {Object} syncPoint - a segment info object that describes the\n     * @returns {Object} a segment request object that describes the segment to load\n     */\n  }, {\n    key: 'checkBuffer_',\n    value: function checkBuffer_(buffered, playlist, mediaIndex, hasPlayed, currentTime, syncPoint) {\n      var lastBufferedEnd = 0;\n      var startOfSegment = undefined;\n\n      if (buffered.length) {\n        lastBufferedEnd = buffered.end(buffered.length - 1);\n      }\n\n      var bufferedTime = Math.max(0, lastBufferedEnd - currentTime);\n\n      if (!playlist.segments.length) {\n        return null;\n      }\n\n      // if there is plenty of content buffered, and the video has\n      // been played before relax for awhile\n      if (bufferedTime >= this.goalBufferLength_()) {\n        return null;\n      }\n\n      // if the video has not yet played once, and we already have\n      // one segment downloaded do nothing\n      if (!hasPlayed && bufferedTime >= 1) {\n        return null;\n      }\n\n      this.logger_('checkBuffer_', 'mediaIndex:', mediaIndex, 'hasPlayed:', hasPlayed, 'currentTime:', currentTime, 'syncPoint:', syncPoint, 'fetchAtBuffer:', this.fetchAtBuffer_, 'bufferedTime:', bufferedTime);\n\n      // When the syncPoint is null, there is no way of determining a good\n      // conservative segment index to fetch from\n      // The best thing to do here is to get the kind of sync-point data by\n      // making a request\n      if (syncPoint === null) {\n        mediaIndex = this.getSyncSegmentCandidate_(playlist);\n        this.logger_('getSync', 'mediaIndex:', mediaIndex);\n        return this.generateSegmentInfo_(playlist, mediaIndex, null, true);\n      }\n\n      // Under normal playback conditions fetching is a simple walk forward\n      if (mediaIndex !== null) {\n        this.logger_('walkForward', 'mediaIndex:', mediaIndex + 1);\n        var segment = playlist.segments[mediaIndex];\n\n        if (segment && segment.end) {\n          startOfSegment = segment.end;\n        } else {\n          startOfSegment = lastBufferedEnd;\n        }\n        return this.generateSegmentInfo_(playlist, mediaIndex + 1, startOfSegment, false);\n      }\n\n      // There is a sync-point but the lack of a mediaIndex indicates that\n      // we need to make a good conservative guess about which segment to\n      // fetch\n      if (this.fetchAtBuffer_) {\n        // Find the segment containing the end of the buffer\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, lastBufferedEnd, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      } else {\n        // Find the segment containing currentTime\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, currentTime, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      }\n      this.logger_('getMediaIndexForTime', 'mediaIndex:', mediaIndex, 'startOfSegment:', startOfSegment);\n\n      return this.generateSegmentInfo_(playlist, mediaIndex, startOfSegment, false);\n    }\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Object} playlist - the playlist object to look for a\n     * @returns {Number} An index of a segment from the playlist to load\n     */\n  }, {\n    key: 'getSyncSegmentCandidate_',\n    value: function getSyncSegmentCandidate_(playlist) {\n      var _this2 = this;\n\n      if (this.currentTimeline_ === -1) {\n        return 0;\n      }\n\n      var segmentIndexArray = playlist.segments.map(function (s, i) {\n        return {\n          timeline: s.timeline,\n          segmentIndex: i\n        };\n      }).filter(function (s) {\n        return s.timeline === _this2.currentTimeline_;\n      });\n\n      if (segmentIndexArray.length) {\n        return segmentIndexArray[Math.min(segmentIndexArray.length - 1, 1)].segmentIndex;\n      }\n\n      return Math.max(playlist.segments.length - 1, 0);\n    }\n  }, {\n    key: 'generateSegmentInfo_',\n    value: function generateSegmentInfo_(playlist, mediaIndex, startOfSegment, isSyncRequest) {\n      if (mediaIndex < 0 || mediaIndex >= playlist.segments.length) {\n        return null;\n      }\n\n      var segment = playlist.segments[mediaIndex];\n\n      return {\n        requestId: 'segment-loader-' + Math.random(),\n        // resolve the segment URL relative to the playlist\n        uri: segment.resolvedUri,\n        // the segment's mediaIndex at the time it was requested\n        mediaIndex: mediaIndex,\n        // whether or not to update the SegmentLoader's state with this\n        // segment's mediaIndex\n        isSyncRequest: isSyncRequest,\n        startOfSegment: startOfSegment,\n        // the segment's playlist\n        playlist: playlist,\n        // unencrypted bytes of the segment\n        bytes: null,\n        // when a key is defined for this segment, the encrypted bytes\n        encryptedBytes: null,\n        // The target timestampOffset for this segment when we append it\n        // to the source buffer\n        timestampOffset: null,\n        // The timeline that the segment is in\n        timeline: segment.timeline,\n        // The expected duration of the segment in seconds\n        duration: segment.duration,\n        // retain the segment in case the playlist updates while doing an async process\n        segment: segment\n      };\n    }\n\n    /**\n     * Determines if the network has enough bandwidth to complete the current segment\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\n     * updated to trigger a playlist switch.\n     *\n     * @param {Object} stats\n     *        Object containing stats about the request timing and size\n     * @return {Boolean} True if the request was aborted, false otherwise\n     * @private\n     */\n  }, {\n    key: 'abortRequestEarly_',\n    value: function abortRequestEarly_(stats) {\n      if (this.hls_.tech_.paused() ||\n      // Don't abort if the current playlist is on the lowestEnabledRendition\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\n      //       the lowestEnabledRendition.\n      !this.xhrOptions_.timeout ||\n      // Don't abort if we have no bandwidth information to estimate segment sizes\n      !this.playlist_.attributes.BANDWIDTH) {\n        return false;\n      }\n\n      // Wait at least 1 second since the first byte of data has been received before\n      // using the calculated bandwidth from the progress event to allow the bitrate\n      // to stabilize\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n        return false;\n      }\n\n      var currentTime = this.currentTime_();\n      var measuredBandwidth = stats.bandwidth;\n      var segmentDuration = this.pendingSegment_.duration;\n\n      var requestTimeRemaining = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);\n\n      // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n      // if we are only left with less than 1 second when the request completes.\n      // A negative timeUntilRebuffering indicates we are already rebuffering\n      var timeUntilRebuffer = (0, _ranges.timeUntilRebuffer)(this.buffered_(), currentTime, this.hls_.tech_.playbackRate()) - 1;\n\n      // Only consider aborting early if the estimated time to finish the download\n      // is larger than the estimated time until the player runs out of forward buffer\n      if (requestTimeRemaining <= timeUntilRebuffer) {\n        return false;\n      }\n\n      var switchCandidate = (0, _playlistSelectors.minRebufferMaxBandwidthSelector)({\n        master: this.hls_.playlists.master,\n        currentTime: currentTime,\n        bandwidth: measuredBandwidth,\n        duration: this.duration_(),\n        segmentDuration: segmentDuration,\n        timeUntilRebuffer: timeUntilRebuffer,\n        currentTimeline: this.currentTimeline_,\n        syncController: this.syncController_\n      });\n\n      if (!switchCandidate) {\n        return;\n      }\n\n      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer;\n\n      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n\n      var minimumTimeSaving = 0.5;\n\n      // If we are already rebuffering, increase the amount of variance we add to the\n      // potential round trip time of the new request so that we are not too aggressive\n      // with switching to a playlist that might save us a fraction of a second.\n      if (timeUntilRebuffer <= _ranges.TIME_FUDGE_FACTOR) {\n        minimumTimeSaving = 1;\n      }\n\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n        return false;\n      }\n\n      // set the bandwidth to that of the desired playlist being sure to scale by\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * _config2['default'].BANDWIDTH_VARIANCE + 1;\n      this.abort();\n      this.trigger('earlyabort');\n      return true;\n    }\n\n    /**\n     * XHR `progress` event handler\n     *\n     * @param {Event}\n     *        The XHR `progress` event\n     * @param {Object} simpleSegment\n     *        A simplified segment object copy\n     * @private\n     */\n  }, {\n    key: 'handleProgress_',\n    value: function handleProgress_(event, simpleSegment) {\n      if (!this.pendingSegment_ || simpleSegment.requestId !== this.pendingSegment_.requestId || this.abortRequestEarly_(simpleSegment.stats)) {\n        return;\n      }\n\n      this.trigger('progress');\n    }\n\n    /**\n     * load a specific segment from a request into the buffer\n     *\n     * @private\n     */\n  }, {\n    key: 'loadSegment_',\n    value: function loadSegment_(segmentInfo) {\n      this.state = 'WAITING';\n      this.pendingSegment_ = segmentInfo;\n      this.trimBackBuffer_(segmentInfo);\n\n      segmentInfo.abortRequests = (0, _mediaSegmentRequest.mediaSegmentRequest)(this.hls_.xhr, this.xhrOptions_, this.decrypter_, this.createSimplifiedSegmentObj_(segmentInfo),\n      // progress callback\n      this.handleProgress_.bind(this), this.segmentRequestFinished_.bind(this));\n    }\n\n    /**\n     * trim the back buffer so that we don't have too much data\n     * in the source buffer\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     */\n  }, {\n    key: 'trimBackBuffer_',\n    value: function trimBackBuffer_(segmentInfo) {\n      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);\n\n      // Chrome has a hard limit of 150MB of\n      // buffer and a very conservative \"garbage collector\"\n      // We manually clear out the old buffer to ensure\n      // we don't trigger the QuotaExceeded error\n      // on the source buffer during subsequent appends\n\n      if (removeToTime > 0) {\n        this.remove(0, removeToTime);\n      }\n    }\n\n    /**\n     * created a simplified copy of the segment object with just the\n     * information necessary to perform the XHR and decryption\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     * @returns {Object} a simplified segment object copy\n     */\n  }, {\n    key: 'createSimplifiedSegmentObj_',\n    value: function createSimplifiedSegmentObj_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var simpleSegment = {\n        resolvedUri: segment.resolvedUri,\n        byterange: segment.byterange,\n        requestId: segmentInfo.requestId\n      };\n\n      if (segment.key) {\n        // if the media sequence is greater than 2^32, the IV will be incorrect\n        // assuming 10s segments, that would be about 1300 years\n        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n\n        simpleSegment.key = {\n          resolvedUri: segment.key.resolvedUri,\n          iv: iv\n        };\n      }\n\n      if (segment.map) {\n        simpleSegment.map = this.initSegment(segment.map);\n      }\n\n      return simpleSegment;\n    }\n\n    /**\n     * Handle the callback from the segmentRequest function and set the\n     * associated SegmentLoader state and errors if necessary\n     *\n     * @private\n     */\n  }, {\n    key: 'segmentRequestFinished_',\n    value: function segmentRequestFinished_(error, simpleSegment) {\n      // every request counts as a media request even if it has been aborted\n      // or canceled due to a timeout\n      this.mediaRequests += 1;\n\n      if (simpleSegment.stats) {\n        this.mediaBytesTransferred += simpleSegment.stats.bytesReceived;\n        this.mediaTransferDuration += simpleSegment.stats.roundTripTime;\n      }\n\n      // The request was aborted and the SegmentLoader has already been reset\n      if (!this.pendingSegment_) {\n        this.mediaRequestsAborted += 1;\n        return;\n      }\n\n      // the request was aborted and the SegmentLoader has already started\n      // another request. this can happen when the timeout for an aborted\n      // request triggers due to a limitation in the XHR library\n      // do not count this as any sort of request or we risk double-counting\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n        return;\n      }\n\n      // an error occurred from the active pendingSegment_ so reset everything\n      if (error) {\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n\n        // the requests were aborted just record the aborted stat and exit\n        // this is not a true error condition and nothing corrective needs\n        // to be done\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.ABORTED) {\n          this.mediaRequestsAborted += 1;\n          return;\n        }\n\n        this.pause();\n\n        // the error is really just that at least one of the requests timed-out\n        // set the bandwidth to a very low value and trigger an ABR switch to\n        // take emergency action\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.TIMEOUT) {\n          this.mediaRequestsTimedout += 1;\n          this.bandwidth = 1;\n          this.roundTrip = NaN;\n          this.trigger('bandwidthupdate');\n          return;\n        }\n\n        // if control-flow has arrived here, then the error is real\n        // emit an error event to blacklist the current playlist\n        this.mediaRequestsErrored += 1;\n        this.error(error);\n        this.trigger('error');\n        return;\n      }\n\n      // the response was a success so set any bandwidth stats the request\n      // generated for ABR purposes\n      this.bandwidth = simpleSegment.stats.bandwidth;\n      this.roundTrip = simpleSegment.stats.roundTripTime;\n\n      // if this request included an initialization segment, save that data\n      // to the initSegment cache\n      if (simpleSegment.map) {\n        simpleSegment.map = this.initSegment(simpleSegment.map, true);\n      }\n\n      this.processSegmentResponse_(simpleSegment);\n    }\n\n    /**\n     * Move any important data from the simplified segment object\n     * back to the real segment object for future phases\n     *\n     * @private\n     */\n  }, {\n    key: 'processSegmentResponse_',\n    value: function processSegmentResponse_(simpleSegment) {\n      var segmentInfo = this.pendingSegment_;\n\n      segmentInfo.bytes = simpleSegment.bytes;\n      if (simpleSegment.map) {\n        segmentInfo.segment.map.bytes = simpleSegment.map.bytes;\n      }\n\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n      this.handleSegment_();\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this3 = this;\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var timingInfo = this.syncController_.probeSegmentInfo(segmentInfo);\n\n      // When we have our first timing info, determine what media types this loader is\n      // dealing with. Although we're maintaining extra state, it helps to preserve the\n      // separation of segment loader from the actual source buffers.\n      if (typeof this.startingMedia_ === 'undefined' && timingInfo && (\n      // Guard against cases where we're not getting timing info at all until we are\n      // certain that all streams will provide it.\n      timingInfo.containsAudio || timingInfo.containsVideo)) {\n        this.startingMedia_ = {\n          containsAudio: timingInfo.containsAudio,\n          containsVideo: timingInfo.containsVideo\n        };\n      }\n\n      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.startingMedia_, timingInfo);\n\n      if (illegalMediaSwitchError) {\n        this.error({\n          message: illegalMediaSwitchError,\n          blacklistDuration: Infinity\n        });\n        this.trigger('error');\n        return;\n      }\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      if (segmentInfo.timestampOffset !== null && segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\n        // fired when a timestamp offset is set in HLS (can also identify discontinuities)\n        this.trigger('timestampoffset');\n      }\n\n      var timelineMapping = this.syncController_.mappingForTimeline(segmentInfo.timeline);\n\n      if (timelineMapping !== null) {\n        this.trigger({\n          type: 'segmenttimemapping',\n          mapping: timelineMapping\n        });\n      }\n\n      this.state = 'APPENDING';\n\n      // if the media initialization segment is changing, append it\n      // before the content segment\n      if (segment.map) {\n        (function () {\n          var initId = (0, _binUtils.initSegmentId)(segment.map);\n\n          if (!_this3.activeInitSegmentId_ || _this3.activeInitSegmentId_ !== initId) {\n            var initSegment = _this3.initSegment(segment.map);\n\n            _this3.sourceUpdater_.appendBuffer(initSegment.bytes, function () {\n              _this3.activeInitSegmentId_ = initId;\n            });\n          }\n        })();\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n        this.mediaSecondsLoaded += segment.end - segment.start;\n      } else {\n        this.mediaSecondsLoaded += segment.duration;\n      }\n\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\n    }\n\n    /**\n     * callback to run when appendBuffer is finished. detects if we are\n     * in a good state to do things with the data we got, or if we need\n     * to wait for more\n     *\n     * @private\n     */\n  }, {\n    key: 'handleUpdateEnd_',\n    value: function handleUpdateEnd_() {\n      this.logger_('handleUpdateEnd_', 'segmentInfo:', this.pendingSegment_);\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        if (!this.paused()) {\n          this.monitorBuffer_();\n        }\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var isWalkingForward = this.mediaIndex !== null;\n\n      this.pendingSegment_ = null;\n      this.recordThroughput_(segmentInfo);\n      this.addSegmentMetadataCue_(segmentInfo);\n\n      this.state = 'READY';\n\n      this.mediaIndex = segmentInfo.mediaIndex;\n      this.fetchAtBuffer_ = true;\n      this.currentTimeline_ = segmentInfo.timeline;\n\n      // We must update the syncinfo to recalculate the seekable range before\n      // the following conditional otherwise it may consider this a bad \"guess\"\n      // and attempt to resync when the post-update seekable window and live\n      // point would mean that this was the perfect segment to fetch\n      this.trigger('syncinfoupdate');\n\n      // If we previously appended a segment that ends more than 3 targetDurations before\n      // the currentTime_ that means that our conservative guess was too conservative.\n      // In that case, reset the loader state so that we try to use any information gained\n      // from the previous request to create a new, more accurate, sync-point.\n      if (segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3) {\n        this.resetEverything();\n        return;\n      }\n\n      // Don't do a rendition switch unless we have enough time to get a sync segment\n      // and conservatively guess\n      if (isWalkingForward) {\n        this.trigger('bandwidthupdate');\n      }\n      this.trigger('progress');\n\n      // any time an update finishes and the last segment is in the\n      // buffer, end the stream. this ensures the \"ended\" event will\n      // fire if playback reaches that point.\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, segmentInfo.mediaIndex + 1);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n      }\n\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * Records the current throughput of the decrypt, transmux, and append\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n     * moving average of the throughput. `throughput.count` is the number of\n     * data points in the average.\n     *\n     * @private\n     * @param {Object} segmentInfo the object returned by loadSegment\n     */\n  }, {\n    key: 'recordThroughput_',\n    value: function recordThroughput_(segmentInfo) {\n      var rate = this.throughput.rate;\n      // Add one to the time to ensure that we don't accidentally attempt to divide\n      // by zero in the case where the throughput is ridiculously high\n      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;\n      // Multiply by 8000 to convert from bytes/millisecond to bits/second\n      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000);\n\n      // This is just a cumulative moving average calculation:\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n\n    /**\n     * Adds a cue to the segment-metadata track with some metadata information about the\n     * segment\n     *\n     * @private\n     * @param {Object} segmentInfo\n     *        the object returned by loadSegment\n     * @method addSegmentMetadataCue_\n     */\n  }, {\n    key: 'addSegmentMetadataCue_',\n    value: function addSegmentMetadataCue_(segmentInfo) {\n      if (!this.segmentMetadataTrack_) {\n        return;\n      }\n\n      var segment = segmentInfo.segment;\n      var start = segment.start;\n      var end = segment.end;\n\n      // Do not try adding the cue if the start and end times are invalid.\n      if (!finite(start) || !finite(end)) {\n        return;\n      }\n\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n\n      var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\n      var value = {\n        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n        resolution: segmentInfo.playlist.attributes.RESOLUTION,\n        codecs: segmentInfo.playlist.attributes.CODECS,\n        byteLength: segmentInfo.byteLength,\n        uri: segmentInfo.uri,\n        timeline: segmentInfo.timeline,\n        playlist: segmentInfo.playlist.uri,\n        start: start,\n        end: end\n      };\n      var data = JSON.stringify(value);\n      var cue = new Cue(start, end, data);\n\n      // Attach the metadata to the value property of the cue to keep consistency between\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\n      cue.value = value;\n\n      this.segmentMetadataTrack_.addCue(cue);\n    }\n  }]);\n\n  return SegmentLoader;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = SegmentLoader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}