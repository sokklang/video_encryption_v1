{"ast":null,"code":"'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function (options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function (output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function (flushSource) {\n  var id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n  this.trigger('done');\n};\nmodule.exports = CoalesceStream;","map":{"version":3,"names":["Stream","require","CoalesceStream","options","numberOfTracks","metadataStream","videoTags","audioTags","videoTrack","audioTrack","pendingCaptions","pendingMetadata","pendingTracks","processedTracks","prototype","init","call","push","output","text","frames","track","type","tags","flush","flushSource","id3","caption","i","timelineStartPts","event","captions","captionStreams","metadata","timelineStartInfo","pts","length","startTime","startPts","endTime","endPts","stream","cueTime","dispatchType","trigger","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/coalesce-stream.js"],"sourcesContent":["'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}