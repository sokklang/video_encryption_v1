{"ast":null,"code":"/**\n * @file flash-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x, _x2, _x3) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x,\n      property = _x2,\n      receiver = _x3;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x = parent;\n        _x2 = property;\n        _x3 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _globalWindow = require('global/window');\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _muxJsLibFlv = require('mux.js/lib/flv');\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\nvar _addTextTrackData = require('./add-text-track-data');\nvar _flashTransmuxerWorker = require('./flash-transmuxer-worker');\nvar _flashTransmuxerWorker2 = _interopRequireDefault(_flashTransmuxerWorker);\nvar _webwackify = require('webwackify');\nvar _webwackify2 = _interopRequireDefault(_webwackify);\nvar _flashConstants = require('./flash-constants');\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\nvar resolveFlashTransmuxWorker = function resolveFlashTransmuxWorker() {\n  var result = undefined;\n  try {\n    result = require.resolve('./flash-transmuxer-worker');\n  } catch (e) {\n    // no result\n  }\n  return result;\n};\n\n/**\n * A wrapper around the setTimeout function that uses\n * the flash constant time between ticks value.\n *\n * @param {Function} func the function callback to run\n * @private\n */\nvar scheduleTick = function scheduleTick(func) {\n  // Chrome doesn't invoke requestAnimationFrame callbacks\n  // in background tabs, so use setTimeout.\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_CHUNKS);\n};\n\n/**\n * Generates a random string of max length 6\n *\n * @return {String} the randomly generated string\n * @function generateRandomString\n * @private\n */\nvar generateRandomString = function generateRandomString() {\n  return Math.random().toString(36).slice(2, 8);\n};\n\n/**\n * Round a number to a specified number of places much like\n * toFixed but return a number instead of a string representation.\n *\n * @param {Number} num A number\n * @param {Number} places The number of decimal places which to\n * round\n * @private\n */\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\n  if (typeof places !== 'number' || places < 0) {\n    places = 0;\n  }\n  var scale = Math.pow(10, places);\n  return Math.round(num * scale) / scale;\n};\n\n/**\n * A SourceBuffer implementation for Flash rather than HTML.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @param {Object} mediaSource the flash media source\n * @class FlashSourceBuffer\n * @extends videojs.EventTarget\n */\n\nvar FlashSourceBuffer = function (_videojs$EventTarget) {\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\n  function FlashSourceBuffer(mediaSource) {\n    var _this = this;\n    _classCallCheck(this, FlashSourceBuffer);\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\n    var encodedHeader = undefined;\n\n    // Start off using the globally defined value but refine\n    // as we append data into flash\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n    // byte arrays queued to be appended\n    this.buffer_ = [];\n\n    // the total number of queued bytes\n    this.bufferSize_ = 0;\n\n    // to be able to determine the correct position to seek to, we\n    // need to retain information about the mapping between the\n    // media timeline and PTS values\n    this.basePtsOffset_ = NaN;\n    this.mediaSource_ = mediaSource;\n    this.audioBufferEnd_ = NaN;\n    this.videoBufferEnd_ = NaN;\n\n    // indicates whether the asynchronous continuation of an operation\n    // is still being processed\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\n    this.updating = false;\n    this.timestampOffset_ = 0;\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(_muxJsLibFlv2['default'].getFlvHeader())));\n\n    // create function names with added randomness for the global callbacks flash will use\n    // to get data from javascript into the swf. Random strings are added as a safety\n    // measure for pages with multiple players since these functions will be global\n    // instead of per instance. When making a call to the swf, the browser generates a\n    // try catch code snippet, but just takes the function name and writes out an unquoted\n    // call to that function. If the player id has any special characters, this will result\n    // in an error, so safePlayerId replaces all special characters to '_'\n    var safePlayerId = this.mediaSource_.player_.id().replace(/[^a-zA-Z0-9]/g, '_');\n    this.flashEncodedHeaderName_ = 'vjs_flashEncodedHeader_' + safePlayerId + generateRandomString();\n    this.flashEncodedDataName_ = 'vjs_flashEncodedData_' + safePlayerId + generateRandomString();\n    _globalWindow2['default'][this.flashEncodedHeaderName_] = function () {\n      delete _globalWindow2['default'][_this.flashEncodedHeaderName_];\n      return encodedHeader;\n    };\n    this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedHeaderName_);\n    this.transmuxer_ = (0, _webwackify2['default'])(_flashTransmuxerWorker2['default'], resolveFlashTransmuxWorker());\n    this.transmuxer_.postMessage({\n      action: 'init',\n      options: {}\n    });\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        _this.receiveBuffer_(event.data.segment);\n      }\n    };\n    this.one('updateend', function () {\n      _this.mediaSource_.tech_.trigger('loadedmetadata');\n    });\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          // We have to tell flash to expect a discontinuity\n          this.mediaSource_.swfObj.vjs_discontinuity();\n          // the media <-> PTS mapping must be re-established after\n          // the discontinuity\n          this.basePtsOffset_ = NaN;\n          this.audioBufferEnd_ = NaN;\n          this.videoBufferEnd_ = NaN;\n          this.transmuxer_.postMessage({\n            action: 'reset'\n          });\n        }\n      }\n    });\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        if (!this.mediaSource_ || !this.mediaSource_.swfObj || !('vjs_getProperty' in this.mediaSource_.swfObj)) {\n          return _videoJs2['default'].createTimeRange();\n        }\n        var buffered = this.mediaSource_.swfObj.vjs_getProperty('buffered');\n        if (buffered && buffered.length) {\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\n        }\n        return _videoJs2['default'].createTimeRanges(buffered);\n      }\n    });\n\n    // On a seek we remove all text track data since flash has no concept\n    // of a buffered-range and everything else is reset on seek\n    this.mediaSource_.player_.on('seeked', function () {\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\n      if (_this.inbandTextTracks_) {\n        for (var track in _this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTracks_[track]);\n        }\n      }\n    });\n    var onHlsReset = this.onHlsReset_.bind(this);\n\n    // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n    // resets its state and flushes the buffer\n    this.mediaSource_.player_.tech_.on('hls-reset', onHlsReset);\n    this.mediaSource_.player_.tech_.hls.on('dispose', function () {\n      _this.transmuxer_.terminate();\n      _this.mediaSource_.player_.tech_.off('hls-reset', onHlsReset);\n    });\n  }\n\n  /**\n   * Append bytes to the sourcebuffers buffer, in this case we\n   * have to append it to swf object.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n   * @param {Array} bytes\n   */\n\n  _createClass(FlashSourceBuffer, [{\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes) {\n      var error = undefined;\n      if (this.updating) {\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n      this.updating = true;\n      this.mediaSource_.readyState = 'open';\n      this.trigger({\n        type: 'update'\n      });\n      this.transmuxer_.postMessage({\n        action: 'push',\n        data: bytes.buffer,\n        byteOffset: bytes.byteOffset,\n        byteLength: bytes.byteLength\n      }, [bytes.buffer]);\n      this.transmuxer_.postMessage({\n        action: 'flush'\n      });\n    }\n\n    /**\n     * Reset the parser and remove any data queued to be sent to the SWF.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      this.buffer_ = [];\n      this.bufferSize_ = 0;\n      this.mediaSource_.swfObj.vjs_abort();\n\n      // report any outstanding updates have ended\n      if (this.updating) {\n        this.updating = false;\n        this.trigger({\n          type: 'updateend'\n        });\n      }\n    }\n\n    /**\n     * Flash cannot remove ranges already buffered in the NetStream\n     * but seeking clears the buffer entirely. For most purposes,\n     * having this operation act as a no-op is acceptable.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start start of the section to remove\n     * @param {Double} end end of the section to remove\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n      this.trigger({\n        type: 'update'\n      });\n      this.trigger({\n        type: 'updateend'\n      });\n    }\n\n    /**\n     * Receive a buffer from the flv.\n     *\n     * @param {Object} segment\n     * @private\n     */\n  }, {\n    key: 'receiveBuffer_',\n    value: function receiveBuffer_(segment) {\n      var _this2 = this;\n\n      // create an in-band caption track if one is present in the segment\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n      (0, _addTextTrackData.addTextTrackData)(this, segment.captions, segment.metadata);\n\n      // Do this asynchronously since convertTagsToData_ can be time consuming\n      scheduleTick(function () {\n        var flvBytes = _this2.convertTagsToData_(segment);\n        if (_this2.buffer_.length === 0) {\n          scheduleTick(_this2.processBuffer_.bind(_this2));\n        }\n        if (flvBytes) {\n          _this2.buffer_.push(flvBytes);\n          _this2.bufferSize_ += flvBytes.byteLength;\n        }\n      });\n    }\n\n    /**\n     * Append a portion of the current buffer to the SWF.\n     *\n     * @private\n     */\n  }, {\n    key: 'processBuffer_',\n    value: function processBuffer_() {\n      var _this3 = this;\n      var chunkSize = _flashConstants2['default'].BYTES_PER_CHUNK;\n      if (!this.buffer_.length) {\n        if (this.updating !== false) {\n          this.updating = false;\n          this.trigger({\n            type: 'updateend'\n          });\n        }\n        // do nothing if the buffer is empty\n        return;\n      }\n\n      // concatenate appends up to the max append size\n      var chunk = this.buffer_[0].subarray(0, chunkSize);\n\n      // requeue any bytes that won't make it this round\n      if (chunk.byteLength < chunkSize || this.buffer_[0].byteLength === chunkSize) {\n        this.buffer_.shift();\n      } else {\n        this.buffer_[0] = this.buffer_[0].subarray(chunkSize);\n      }\n      this.bufferSize_ -= chunk.byteLength;\n\n      // base64 encode the bytes\n      var binary = [];\n      var length = chunk.byteLength;\n      for (var i = 0; i < length; i++) {\n        binary.push(String.fromCharCode(chunk[i]));\n      }\n      var b64str = _globalWindow2['default'].btoa(binary.join(''));\n      _globalWindow2['default'][this.flashEncodedDataName_] = function () {\n        // schedule another processBuffer to process any left over data or to\n        // trigger updateend\n        scheduleTick(_this3.processBuffer_.bind(_this3));\n        delete _globalWindow2['default'][_this3.flashEncodedDataName_];\n        return b64str;\n      };\n\n      // Notify the swf that segment data is ready to be appended\n      this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedDataName_);\n    }\n\n    /**\n     * Turns an array of flv tags into a Uint8Array representing the\n     * flv data. Also removes any tags that are before the current\n     * time so that playback begins at or slightly after the right\n     * place on a seek\n     *\n     * @private\n     * @param {Object} segmentData object of segment data\n     */\n  }, {\n    key: 'convertTagsToData_',\n    value: function convertTagsToData_(segmentData) {\n      var segmentByteLength = 0;\n      var tech = this.mediaSource_.tech_;\n      var videoTargetPts = 0;\n      var segment = undefined;\n      var videoTags = segmentData.tags.videoTags;\n      var audioTags = segmentData.tags.audioTags;\n\n      // Establish the media timeline to PTS translation if we don't\n      // have one already\n      if (isNaN(this.basePtsOffset_) && (videoTags.length || audioTags.length)) {\n        // We know there is at least one video or audio tag, but since we may not have both,\n        // we use pts: Infinity for the missing tag. The will force the following Math.min\n        // call will to use the proper pts value since it will always be less than Infinity\n        var firstVideoTag = videoTags[0] || {\n          pts: Infinity\n        };\n        var firstAudioTag = audioTags[0] || {\n          pts: Infinity\n        };\n        this.basePtsOffset_ = Math.min(firstAudioTag.pts, firstVideoTag.pts);\n      }\n      if (tech.seeking()) {\n        // Do not use previously saved buffer end values while seeking since buffer\n        // is cleared on all seeks\n        this.videoBufferEnd_ = NaN;\n        this.audioBufferEnd_ = NaN;\n      }\n      if (isNaN(this.videoBufferEnd_)) {\n        if (tech.buffered().length) {\n          videoTargetPts = tech.buffered().end(0) - this.timestampOffset;\n        }\n\n        // Trim to currentTime if seeking\n        if (tech.seeking()) {\n          videoTargetPts = Math.max(videoTargetPts, tech.currentTime() - this.timestampOffset);\n        }\n\n        // PTS values are represented in milliseconds\n        videoTargetPts *= 1e3;\n        videoTargetPts += this.basePtsOffset_;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        videoTargetPts = this.videoBufferEnd_ + 0.1;\n      }\n\n      // filter complete GOPs with a presentation time less than the seek target/end of buffer\n      var currentIndex = videoTags.length;\n\n      // if the last tag is beyond videoTargetPts, then do not search the list for a GOP\n      // since our videoTargetPts lies in a future segment\n      if (currentIndex && videoTags[currentIndex - 1].pts >= videoTargetPts) {\n        // Start by walking backwards from the end of the list until we reach a tag that\n        // is equal to or less than videoTargetPts\n        while (--currentIndex) {\n          var currentTag = videoTags[currentIndex];\n          if (currentTag.pts > videoTargetPts) {\n            continue;\n          }\n\n          // if we see a keyFrame or metadata tag once we've gone below videoTargetPts,\n          // exit the loop as this is the start of the GOP that we want to append\n          if (currentTag.keyFrame || currentTag.metaDataTag) {\n            break;\n          }\n        }\n\n        // We need to check if there are any metadata tags that come before currentIndex\n        // as those will be metadata tags associated with the GOP we are appending\n        // There could be 0 to 2 metadata tags that come before the currentIndex depending\n        // on what videoTargetPts is and whether the transmuxer prepended metadata tags to this\n        // key frame\n        while (currentIndex) {\n          var nextTag = videoTags[currentIndex - 1];\n          if (!nextTag.metaDataTag) {\n            break;\n          }\n          currentIndex--;\n        }\n      }\n      var filteredVideoTags = videoTags.slice(currentIndex);\n      var audioTargetPts = undefined;\n      if (isNaN(this.audioBufferEnd_)) {\n        audioTargetPts = videoTargetPts;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        audioTargetPts = this.audioBufferEnd_ + 0.1;\n      }\n      if (filteredVideoTags.length) {\n        // If targetPts intersects a GOP and we appended the tags for the GOP that came\n        // before targetPts, we want to make sure to trim audio tags at the pts\n        // of the first video tag to avoid brief moments of silence\n        audioTargetPts = Math.min(audioTargetPts, filteredVideoTags[0].pts);\n      }\n\n      // skip tags with a presentation time less than the seek target/end of buffer\n      currentIndex = 0;\n      while (currentIndex < audioTags.length) {\n        if (audioTags[currentIndex].pts >= audioTargetPts) {\n          break;\n        }\n        currentIndex++;\n      }\n      var filteredAudioTags = audioTags.slice(currentIndex);\n\n      // update the audio and video buffer ends\n      if (filteredAudioTags.length) {\n        this.audioBufferEnd_ = filteredAudioTags[filteredAudioTags.length - 1].pts;\n      }\n      if (filteredVideoTags.length) {\n        this.videoBufferEnd_ = filteredVideoTags[filteredVideoTags.length - 1].pts;\n      }\n      var tags = this.getOrderedTags_(filteredVideoTags, filteredAudioTags);\n      if (tags.length === 0) {\n        return;\n      }\n\n      // If we are appending data that comes before our target pts, we want to tell\n      // the swf to adjust its notion of current time to account for the extra tags\n      // we are appending to complete the GOP that intersects with targetPts\n      if (tags[0].pts < videoTargetPts && tech.seeking()) {\n        var fudgeFactor = 1 / 30;\n        var currentTime = tech.currentTime();\n        var diff = (videoTargetPts - tags[0].pts) / 1e3;\n        var adjustedTime = currentTime - diff;\n        if (adjustedTime < fudgeFactor) {\n          adjustedTime = 0;\n        }\n        try {\n          this.mediaSource_.swfObj.vjs_adjustCurrentTime(adjustedTime);\n        } catch (e) {\n          // no-op for backwards compatability of swf. If adjustCurrentTime fails,\n          // the swf may incorrectly report currentTime and buffered ranges\n          // but should not affect playback over than the time displayed on the\n          // progress bar is inaccurate\n        }\n      }\n\n      // concatenate the bytes into a single segment\n      for (var i = 0; i < tags.length; i++) {\n        segmentByteLength += tags[i].bytes.byteLength;\n      }\n      segment = new Uint8Array(segmentByteLength);\n      for (var i = 0, j = 0; i < tags.length; i++) {\n        segment.set(tags[i].bytes, j);\n        j += tags[i].bytes.byteLength;\n      }\n      return segment;\n    }\n\n    /**\n     * Assemble the FLV tags in decoder order.\n     *\n     * @private\n     * @param {Array} videoTags list of video tags\n     * @param {Array} audioTags list of audio tags\n     */\n  }, {\n    key: 'getOrderedTags_',\n    value: function getOrderedTags_(videoTags, audioTags) {\n      var tag = undefined;\n      var tags = [];\n      while (videoTags.length || audioTags.length) {\n        if (!videoTags.length) {\n          // only audio tags remain\n          tag = audioTags.shift();\n        } else if (!audioTags.length) {\n          // only video tags remain\n          tag = videoTags.shift();\n        } else if (audioTags[0].dts < videoTags[0].dts) {\n          // audio should be decoded next\n          tag = audioTags.shift();\n        } else {\n          // video should be decoded next\n          tag = videoTags.shift();\n        }\n        tags.push(tag);\n      }\n      return tags;\n    }\n  }, {\n    key: 'onHlsReset_',\n    value: function onHlsReset_() {\n      this.transmuxer_.postMessage({\n        action: 'resetCaptions'\n      });\n    }\n  }]);\n  return FlashSourceBuffer;\n}(_videoJs2['default'].EventTarget);\nexports['default'] = FlashSourceBuffer;\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x","_x2","_x3","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_globalWindow","require","_globalWindow2","_videoJs","_videoJs2","_muxJsLibFlv","_muxJsLibFlv2","_removeCuesFromTrack","_removeCuesFromTrack2","_createTextTracksIfNecessary","_createTextTracksIfNecessary2","_addTextTrackData","_flashTransmuxerWorker","_flashTransmuxerWorker2","_webwackify","_webwackify2","_flashConstants","_flashConstants2","resolveFlashTransmuxWorker","result","resolve","e","scheduleTick","func","setTimeout","TIME_BETWEEN_CHUNKS","generateRandomString","Math","random","toString","slice","toDecimalPlaces","num","places","scale","pow","round","FlashSourceBuffer","_videojs$EventTarget","mediaSource","_this","encodedHeader","chunkSize_","BYTES_PER_CHUNK","buffer_","bufferSize_","basePtsOffset_","NaN","mediaSource_","audioBufferEnd_","videoBufferEnd_","updating","timestampOffset_","btoa","String","fromCharCode","apply","Array","getFlvHeader","safePlayerId","player_","id","replace","flashEncodedHeaderName_","flashEncodedDataName_","swfObj","vjs_appendChunkReady","transmuxer_","postMessage","action","options","onmessage","event","data","receiveBuffer_","segment","one","tech_","trigger","set","val","vjs_discontinuity","createTimeRange","buffered","vjs_getProperty","createTimeRanges","on","Infinity","metadataTrack_","inbandTextTracks_","track","onHlsReset","onHlsReset_","bind","hls","terminate","off","appendBuffer","bytes","error","Error","name","code","readyState","type","buffer","byteOffset","byteLength","abort","vjs_abort","remove","start","end","_this2","addTextTrackData","captions","metadata","flvBytes","convertTagsToData_","processBuffer_","push","_this3","chunkSize","chunk","subarray","shift","binary","b64str","join","segmentData","segmentByteLength","tech","videoTargetPts","videoTags","tags","audioTags","isNaN","firstVideoTag","pts","firstAudioTag","min","seeking","timestampOffset","max","currentTime","currentIndex","currentTag","keyFrame","metaDataTag","nextTag","filteredVideoTags","audioTargetPts","filteredAudioTags","getOrderedTags_","fudgeFactor","diff","adjustedTime","vjs_adjustCurrentTime","Uint8Array","j","tag","dts","EventTarget","module"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/es5/flash-source-buffer.js"],"sourcesContent":["/**\n * @file flash-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _muxJsLibFlv = require('mux.js/lib/flv');\n\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\n\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _addTextTrackData = require('./add-text-track-data');\n\nvar _flashTransmuxerWorker = require('./flash-transmuxer-worker');\n\nvar _flashTransmuxerWorker2 = _interopRequireDefault(_flashTransmuxerWorker);\n\nvar _webwackify = require('webwackify');\n\nvar _webwackify2 = _interopRequireDefault(_webwackify);\n\nvar _flashConstants = require('./flash-constants');\n\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\n\nvar resolveFlashTransmuxWorker = function resolveFlashTransmuxWorker() {\n  var result = undefined;\n\n  try {\n    result = require.resolve('./flash-transmuxer-worker');\n  } catch (e) {\n    // no result\n  }\n\n  return result;\n};\n\n/**\n * A wrapper around the setTimeout function that uses\n * the flash constant time between ticks value.\n *\n * @param {Function} func the function callback to run\n * @private\n */\nvar scheduleTick = function scheduleTick(func) {\n  // Chrome doesn't invoke requestAnimationFrame callbacks\n  // in background tabs, so use setTimeout.\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_CHUNKS);\n};\n\n/**\n * Generates a random string of max length 6\n *\n * @return {String} the randomly generated string\n * @function generateRandomString\n * @private\n */\nvar generateRandomString = function generateRandomString() {\n  return Math.random().toString(36).slice(2, 8);\n};\n\n/**\n * Round a number to a specified number of places much like\n * toFixed but return a number instead of a string representation.\n *\n * @param {Number} num A number\n * @param {Number} places The number of decimal places which to\n * round\n * @private\n */\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\n  if (typeof places !== 'number' || places < 0) {\n    places = 0;\n  }\n\n  var scale = Math.pow(10, places);\n\n  return Math.round(num * scale) / scale;\n};\n\n/**\n * A SourceBuffer implementation for Flash rather than HTML.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @param {Object} mediaSource the flash media source\n * @class FlashSourceBuffer\n * @extends videojs.EventTarget\n */\n\nvar FlashSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\n\n  function FlashSourceBuffer(mediaSource) {\n    var _this = this;\n\n    _classCallCheck(this, FlashSourceBuffer);\n\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\n    var encodedHeader = undefined;\n\n    // Start off using the globally defined value but refine\n    // as we append data into flash\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n    // byte arrays queued to be appended\n    this.buffer_ = [];\n\n    // the total number of queued bytes\n    this.bufferSize_ = 0;\n\n    // to be able to determine the correct position to seek to, we\n    // need to retain information about the mapping between the\n    // media timeline and PTS values\n    this.basePtsOffset_ = NaN;\n\n    this.mediaSource_ = mediaSource;\n\n    this.audioBufferEnd_ = NaN;\n    this.videoBufferEnd_ = NaN;\n\n    // indicates whether the asynchronous continuation of an operation\n    // is still being processed\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\n    this.updating = false;\n    this.timestampOffset_ = 0;\n\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(_muxJsLibFlv2['default'].getFlvHeader())));\n\n    // create function names with added randomness for the global callbacks flash will use\n    // to get data from javascript into the swf. Random strings are added as a safety\n    // measure for pages with multiple players since these functions will be global\n    // instead of per instance. When making a call to the swf, the browser generates a\n    // try catch code snippet, but just takes the function name and writes out an unquoted\n    // call to that function. If the player id has any special characters, this will result\n    // in an error, so safePlayerId replaces all special characters to '_'\n    var safePlayerId = this.mediaSource_.player_.id().replace(/[^a-zA-Z0-9]/g, '_');\n\n    this.flashEncodedHeaderName_ = 'vjs_flashEncodedHeader_' + safePlayerId + generateRandomString();\n    this.flashEncodedDataName_ = 'vjs_flashEncodedData_' + safePlayerId + generateRandomString();\n\n    _globalWindow2['default'][this.flashEncodedHeaderName_] = function () {\n      delete _globalWindow2['default'][_this.flashEncodedHeaderName_];\n      return encodedHeader;\n    };\n\n    this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedHeaderName_);\n\n    this.transmuxer_ = (0, _webwackify2['default'])(_flashTransmuxerWorker2['default'], resolveFlashTransmuxWorker());\n    this.transmuxer_.postMessage({ action: 'init', options: {} });\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        _this.receiveBuffer_(event.data.segment);\n      }\n    };\n\n    this.one('updateend', function () {\n      _this.mediaSource_.tech_.trigger('loadedmetadata');\n    });\n\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          // We have to tell flash to expect a discontinuity\n          this.mediaSource_.swfObj.vjs_discontinuity();\n          // the media <-> PTS mapping must be re-established after\n          // the discontinuity\n          this.basePtsOffset_ = NaN;\n          this.audioBufferEnd_ = NaN;\n          this.videoBufferEnd_ = NaN;\n\n          this.transmuxer_.postMessage({ action: 'reset' });\n        }\n      }\n    });\n\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        if (!this.mediaSource_ || !this.mediaSource_.swfObj || !('vjs_getProperty' in this.mediaSource_.swfObj)) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        var buffered = this.mediaSource_.swfObj.vjs_getProperty('buffered');\n\n        if (buffered && buffered.length) {\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\n        }\n        return _videoJs2['default'].createTimeRanges(buffered);\n      }\n    });\n\n    // On a seek we remove all text track data since flash has no concept\n    // of a buffered-range and everything else is reset on seek\n    this.mediaSource_.player_.on('seeked', function () {\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\n      if (_this.inbandTextTracks_) {\n        for (var track in _this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTracks_[track]);\n        }\n      }\n    });\n\n    var onHlsReset = this.onHlsReset_.bind(this);\n\n    // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n    // resets its state and flushes the buffer\n    this.mediaSource_.player_.tech_.on('hls-reset', onHlsReset);\n\n    this.mediaSource_.player_.tech_.hls.on('dispose', function () {\n      _this.transmuxer_.terminate();\n      _this.mediaSource_.player_.tech_.off('hls-reset', onHlsReset);\n    });\n  }\n\n  /**\n   * Append bytes to the sourcebuffers buffer, in this case we\n   * have to append it to swf object.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n   * @param {Array} bytes\n   */\n\n  _createClass(FlashSourceBuffer, [{\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes) {\n      var error = undefined;\n\n      if (this.updating) {\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n      this.updating = true;\n      this.mediaSource_.readyState = 'open';\n      this.trigger({ type: 'update' });\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        data: bytes.buffer,\n        byteOffset: bytes.byteOffset,\n        byteLength: bytes.byteLength\n      }, [bytes.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Reset the parser and remove any data queued to be sent to the SWF.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      this.buffer_ = [];\n      this.bufferSize_ = 0;\n      this.mediaSource_.swfObj.vjs_abort();\n\n      // report any outstanding updates have ended\n      if (this.updating) {\n        this.updating = false;\n        this.trigger({ type: 'updateend' });\n      }\n    }\n\n    /**\n     * Flash cannot remove ranges already buffered in the NetStream\n     * but seeking clears the buffer entirely. For most purposes,\n     * having this operation act as a no-op is acceptable.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start start of the section to remove\n     * @param {Double} end end of the section to remove\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n      this.trigger({ type: 'update' });\n      this.trigger({ type: 'updateend' });\n    }\n\n    /**\n     * Receive a buffer from the flv.\n     *\n     * @param {Object} segment\n     * @private\n     */\n  }, {\n    key: 'receiveBuffer_',\n    value: function receiveBuffer_(segment) {\n      var _this2 = this;\n\n      // create an in-band caption track if one is present in the segment\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n      (0, _addTextTrackData.addTextTrackData)(this, segment.captions, segment.metadata);\n\n      // Do this asynchronously since convertTagsToData_ can be time consuming\n      scheduleTick(function () {\n        var flvBytes = _this2.convertTagsToData_(segment);\n\n        if (_this2.buffer_.length === 0) {\n          scheduleTick(_this2.processBuffer_.bind(_this2));\n        }\n\n        if (flvBytes) {\n          _this2.buffer_.push(flvBytes);\n          _this2.bufferSize_ += flvBytes.byteLength;\n        }\n      });\n    }\n\n    /**\n     * Append a portion of the current buffer to the SWF.\n     *\n     * @private\n     */\n  }, {\n    key: 'processBuffer_',\n    value: function processBuffer_() {\n      var _this3 = this;\n\n      var chunkSize = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n      if (!this.buffer_.length) {\n        if (this.updating !== false) {\n          this.updating = false;\n          this.trigger({ type: 'updateend' });\n        }\n        // do nothing if the buffer is empty\n        return;\n      }\n\n      // concatenate appends up to the max append size\n      var chunk = this.buffer_[0].subarray(0, chunkSize);\n\n      // requeue any bytes that won't make it this round\n      if (chunk.byteLength < chunkSize || this.buffer_[0].byteLength === chunkSize) {\n        this.buffer_.shift();\n      } else {\n        this.buffer_[0] = this.buffer_[0].subarray(chunkSize);\n      }\n\n      this.bufferSize_ -= chunk.byteLength;\n\n      // base64 encode the bytes\n      var binary = [];\n      var length = chunk.byteLength;\n\n      for (var i = 0; i < length; i++) {\n        binary.push(String.fromCharCode(chunk[i]));\n      }\n      var b64str = _globalWindow2['default'].btoa(binary.join(''));\n\n      _globalWindow2['default'][this.flashEncodedDataName_] = function () {\n        // schedule another processBuffer to process any left over data or to\n        // trigger updateend\n        scheduleTick(_this3.processBuffer_.bind(_this3));\n        delete _globalWindow2['default'][_this3.flashEncodedDataName_];\n        return b64str;\n      };\n\n      // Notify the swf that segment data is ready to be appended\n      this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedDataName_);\n    }\n\n    /**\n     * Turns an array of flv tags into a Uint8Array representing the\n     * flv data. Also removes any tags that are before the current\n     * time so that playback begins at or slightly after the right\n     * place on a seek\n     *\n     * @private\n     * @param {Object} segmentData object of segment data\n     */\n  }, {\n    key: 'convertTagsToData_',\n    value: function convertTagsToData_(segmentData) {\n      var segmentByteLength = 0;\n      var tech = this.mediaSource_.tech_;\n      var videoTargetPts = 0;\n      var segment = undefined;\n      var videoTags = segmentData.tags.videoTags;\n      var audioTags = segmentData.tags.audioTags;\n\n      // Establish the media timeline to PTS translation if we don't\n      // have one already\n      if (isNaN(this.basePtsOffset_) && (videoTags.length || audioTags.length)) {\n        // We know there is at least one video or audio tag, but since we may not have both,\n        // we use pts: Infinity for the missing tag. The will force the following Math.min\n        // call will to use the proper pts value since it will always be less than Infinity\n        var firstVideoTag = videoTags[0] || { pts: Infinity };\n        var firstAudioTag = audioTags[0] || { pts: Infinity };\n\n        this.basePtsOffset_ = Math.min(firstAudioTag.pts, firstVideoTag.pts);\n      }\n\n      if (tech.seeking()) {\n        // Do not use previously saved buffer end values while seeking since buffer\n        // is cleared on all seeks\n        this.videoBufferEnd_ = NaN;\n        this.audioBufferEnd_ = NaN;\n      }\n\n      if (isNaN(this.videoBufferEnd_)) {\n        if (tech.buffered().length) {\n          videoTargetPts = tech.buffered().end(0) - this.timestampOffset;\n        }\n\n        // Trim to currentTime if seeking\n        if (tech.seeking()) {\n          videoTargetPts = Math.max(videoTargetPts, tech.currentTime() - this.timestampOffset);\n        }\n\n        // PTS values are represented in milliseconds\n        videoTargetPts *= 1e3;\n        videoTargetPts += this.basePtsOffset_;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        videoTargetPts = this.videoBufferEnd_ + 0.1;\n      }\n\n      // filter complete GOPs with a presentation time less than the seek target/end of buffer\n      var currentIndex = videoTags.length;\n\n      // if the last tag is beyond videoTargetPts, then do not search the list for a GOP\n      // since our videoTargetPts lies in a future segment\n      if (currentIndex && videoTags[currentIndex - 1].pts >= videoTargetPts) {\n        // Start by walking backwards from the end of the list until we reach a tag that\n        // is equal to or less than videoTargetPts\n        while (--currentIndex) {\n          var currentTag = videoTags[currentIndex];\n\n          if (currentTag.pts > videoTargetPts) {\n            continue;\n          }\n\n          // if we see a keyFrame or metadata tag once we've gone below videoTargetPts,\n          // exit the loop as this is the start of the GOP that we want to append\n          if (currentTag.keyFrame || currentTag.metaDataTag) {\n            break;\n          }\n        }\n\n        // We need to check if there are any metadata tags that come before currentIndex\n        // as those will be metadata tags associated with the GOP we are appending\n        // There could be 0 to 2 metadata tags that come before the currentIndex depending\n        // on what videoTargetPts is and whether the transmuxer prepended metadata tags to this\n        // key frame\n        while (currentIndex) {\n          var nextTag = videoTags[currentIndex - 1];\n\n          if (!nextTag.metaDataTag) {\n            break;\n          }\n\n          currentIndex--;\n        }\n      }\n\n      var filteredVideoTags = videoTags.slice(currentIndex);\n\n      var audioTargetPts = undefined;\n\n      if (isNaN(this.audioBufferEnd_)) {\n        audioTargetPts = videoTargetPts;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        audioTargetPts = this.audioBufferEnd_ + 0.1;\n      }\n\n      if (filteredVideoTags.length) {\n        // If targetPts intersects a GOP and we appended the tags for the GOP that came\n        // before targetPts, we want to make sure to trim audio tags at the pts\n        // of the first video tag to avoid brief moments of silence\n        audioTargetPts = Math.min(audioTargetPts, filteredVideoTags[0].pts);\n      }\n\n      // skip tags with a presentation time less than the seek target/end of buffer\n      currentIndex = 0;\n\n      while (currentIndex < audioTags.length) {\n        if (audioTags[currentIndex].pts >= audioTargetPts) {\n          break;\n        }\n\n        currentIndex++;\n      }\n\n      var filteredAudioTags = audioTags.slice(currentIndex);\n\n      // update the audio and video buffer ends\n      if (filteredAudioTags.length) {\n        this.audioBufferEnd_ = filteredAudioTags[filteredAudioTags.length - 1].pts;\n      }\n      if (filteredVideoTags.length) {\n        this.videoBufferEnd_ = filteredVideoTags[filteredVideoTags.length - 1].pts;\n      }\n\n      var tags = this.getOrderedTags_(filteredVideoTags, filteredAudioTags);\n\n      if (tags.length === 0) {\n        return;\n      }\n\n      // If we are appending data that comes before our target pts, we want to tell\n      // the swf to adjust its notion of current time to account for the extra tags\n      // we are appending to complete the GOP that intersects with targetPts\n      if (tags[0].pts < videoTargetPts && tech.seeking()) {\n        var fudgeFactor = 1 / 30;\n        var currentTime = tech.currentTime();\n        var diff = (videoTargetPts - tags[0].pts) / 1e3;\n        var adjustedTime = currentTime - diff;\n\n        if (adjustedTime < fudgeFactor) {\n          adjustedTime = 0;\n        }\n\n        try {\n          this.mediaSource_.swfObj.vjs_adjustCurrentTime(adjustedTime);\n        } catch (e) {\n          // no-op for backwards compatability of swf. If adjustCurrentTime fails,\n          // the swf may incorrectly report currentTime and buffered ranges\n          // but should not affect playback over than the time displayed on the\n          // progress bar is inaccurate\n        }\n      }\n\n      // concatenate the bytes into a single segment\n      for (var i = 0; i < tags.length; i++) {\n        segmentByteLength += tags[i].bytes.byteLength;\n      }\n      segment = new Uint8Array(segmentByteLength);\n      for (var i = 0, j = 0; i < tags.length; i++) {\n        segment.set(tags[i].bytes, j);\n        j += tags[i].bytes.byteLength;\n      }\n\n      return segment;\n    }\n\n    /**\n     * Assemble the FLV tags in decoder order.\n     *\n     * @private\n     * @param {Array} videoTags list of video tags\n     * @param {Array} audioTags list of audio tags\n     */\n  }, {\n    key: 'getOrderedTags_',\n    value: function getOrderedTags_(videoTags, audioTags) {\n      var tag = undefined;\n      var tags = [];\n\n      while (videoTags.length || audioTags.length) {\n        if (!videoTags.length) {\n          // only audio tags remain\n          tag = audioTags.shift();\n        } else if (!audioTags.length) {\n          // only video tags remain\n          tag = videoTags.shift();\n        } else if (audioTags[0].dts < videoTags[0].dts) {\n          // audio should be decoded next\n          tag = audioTags.shift();\n        } else {\n          // video should be decoded next\n          tag = videoTags.shift();\n        }\n\n        tags.push(tag);\n      }\n\n      return tags;\n    }\n  }, {\n    key: 'onHlsReset_',\n    value: function onHlsReset_() {\n      this.transmuxer_.postMessage({ action: 'resetCaptions' });\n    }\n  }]);\n\n  return FlashSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = FlashSourceBuffer;\nmodule.exports = exports['default'];"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}