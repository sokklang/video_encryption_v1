{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _playlistLoader = require('./playlist-loader');\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\nvar noop = function noop() {};\n\n/**\n * Convert the properties of an HLS track into an audioTrackKind.\n *\n * @private\n */\nvar audioTrackKind_ = function audioTrackKind_(properties) {\n  var kind = properties['default'] ? 'main' : 'alternative';\n  if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n    kind = 'main-desc';\n  }\n  return kind;\n};\n\n/**\n * Pause provided segment loader and playlist loader if active\n *\n * @param {SegmentLoader} segmentLoader\n *        SegmentLoader to pause\n * @param {Object} mediaType\n *        Active media type\n * @function stopLoaders\n */\nvar stopLoaders = function stopLoaders(segmentLoader, mediaType) {\n  segmentLoader.abort();\n  segmentLoader.pause();\n  if (mediaType && mediaType.activePlaylistLoader) {\n    mediaType.activePlaylistLoader.pause();\n    mediaType.activePlaylistLoader = null;\n  }\n};\nexports.stopLoaders = stopLoaders;\n/**\n * Start loading provided segment loader and playlist loader\n *\n * @param {PlaylistLoader} playlistLoader\n *        PlaylistLoader to start loading\n * @param {Object} mediaType\n *        Active media type\n * @function startLoaders\n */\nvar startLoaders = function startLoaders(playlistLoader, mediaType) {\n  // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n  // playlist loader\n  mediaType.activePlaylistLoader = playlistLoader;\n  playlistLoader.load();\n};\nexports.startLoaders = startLoaders;\n/**\n * Returns a function to be called when the media group changes. It performs a\n * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n * change of group is merely a rendition switch of the same content at another encoding,\n * rather than a change of content, such as switching audio from English to Spanish.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a non-destructive resync of SegmentLoader when the active media\n *         group changes.\n * @function onGroupChanged\n */\nvar onGroupChanged = function onGroupChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders[type];\n    var mainSegmentLoader = _settings$segmentLoaders.main;\n    var mediaType = settings.mediaTypes[type];\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n    stopLoaders(segmentLoader, mediaType);\n    if (!activeGroup) {\n      // there is no group active\n      return;\n    }\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n      return;\n    }\n\n    // Non-destructive resync\n    segmentLoader.resyncLoader();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\nexports.onGroupChanged = onGroupChanged;\n/**\n * Returns a function to be called when the media track changes. It performs a\n * destructive reset of the SegmentLoader to ensure we start loading as close to\n * currentTime as possible.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a destructive reset of SegmentLoader when the active media\n *         track changes.\n * @function onTrackChanged\n */\nvar onTrackChanged = function onTrackChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders2 = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders2[type];\n    var mainSegmentLoader = _settings$segmentLoaders2.main;\n    var mediaType = settings.mediaTypes[type];\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n    stopLoaders(segmentLoader, mediaType);\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n    if (!activeGroup.playlistLoader) {\n      // when switching from demuxed audio/video to muxed audio/video (noted by no playlist\n      // loader for the audio group), we want to do a destructive reset of the main segment\n      // loader and not restart the audio loaders\n      mainSegmentLoader.resetEverything();\n      return;\n    }\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    }\n\n    // destructive reset\n    segmentLoader.resetEverything();\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\nexports.onTrackChanged = onTrackChanged;\nvar onError = {\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning (or error if the playlist is blacklisted) to\n   *         console and switches back to default audio track.\n   * @function onError.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n      var blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\n      stopLoaders(segmentLoader, mediaType);\n\n      // switch back to default audio track\n      var activeTrack = mediaType.activeTrack();\n      var activeGroup = mediaType.activeGroup();\n      var id = (activeGroup.filter(function (group) {\n        return group['default'];\n      })[0] || activeGroup[0]).id;\n      var defaultTrack = mediaType.tracks[id];\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is blacklist the current\n        // rendition and hope another will switch audio groups\n        blacklistCurrentPlaylist({\n          message: 'Problem encountered loading the default audio track.'\n        });\n        return;\n      }\n      _videoJs2['default'].log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n      for (var trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n      mediaType.onTrackChanged();\n    };\n  },\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning to console and disables the active subtitle track\n   * @function onError.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n      _videoJs2['default'].log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n      stopLoaders(segmentLoader, mediaType);\n      var track = mediaType.activeTrack();\n      if (track) {\n        track.mode = 'disabled';\n      }\n      mediaType.onTrackChanged();\n    };\n  }\n};\nexports.onError = onError;\nvar setupListeners = {\n  /**\n   * Setup event listeners for audio playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.AUDIO\n   */\n  AUDIO: function AUDIO(type, playlistLoader, settings) {\n    if (!playlistLoader) {\n      // no playlist loader means audio will be muxed with the video\n      return;\n    }\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n      segmentLoader.playlist(media, requestOptions);\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup event listeners for subtitle playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n    var mediaType = settings.mediaTypes[type];\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n      segmentLoader.playlist(media, requestOptions);\n      segmentLoader.track(mediaType.activeTrack());\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n    playlistLoader.on('error', onError[type](type, settings));\n  }\n};\nexports.setupListeners = setupListeners;\nvar initialize = {\n  /**\n   * Setup PlaylistLoaders and AudioTracks for the audio groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.AUDIO\n   */\n  'AUDIO': function AUDIO(type, settings) {\n    var mode = settings.mode;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var requestOptions = settings.requestOptions;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type.groups;\n    var tracks = _settings$mediaTypes$type.tracks;\n\n    // force a default if we have none or we are not\n    // in html5 mode (the only mode to support more than one\n    // audio track)\n    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0 || mode !== 'html5') {\n      mediaGroups[type] = {\n        main: {\n          'default': {\n            'default': true\n          }\n        }\n      };\n    }\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n        var playlistLoader = undefined;\n        if (properties.resolvedUri) {\n          playlistLoader = new _playlistLoader2['default'](properties.resolvedUri, hls, requestOptions);\n        } else {\n          // no resolvedUri means the audio is muxed with the video when using this\n          // audio track\n          playlistLoader = null;\n        }\n        properties = _videoJs2['default'].mergeOptions({\n          id: variantLabel,\n          playlistLoader: playlistLoader\n        }, properties);\n        setupListeners[type](type, properties.playlistLoader, settings);\n        groups[groupId].push(properties);\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = new _videoJs2['default'].AudioTrack({\n            id: variantLabel,\n            kind: audioTrackKind_(properties),\n            enabled: false,\n            language: properties.language,\n            'default': properties['default'],\n            label: variantLabel\n          });\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup PlaylistLoaders and TextTracks for the subtitle groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.SUBTITLES\n   */\n  'SUBTITLES': function SUBTITLES(type, settings) {\n    var tech = settings.tech;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var requestOptions = settings.requestOptions;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type2 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type2.groups;\n    var tracks = _settings$mediaTypes$type2.tracks;\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        if (mediaGroups[type][groupId][variantLabel].forced) {\n          // Subtitle playlists with the forced attribute are not selectable in Safari.\n          // According to Apple's HLS Authoring Specification:\n          //   If content has forced subtitles and regular subtitles in a given language,\n          //   the regular subtitles track in that language MUST contain both the forced\n          //   subtitles and the regular subtitles for that language.\n          // Because of this requirement and that Safari does not add forced subtitles,\n          // forced subtitles are skipped here to maintain consistent experience across\n          // all platforms\n          continue;\n        }\n        var properties = mediaGroups[type][groupId][variantLabel];\n        properties = _videoJs2['default'].mergeOptions({\n          id: variantLabel,\n          playlistLoader: new _playlistLoader2['default'](properties.resolvedUri, hls, requestOptions)\n        }, properties);\n        setupListeners[type](type, properties.playlistLoader, settings);\n        groups[groupId].push(properties);\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: variantLabel,\n            kind: 'subtitles',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup TextTracks for the closed-caption groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize['CLOSED-CAPTIONS']\n   */\n  'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\n    var tech = settings.tech;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type3 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type3.groups;\n    var tracks = _settings$mediaTypes$type3.tracks;\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        // We only support CEA608 captions for now, so ignore anything that\n        // doesn't use a CCx INSTREAM-ID\n        if (!properties.instreamId.match(/CC\\d/)) {\n          continue;\n        }\n\n        // No PlaylistLoader is required for Closed-Captions because the captions are\n        // embedded within the video stream\n        groups[groupId].push(_videoJs2['default'].mergeOptions({\n          id: variantLabel\n        }, properties));\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: properties.instreamId,\n            kind: 'captions',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n  }\n};\nexports.initialize = initialize;\n/**\n * Returns a function used to get the active group of the provided type\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Function that returns the active media group for the provided type. Takes an\n *         optional parameter {TextTrack} track. If no track is provided, a list of all\n *         variants in the group, otherwise the variant corresponding to the provided\n *         track is returned.\n * @function activeGroup\n */\nvar activeGroup = function activeGroup(type, settings) {\n  return function (track) {\n    var masterPlaylistLoader = settings.masterPlaylistLoader;\n    var groups = settings.mediaTypes[type].groups;\n    var media = masterPlaylistLoader.media();\n    if (!media) {\n      return null;\n    }\n    var variants = null;\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n    variants = variants || groups.main;\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n    if (track === null) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n    return variants.filter(function (props) {\n      return props.id === track.id;\n    })[0] || null;\n  };\n};\nexports.activeGroup = activeGroup;\nvar activeTrack = {\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n      for (var id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n      return null;\n    };\n  },\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n      for (var id in tracks) {\n        if (tracks[id].mode === 'showing') {\n          return tracks[id];\n        }\n      }\n      return null;\n    };\n  }\n};\nexports.activeTrack = activeTrack;\n/**\n * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n * Closed-Captions) specified in the master manifest.\n *\n * @param {Object} settings\n *        Object containing required information for setting up the media groups\n * @param {SegmentLoader} settings.segmentLoaders.AUDIO\n *        Audio segment loader\n * @param {SegmentLoader} settings.segmentLoaders.SUBTITLES\n *        Subtitle segment loader\n * @param {SegmentLoader} settings.segmentLoaders.main\n *        Main segment loader\n * @param {Tech} settings.tech\n *        The tech of the player\n * @param {Object} settings.requestOptions\n *        XHR request options used by the segment loaders\n * @param {PlaylistLoader} settings.masterPlaylistLoader\n *        PlaylistLoader for the master source\n * @param {String} mode\n *        Mode of the hls source handler. Can be 'auto', 'html5', or 'flash'\n * @param {HlsHandler} settings.hls\n *        HLS SourceHandler\n * @param {Object} settings.master\n *        The parsed master manifest\n * @param {Object} settings.mediaTypes\n *        Object to store the loaders, tracks, and utility methods for each media type\n * @param {Function} settings.blacklistCurrentPlaylist\n *        Blacklists the current rendition and forces a rendition switch.\n * @function setupMediaGroups\n */\nvar setupMediaGroups = function setupMediaGroups(settings) {\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    initialize[type](type, settings);\n  });\n  var mediaTypes = settings.mediaTypes;\n  var masterPlaylistLoader = settings.masterPlaylistLoader;\n  var tech = settings.tech;\n  var hls = settings.hls;\n\n  // setup active group and track getters and change event handlers\n  ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n    mediaTypes[type].activeGroup = activeGroup(type, settings);\n    mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n    mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n    mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n  });\n\n  // DO NOT enable the default subtitle or caption track.\n  // DO enable the default audio track\n  var audioGroup = mediaTypes.AUDIO.activeGroup();\n  var groupId = (audioGroup.filter(function (group) {\n    return group['default'];\n  })[0] || audioGroup[0]).id;\n  mediaTypes.AUDIO.tracks[groupId].enabled = true;\n  mediaTypes.AUDIO.onTrackChanged();\n  masterPlaylistLoader.on('mediachange', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanged();\n    });\n  });\n\n  // custom audio track change event handler for usage event\n  var onAudioTrackChanged = function onAudioTrackChanged() {\n    mediaTypes.AUDIO.onTrackChanged();\n    tech.trigger({\n      type: 'usage',\n      name: 'hls-audio-change'\n    });\n  };\n  tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n  tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  hls.on('dispose', function () {\n    tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  });\n\n  // clear existing audio tracks and add the ones we just created\n  tech.clearTracks('audio');\n  for (var id in mediaTypes.AUDIO.tracks) {\n    tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n  }\n};\nexports.setupMediaGroups = setupMediaGroups;\n/**\n * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n * media type\n *\n * @return {Object}\n *         Object to store the loaders, tracks, and utility methods for each media type\n * @function createMediaTypes\n */\nvar createMediaTypes = function createMediaTypes() {\n  var mediaTypes = {};\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    mediaTypes[type] = {\n      groups: {},\n      tracks: {},\n      activePlaylistLoader: null,\n      activeGroup: noop,\n      activeTrack: noop,\n      onGroupChanged: noop,\n      onTrackChanged: noop\n    };\n  });\n  return mediaTypes;\n};\nexports.createMediaTypes = createMediaTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_videoJs","require","_videoJs2","_playlistLoader","_playlistLoader2","noop","audioTrackKind_","properties","kind","characteristics","indexOf","stopLoaders","segmentLoader","mediaType","abort","pause","activePlaylistLoader","startLoaders","playlistLoader","load","onGroupChanged","type","settings","_settings$segmentLoaders","segmentLoaders","mainSegmentLoader","main","mediaTypes","activeTrack","activeGroup","previousActiveLoader","resetEverything","resyncLoader","onTrackChanged","_settings$segmentLoaders2","track","onError","AUDIO","blacklistCurrentPlaylist","id","filter","group","defaultTrack","tracks","message","log","warn","trackId","enabled","SUBTITLES","mode","setupListeners","tech","requestOptions","on","media","playlist","paused","endList","preload","initialize","hls","mediaGroups","master","_settings$mediaTypes$type","groups","keys","length","groupId","variantLabel","undefined","resolvedUri","mergeOptions","push","AudioTrack","language","label","_settings$mediaTypes$type2","forced","addRemoteTextTrack","CLOSEDCAPTIONS","_settings$mediaTypes$type3","instreamId","match","masterPlaylistLoader","variants","attributes","props","setupMediaGroups","forEach","audioGroup","onAudioTrackChanged","trigger","name","audioTracks","addEventListener","remoteTextTracks","removeEventListener","clearTracks","addTrack","createMediaTypes"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/media-groups.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _playlistLoader = require('./playlist-loader');\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar noop = function noop() {};\n\n/**\n * Convert the properties of an HLS track into an audioTrackKind.\n *\n * @private\n */\nvar audioTrackKind_ = function audioTrackKind_(properties) {\n  var kind = properties['default'] ? 'main' : 'alternative';\n\n  if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n    kind = 'main-desc';\n  }\n\n  return kind;\n};\n\n/**\n * Pause provided segment loader and playlist loader if active\n *\n * @param {SegmentLoader} segmentLoader\n *        SegmentLoader to pause\n * @param {Object} mediaType\n *        Active media type\n * @function stopLoaders\n */\nvar stopLoaders = function stopLoaders(segmentLoader, mediaType) {\n  segmentLoader.abort();\n  segmentLoader.pause();\n\n  if (mediaType && mediaType.activePlaylistLoader) {\n    mediaType.activePlaylistLoader.pause();\n    mediaType.activePlaylistLoader = null;\n  }\n};\n\nexports.stopLoaders = stopLoaders;\n/**\n * Start loading provided segment loader and playlist loader\n *\n * @param {PlaylistLoader} playlistLoader\n *        PlaylistLoader to start loading\n * @param {Object} mediaType\n *        Active media type\n * @function startLoaders\n */\nvar startLoaders = function startLoaders(playlistLoader, mediaType) {\n  // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n  // playlist loader\n  mediaType.activePlaylistLoader = playlistLoader;\n  playlistLoader.load();\n};\n\nexports.startLoaders = startLoaders;\n/**\n * Returns a function to be called when the media group changes. It performs a\n * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n * change of group is merely a rendition switch of the same content at another encoding,\n * rather than a change of content, such as switching audio from English to Spanish.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a non-destructive resync of SegmentLoader when the active media\n *         group changes.\n * @function onGroupChanged\n */\nvar onGroupChanged = function onGroupChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders[type];\n    var mainSegmentLoader = _settings$segmentLoaders.main;\n    var mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n      return;\n    }\n\n    // Non-destructive resync\n    segmentLoader.resyncLoader();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nexports.onGroupChanged = onGroupChanged;\n/**\n * Returns a function to be called when the media track changes. It performs a\n * destructive reset of the SegmentLoader to ensure we start loading as close to\n * currentTime as possible.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a destructive reset of SegmentLoader when the active media\n *         track changes.\n * @function onTrackChanged\n */\nvar onTrackChanged = function onTrackChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders2 = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders2[type];\n    var mainSegmentLoader = _settings$segmentLoaders2.main;\n    var mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      // when switching from demuxed audio/video to muxed audio/video (noted by no playlist\n      // loader for the audio group), we want to do a destructive reset of the main segment\n      // loader and not restart the audio loaders\n      mainSegmentLoader.resetEverything();\n      return;\n    }\n\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    }\n\n    // destructive reset\n    segmentLoader.resetEverything();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nexports.onTrackChanged = onTrackChanged;\nvar onError = {\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning (or error if the playlist is blacklisted) to\n   *         console and switches back to default audio track.\n   * @function onError.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n      var blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\n\n      stopLoaders(segmentLoader, mediaType);\n\n      // switch back to default audio track\n      var activeTrack = mediaType.activeTrack();\n      var activeGroup = mediaType.activeGroup();\n      var id = (activeGroup.filter(function (group) {\n        return group['default'];\n      })[0] || activeGroup[0]).id;\n      var defaultTrack = mediaType.tracks[id];\n\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is blacklist the current\n        // rendition and hope another will switch audio groups\n        blacklistCurrentPlaylist({\n          message: 'Problem encountered loading the default audio track.'\n        });\n        return;\n      }\n\n      _videoJs2['default'].log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n\n      for (var trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n\n      mediaType.onTrackChanged();\n    };\n  },\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning to console and disables the active subtitle track\n   * @function onError.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n\n      _videoJs2['default'].log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n\n      stopLoaders(segmentLoader, mediaType);\n\n      var track = mediaType.activeTrack();\n\n      if (track) {\n        track.mode = 'disabled';\n      }\n\n      mediaType.onTrackChanged();\n    };\n  }\n};\n\nexports.onError = onError;\nvar setupListeners = {\n  /**\n   * Setup event listeners for audio playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.AUDIO\n   */\n  AUDIO: function AUDIO(type, playlistLoader, settings) {\n    if (!playlistLoader) {\n      // no playlist loader means audio will be muxed with the video\n      return;\n    }\n\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup event listeners for subtitle playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n    var mediaType = settings.mediaTypes[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n      segmentLoader.track(mediaType.activeTrack());\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  }\n};\n\nexports.setupListeners = setupListeners;\nvar initialize = {\n  /**\n   * Setup PlaylistLoaders and AudioTracks for the audio groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.AUDIO\n   */\n  'AUDIO': function AUDIO(type, settings) {\n    var mode = settings.mode;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var requestOptions = settings.requestOptions;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type.groups;\n    var tracks = _settings$mediaTypes$type.tracks;\n\n    // force a default if we have none or we are not\n    // in html5 mode (the only mode to support more than one\n    // audio track)\n    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0 || mode !== 'html5') {\n      mediaGroups[type] = { main: { 'default': { 'default': true } } };\n    }\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n        var playlistLoader = undefined;\n\n        if (properties.resolvedUri) {\n          playlistLoader = new _playlistLoader2['default'](properties.resolvedUri, hls, requestOptions);\n        } else {\n          // no resolvedUri means the audio is muxed with the video when using this\n          // audio track\n          playlistLoader = null;\n        }\n\n        properties = _videoJs2['default'].mergeOptions({ id: variantLabel, playlistLoader: playlistLoader }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = new _videoJs2['default'].AudioTrack({\n            id: variantLabel,\n            kind: audioTrackKind_(properties),\n            enabled: false,\n            language: properties.language,\n            'default': properties['default'],\n            label: variantLabel\n          });\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup PlaylistLoaders and TextTracks for the subtitle groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.SUBTITLES\n   */\n  'SUBTITLES': function SUBTITLES(type, settings) {\n    var tech = settings.tech;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var requestOptions = settings.requestOptions;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type2 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type2.groups;\n    var tracks = _settings$mediaTypes$type2.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        if (mediaGroups[type][groupId][variantLabel].forced) {\n          // Subtitle playlists with the forced attribute are not selectable in Safari.\n          // According to Apple's HLS Authoring Specification:\n          //   If content has forced subtitles and regular subtitles in a given language,\n          //   the regular subtitles track in that language MUST contain both the forced\n          //   subtitles and the regular subtitles for that language.\n          // Because of this requirement and that Safari does not add forced subtitles,\n          // forced subtitles are skipped here to maintain consistent experience across\n          // all platforms\n          continue;\n        }\n\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        properties = _videoJs2['default'].mergeOptions({\n          id: variantLabel,\n          playlistLoader: new _playlistLoader2['default'](properties.resolvedUri, hls, requestOptions)\n        }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: variantLabel,\n            kind: 'subtitles',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup TextTracks for the closed-caption groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize['CLOSED-CAPTIONS']\n   */\n  'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\n    var tech = settings.tech;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type3 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type3.groups;\n    var tracks = _settings$mediaTypes$type3.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        // We only support CEA608 captions for now, so ignore anything that\n        // doesn't use a CCx INSTREAM-ID\n        if (!properties.instreamId.match(/CC\\d/)) {\n          continue;\n        }\n\n        // No PlaylistLoader is required for Closed-Captions because the captions are\n        // embedded within the video stream\n        groups[groupId].push(_videoJs2['default'].mergeOptions({ id: variantLabel }, properties));\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: properties.instreamId,\n            kind: 'captions',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n  }\n};\n\nexports.initialize = initialize;\n/**\n * Returns a function used to get the active group of the provided type\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Function that returns the active media group for the provided type. Takes an\n *         optional parameter {TextTrack} track. If no track is provided, a list of all\n *         variants in the group, otherwise the variant corresponding to the provided\n *         track is returned.\n * @function activeGroup\n */\nvar activeGroup = function activeGroup(type, settings) {\n  return function (track) {\n    var masterPlaylistLoader = settings.masterPlaylistLoader;\n    var groups = settings.mediaTypes[type].groups;\n\n    var media = masterPlaylistLoader.media();\n\n    if (!media) {\n      return null;\n    }\n\n    var variants = null;\n\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n\n    variants = variants || groups.main;\n\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n\n    if (track === null) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n\n    return variants.filter(function (props) {\n      return props.id === track.id;\n    })[0] || null;\n  };\n};\n\nexports.activeGroup = activeGroup;\nvar activeTrack = {\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  },\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].mode === 'showing') {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  }\n};\n\nexports.activeTrack = activeTrack;\n/**\n * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n * Closed-Captions) specified in the master manifest.\n *\n * @param {Object} settings\n *        Object containing required information for setting up the media groups\n * @param {SegmentLoader} settings.segmentLoaders.AUDIO\n *        Audio segment loader\n * @param {SegmentLoader} settings.segmentLoaders.SUBTITLES\n *        Subtitle segment loader\n * @param {SegmentLoader} settings.segmentLoaders.main\n *        Main segment loader\n * @param {Tech} settings.tech\n *        The tech of the player\n * @param {Object} settings.requestOptions\n *        XHR request options used by the segment loaders\n * @param {PlaylistLoader} settings.masterPlaylistLoader\n *        PlaylistLoader for the master source\n * @param {String} mode\n *        Mode of the hls source handler. Can be 'auto', 'html5', or 'flash'\n * @param {HlsHandler} settings.hls\n *        HLS SourceHandler\n * @param {Object} settings.master\n *        The parsed master manifest\n * @param {Object} settings.mediaTypes\n *        Object to store the loaders, tracks, and utility methods for each media type\n * @param {Function} settings.blacklistCurrentPlaylist\n *        Blacklists the current rendition and forces a rendition switch.\n * @function setupMediaGroups\n */\nvar setupMediaGroups = function setupMediaGroups(settings) {\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    initialize[type](type, settings);\n  });\n\n  var mediaTypes = settings.mediaTypes;\n  var masterPlaylistLoader = settings.masterPlaylistLoader;\n  var tech = settings.tech;\n  var hls = settings.hls;\n\n  // setup active group and track getters and change event handlers\n  ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n    mediaTypes[type].activeGroup = activeGroup(type, settings);\n    mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n    mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n    mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n  });\n\n  // DO NOT enable the default subtitle or caption track.\n  // DO enable the default audio track\n  var audioGroup = mediaTypes.AUDIO.activeGroup();\n  var groupId = (audioGroup.filter(function (group) {\n    return group['default'];\n  })[0] || audioGroup[0]).id;\n\n  mediaTypes.AUDIO.tracks[groupId].enabled = true;\n  mediaTypes.AUDIO.onTrackChanged();\n\n  masterPlaylistLoader.on('mediachange', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanged();\n    });\n  });\n\n  // custom audio track change event handler for usage event\n  var onAudioTrackChanged = function onAudioTrackChanged() {\n    mediaTypes.AUDIO.onTrackChanged();\n    tech.trigger({ type: 'usage', name: 'hls-audio-change' });\n  };\n\n  tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n  tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n\n  hls.on('dispose', function () {\n    tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  });\n\n  // clear existing audio tracks and add the ones we just created\n  tech.clearTracks('audio');\n\n  for (var id in mediaTypes.AUDIO.tracks) {\n    tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n  }\n};\n\nexports.setupMediaGroups = setupMediaGroups;\n/**\n * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n * media type\n *\n * @return {Object}\n *         Object to store the loaders, tracks, and utility methods for each media type\n * @function createMediaTypes\n */\nvar createMediaTypes = function createMediaTypes() {\n  var mediaTypes = {};\n\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    mediaTypes[type] = {\n      groups: {},\n      tracks: {},\n      activePlaylistLoader: null,\n      activeGroup: noop,\n      activeTrack: noop,\n      onGroupChanged: noop,\n      onTrackChanged: noop\n    };\n  });\n\n  return mediaTypes;\n};\nexports.createMediaTypes = createMediaTypes;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AAEF,SAASC,sBAAsBA,CAACC,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAAE;AAEhG,IAAIE,QAAQ,GAAGC,OAAO,CAAC,UAAU,CAAC;AAElC,IAAIC,SAAS,GAAGL,sBAAsB,CAACG,QAAQ,CAAC;AAEhD,IAAIG,eAAe,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAElD,IAAIG,gBAAgB,GAAGP,sBAAsB,CAACM,eAAe,CAAC;AAE9D,IAAIE,IAAI,GAAG,SAASA,IAAIA,CAAA,EAAG,CAAC,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe,GAAG,SAASA,eAAeA,CAACC,UAAU,EAAE;EACzD,IAAIC,IAAI,GAAGD,UAAU,CAAC,SAAS,CAAC,GAAG,MAAM,GAAG,aAAa;EAEzD,IAAIA,UAAU,CAACE,eAAe,IAAIF,UAAU,CAACE,eAAe,CAACC,OAAO,CAAC,sCAAsC,CAAC,IAAI,CAAC,EAAE;IACjHF,IAAI,GAAG,WAAW;EACpB;EAEA,OAAOA,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,WAAW,GAAG,SAASA,WAAWA,CAACC,aAAa,EAAEC,SAAS,EAAE;EAC/DD,aAAa,CAACE,KAAK,CAAC,CAAC;EACrBF,aAAa,CAACG,KAAK,CAAC,CAAC;EAErB,IAAIF,SAAS,IAAIA,SAAS,CAACG,oBAAoB,EAAE;IAC/CH,SAAS,CAACG,oBAAoB,CAACD,KAAK,CAAC,CAAC;IACtCF,SAAS,CAACG,oBAAoB,GAAG,IAAI;EACvC;AACF,CAAC;AAEDrB,OAAO,CAACgB,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIM,YAAY,GAAG,SAASA,YAAYA,CAACC,cAAc,EAAEL,SAAS,EAAE;EAClE;EACA;EACAA,SAAS,CAACG,oBAAoB,GAAGE,cAAc;EAC/CA,cAAc,CAACC,IAAI,CAAC,CAAC;AACvB,CAAC;AAEDxB,OAAO,CAACsB,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,cAAc,GAAG,SAASA,cAAcA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC3D,OAAO,YAAY;IACjB,IAAIC,wBAAwB,GAAGD,QAAQ,CAACE,cAAc;IACtD,IAAIZ,aAAa,GAAGW,wBAAwB,CAACF,IAAI,CAAC;IAClD,IAAII,iBAAiB,GAAGF,wBAAwB,CAACG,IAAI;IACrD,IAAIb,SAAS,GAAGS,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IAEzC,IAAIO,WAAW,GAAGf,SAAS,CAACe,WAAW,CAAC,CAAC;IACzC,IAAIC,WAAW,GAAGhB,SAAS,CAACgB,WAAW,CAACD,WAAW,CAAC;IACpD,IAAIE,oBAAoB,GAAGjB,SAAS,CAACG,oBAAoB;IAEzDL,WAAW,CAACC,aAAa,EAAEC,SAAS,CAAC;IAErC,IAAI,CAACgB,WAAW,EAAE;MAChB;MACA;IACF;IAEA,IAAI,CAACA,WAAW,CAACX,cAAc,EAAE;MAC/B,IAAIY,oBAAoB,EAAE;QACxB;QACA;QACA;QACA;QACAL,iBAAiB,CAACM,eAAe,CAAC,CAAC;MACrC;MACA;IACF;;IAEA;IACAnB,aAAa,CAACoB,YAAY,CAAC,CAAC;IAE5Bf,YAAY,CAACY,WAAW,CAACX,cAAc,EAAEL,SAAS,CAAC;EACrD,CAAC;AACH,CAAC;AAEDlB,OAAO,CAACyB,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIa,cAAc,GAAG,SAASA,cAAcA,CAACZ,IAAI,EAAEC,QAAQ,EAAE;EAC3D,OAAO,YAAY;IACjB,IAAIY,yBAAyB,GAAGZ,QAAQ,CAACE,cAAc;IACvD,IAAIZ,aAAa,GAAGsB,yBAAyB,CAACb,IAAI,CAAC;IACnD,IAAII,iBAAiB,GAAGS,yBAAyB,CAACR,IAAI;IACtD,IAAIb,SAAS,GAAGS,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IAEzC,IAAIO,WAAW,GAAGf,SAAS,CAACe,WAAW,CAAC,CAAC;IACzC,IAAIC,WAAW,GAAGhB,SAAS,CAACgB,WAAW,CAACD,WAAW,CAAC;IACpD,IAAIE,oBAAoB,GAAGjB,SAAS,CAACG,oBAAoB;IAEzDL,WAAW,CAACC,aAAa,EAAEC,SAAS,CAAC;IAErC,IAAI,CAACgB,WAAW,EAAE;MAChB;MACA;IACF;IAEA,IAAI,CAACA,WAAW,CAACX,cAAc,EAAE;MAC/B;MACA;MACA;MACAO,iBAAiB,CAACM,eAAe,CAAC,CAAC;MACnC;IACF;IAEA,IAAID,oBAAoB,KAAKD,WAAW,CAACX,cAAc,EAAE;MACvD;MACA;MACA;MACAD,YAAY,CAACY,WAAW,CAACX,cAAc,EAAEL,SAAS,CAAC;MACnD;IACF;IAEA,IAAID,aAAa,CAACuB,KAAK,EAAE;MACvB;MACAvB,aAAa,CAACuB,KAAK,CAACP,WAAW,CAAC;IAClC;;IAEA;IACAhB,aAAa,CAACmB,eAAe,CAAC,CAAC;IAE/Bd,YAAY,CAACY,WAAW,CAACX,cAAc,EAAEL,SAAS,CAAC;EACrD,CAAC;AACH,CAAC;AAEDlB,OAAO,CAACsC,cAAc,GAAGA,cAAc;AACvC,IAAIG,OAAO,GAAG;EACZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,SAASA,KAAKA,CAAChB,IAAI,EAAEC,QAAQ,EAAE;IACpC,OAAO,YAAY;MACjB,IAAIV,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;MACjD,IAAIR,SAAS,GAAGS,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;MACzC,IAAIiB,wBAAwB,GAAGhB,QAAQ,CAACgB,wBAAwB;MAEhE3B,WAAW,CAACC,aAAa,EAAEC,SAAS,CAAC;;MAErC;MACA,IAAIe,WAAW,GAAGf,SAAS,CAACe,WAAW,CAAC,CAAC;MACzC,IAAIC,WAAW,GAAGhB,SAAS,CAACgB,WAAW,CAAC,CAAC;MACzC,IAAIU,EAAE,GAAG,CAACV,WAAW,CAACW,MAAM,CAAC,UAAUC,KAAK,EAAE;QAC5C,OAAOA,KAAK,CAAC,SAAS,CAAC;MACzB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIZ,WAAW,CAAC,CAAC,CAAC,EAAEU,EAAE;MAC3B,IAAIG,YAAY,GAAG7B,SAAS,CAAC8B,MAAM,CAACJ,EAAE,CAAC;MAEvC,IAAIX,WAAW,KAAKc,YAAY,EAAE;QAChC;QACA;QACAJ,wBAAwB,CAAC;UACvBM,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEA1C,SAAS,CAAC,SAAS,CAAC,CAAC2C,GAAG,CAACC,IAAI,CAAC,wDAAwD,GAAG,4BAA4B,CAAC;MAEtH,KAAK,IAAIC,OAAO,IAAIlC,SAAS,CAAC8B,MAAM,EAAE;QACpC9B,SAAS,CAAC8B,MAAM,CAACI,OAAO,CAAC,CAACC,OAAO,GAAGnC,SAAS,CAAC8B,MAAM,CAACI,OAAO,CAAC,KAAKL,YAAY;MAChF;MAEA7B,SAAS,CAACoB,cAAc,CAAC,CAAC;IAC5B,CAAC;EACH,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,SAAS,EAAE,SAASA,SAASA,CAAC5B,IAAI,EAAEC,QAAQ,EAAE;IAC5C,OAAO,YAAY;MACjB,IAAIV,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;MACjD,IAAIR,SAAS,GAAGS,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;MAEzCnB,SAAS,CAAC,SAAS,CAAC,CAAC2C,GAAG,CAACC,IAAI,CAAC,iDAAiD,GAAG,2BAA2B,CAAC;MAE9GnC,WAAW,CAACC,aAAa,EAAEC,SAAS,CAAC;MAErC,IAAIsB,KAAK,GAAGtB,SAAS,CAACe,WAAW,CAAC,CAAC;MAEnC,IAAIO,KAAK,EAAE;QACTA,KAAK,CAACe,IAAI,GAAG,UAAU;MACzB;MAEArC,SAAS,CAACoB,cAAc,CAAC,CAAC;IAC5B,CAAC;EACH;AACF,CAAC;AAEDtC,OAAO,CAACyC,OAAO,GAAGA,OAAO;AACzB,IAAIe,cAAc,GAAG;EACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,KAAK,EAAE,SAASA,KAAKA,CAAChB,IAAI,EAAEH,cAAc,EAAEI,QAAQ,EAAE;IACpD,IAAI,CAACJ,cAAc,EAAE;MACnB;MACA;IACF;IAEA,IAAIkC,IAAI,GAAG9B,QAAQ,CAAC8B,IAAI;IACxB,IAAIC,cAAc,GAAG/B,QAAQ,CAAC+B,cAAc;IAC5C,IAAIzC,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;IAEjDH,cAAc,CAACoC,EAAE,CAAC,gBAAgB,EAAE,YAAY;MAC9C,IAAIC,KAAK,GAAGrC,cAAc,CAACqC,KAAK,CAAC,CAAC;MAElC3C,aAAa,CAAC4C,QAAQ,CAACD,KAAK,EAAEF,cAAc,CAAC;;MAE7C;MACA;MACA,IAAI,CAACD,IAAI,CAACK,MAAM,CAAC,CAAC,IAAIF,KAAK,CAACG,OAAO,IAAIN,IAAI,CAACO,OAAO,CAAC,CAAC,KAAK,MAAM,EAAE;QAChE/C,aAAa,CAACO,IAAI,CAAC,CAAC;MACtB;IACF,CAAC,CAAC;IAEFD,cAAc,CAACoC,EAAE,CAAC,gBAAgB,EAAE,YAAY;MAC9C1C,aAAa,CAAC4C,QAAQ,CAACtC,cAAc,CAACqC,KAAK,CAAC,CAAC,EAAEF,cAAc,CAAC;;MAE9D;MACA,IAAI,CAACD,IAAI,CAACK,MAAM,CAAC,CAAC,EAAE;QAClB7C,aAAa,CAACO,IAAI,CAAC,CAAC;MACtB;IACF,CAAC,CAAC;IAEFD,cAAc,CAACoC,EAAE,CAAC,OAAO,EAAElB,OAAO,CAACf,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC,CAAC;EAC3D,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,SAAS,EAAE,SAASA,SAASA,CAAC5B,IAAI,EAAEH,cAAc,EAAEI,QAAQ,EAAE;IAC5D,IAAI8B,IAAI,GAAG9B,QAAQ,CAAC8B,IAAI;IACxB,IAAIC,cAAc,GAAG/B,QAAQ,CAAC+B,cAAc;IAC5C,IAAIzC,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;IACjD,IAAIR,SAAS,GAAGS,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IAEzCH,cAAc,CAACoC,EAAE,CAAC,gBAAgB,EAAE,YAAY;MAC9C,IAAIC,KAAK,GAAGrC,cAAc,CAACqC,KAAK,CAAC,CAAC;MAElC3C,aAAa,CAAC4C,QAAQ,CAACD,KAAK,EAAEF,cAAc,CAAC;MAC7CzC,aAAa,CAACuB,KAAK,CAACtB,SAAS,CAACe,WAAW,CAAC,CAAC,CAAC;;MAE5C;MACA;MACA,IAAI,CAACwB,IAAI,CAACK,MAAM,CAAC,CAAC,IAAIF,KAAK,CAACG,OAAO,IAAIN,IAAI,CAACO,OAAO,CAAC,CAAC,KAAK,MAAM,EAAE;QAChE/C,aAAa,CAACO,IAAI,CAAC,CAAC;MACtB;IACF,CAAC,CAAC;IAEFD,cAAc,CAACoC,EAAE,CAAC,gBAAgB,EAAE,YAAY;MAC9C1C,aAAa,CAAC4C,QAAQ,CAACtC,cAAc,CAACqC,KAAK,CAAC,CAAC,EAAEF,cAAc,CAAC;;MAE9D;MACA,IAAI,CAACD,IAAI,CAACK,MAAM,CAAC,CAAC,EAAE;QAClB7C,aAAa,CAACO,IAAI,CAAC,CAAC;MACtB;IACF,CAAC,CAAC;IAEFD,cAAc,CAACoC,EAAE,CAAC,OAAO,EAAElB,OAAO,CAACf,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC,CAAC;EAC3D;AACF,CAAC;AAED3B,OAAO,CAACwD,cAAc,GAAGA,cAAc;AACvC,IAAIS,UAAU,GAAG;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAO,EAAE,SAASvB,KAAKA,CAAChB,IAAI,EAAEC,QAAQ,EAAE;IACtC,IAAI4B,IAAI,GAAG5B,QAAQ,CAAC4B,IAAI;IACxB,IAAIW,GAAG,GAAGvC,QAAQ,CAACuC,GAAG;IACtB,IAAIjD,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;IACjD,IAAIgC,cAAc,GAAG/B,QAAQ,CAAC+B,cAAc;IAC5C,IAAIS,WAAW,GAAGxC,QAAQ,CAACyC,MAAM,CAACD,WAAW;IAC7C,IAAIE,yBAAyB,GAAG1C,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IACzD,IAAI4C,MAAM,GAAGD,yBAAyB,CAACC,MAAM;IAC7C,IAAItB,MAAM,GAAGqB,yBAAyB,CAACrB,MAAM;;IAE7C;IACA;IACA;IACA,IAAI,CAACmB,WAAW,CAACzC,IAAI,CAAC,IAAI5B,MAAM,CAACyE,IAAI,CAACJ,WAAW,CAACzC,IAAI,CAAC,CAAC,CAAC8C,MAAM,KAAK,CAAC,IAAIjB,IAAI,KAAK,OAAO,EAAE;MACzFY,WAAW,CAACzC,IAAI,CAAC,GAAG;QAAEK,IAAI,EAAE;UAAE,SAAS,EAAE;YAAE,SAAS,EAAE;UAAK;QAAE;MAAE,CAAC;IAClE;IAEA,KAAK,IAAI0C,OAAO,IAAIN,WAAW,CAACzC,IAAI,CAAC,EAAE;MACrC,IAAI,CAAC4C,MAAM,CAACG,OAAO,CAAC,EAAE;QACpBH,MAAM,CAACG,OAAO,CAAC,GAAG,EAAE;MACtB;MAEA,KAAK,IAAIC,YAAY,IAAIP,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,EAAE;QACnD,IAAI7D,UAAU,GAAGuD,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,CAACC,YAAY,CAAC;QACzD,IAAInD,cAAc,GAAGoD,SAAS;QAE9B,IAAI/D,UAAU,CAACgE,WAAW,EAAE;UAC1BrD,cAAc,GAAG,IAAId,gBAAgB,CAAC,SAAS,CAAC,CAACG,UAAU,CAACgE,WAAW,EAAEV,GAAG,EAAER,cAAc,CAAC;QAC/F,CAAC,MAAM;UACL;UACA;UACAnC,cAAc,GAAG,IAAI;QACvB;QAEAX,UAAU,GAAGL,SAAS,CAAC,SAAS,CAAC,CAACsE,YAAY,CAAC;UAAEjC,EAAE,EAAE8B,YAAY;UAAEnD,cAAc,EAAEA;QAAe,CAAC,EAAEX,UAAU,CAAC;QAEhH4C,cAAc,CAAC9B,IAAI,CAAC,CAACA,IAAI,EAAEd,UAAU,CAACW,cAAc,EAAEI,QAAQ,CAAC;QAE/D2C,MAAM,CAACG,OAAO,CAAC,CAACK,IAAI,CAAClE,UAAU,CAAC;QAEhC,IAAI,OAAOoC,MAAM,CAAC0B,YAAY,CAAC,KAAK,WAAW,EAAE;UAC/C,IAAIlC,KAAK,GAAG,IAAIjC,SAAS,CAAC,SAAS,CAAC,CAACwE,UAAU,CAAC;YAC9CnC,EAAE,EAAE8B,YAAY;YAChB7D,IAAI,EAAEF,eAAe,CAACC,UAAU,CAAC;YACjCyC,OAAO,EAAE,KAAK;YACd2B,QAAQ,EAAEpE,UAAU,CAACoE,QAAQ;YAC7B,SAAS,EAAEpE,UAAU,CAAC,SAAS,CAAC;YAChCqE,KAAK,EAAEP;UACT,CAAC,CAAC;UAEF1B,MAAM,CAAC0B,YAAY,CAAC,GAAGlC,KAAK;QAC9B;MACF;IACF;;IAEA;IACAvB,aAAa,CAAC0C,EAAE,CAAC,OAAO,EAAElB,OAAO,CAACf,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC,CAAC;EAC1D,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,WAAW,EAAE,SAAS2B,SAASA,CAAC5B,IAAI,EAAEC,QAAQ,EAAE;IAC9C,IAAI8B,IAAI,GAAG9B,QAAQ,CAAC8B,IAAI;IACxB,IAAIS,GAAG,GAAGvC,QAAQ,CAACuC,GAAG;IACtB,IAAIjD,aAAa,GAAGU,QAAQ,CAACE,cAAc,CAACH,IAAI,CAAC;IACjD,IAAIgC,cAAc,GAAG/B,QAAQ,CAAC+B,cAAc;IAC5C,IAAIS,WAAW,GAAGxC,QAAQ,CAACyC,MAAM,CAACD,WAAW;IAC7C,IAAIe,0BAA0B,GAAGvD,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IAC1D,IAAI4C,MAAM,GAAGY,0BAA0B,CAACZ,MAAM;IAC9C,IAAItB,MAAM,GAAGkC,0BAA0B,CAAClC,MAAM;IAE9C,KAAK,IAAIyB,OAAO,IAAIN,WAAW,CAACzC,IAAI,CAAC,EAAE;MACrC,IAAI,CAAC4C,MAAM,CAACG,OAAO,CAAC,EAAE;QACpBH,MAAM,CAACG,OAAO,CAAC,GAAG,EAAE;MACtB;MAEA,KAAK,IAAIC,YAAY,IAAIP,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,EAAE;QACnD,IAAIN,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,CAACC,YAAY,CAAC,CAACS,MAAM,EAAE;UACnD;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QACF;QAEA,IAAIvE,UAAU,GAAGuD,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,CAACC,YAAY,CAAC;QAEzD9D,UAAU,GAAGL,SAAS,CAAC,SAAS,CAAC,CAACsE,YAAY,CAAC;UAC7CjC,EAAE,EAAE8B,YAAY;UAChBnD,cAAc,EAAE,IAAId,gBAAgB,CAAC,SAAS,CAAC,CAACG,UAAU,CAACgE,WAAW,EAAEV,GAAG,EAAER,cAAc;QAC7F,CAAC,EAAE9C,UAAU,CAAC;QAEd4C,cAAc,CAAC9B,IAAI,CAAC,CAACA,IAAI,EAAEd,UAAU,CAACW,cAAc,EAAEI,QAAQ,CAAC;QAE/D2C,MAAM,CAACG,OAAO,CAAC,CAACK,IAAI,CAAClE,UAAU,CAAC;QAEhC,IAAI,OAAOoC,MAAM,CAAC0B,YAAY,CAAC,KAAK,WAAW,EAAE;UAC/C,IAAIlC,KAAK,GAAGiB,IAAI,CAAC2B,kBAAkB,CAAC;YAClCxC,EAAE,EAAE8B,YAAY;YAChB7D,IAAI,EAAE,WAAW;YACjBwC,OAAO,EAAE,KAAK;YACd2B,QAAQ,EAAEpE,UAAU,CAACoE,QAAQ;YAC7BC,KAAK,EAAEP;UACT,CAAC,EAAE,KAAK,CAAC,CAAClC,KAAK;UAEfQ,MAAM,CAAC0B,YAAY,CAAC,GAAGlC,KAAK;QAC9B;MACF;IACF;;IAEA;IACAvB,aAAa,CAAC0C,EAAE,CAAC,OAAO,EAAElB,OAAO,CAACf,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC,CAAC;EAC1D,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,iBAAiB,EAAE,SAAS0D,cAAcA,CAAC3D,IAAI,EAAEC,QAAQ,EAAE;IACzD,IAAI8B,IAAI,GAAG9B,QAAQ,CAAC8B,IAAI;IACxB,IAAIU,WAAW,GAAGxC,QAAQ,CAACyC,MAAM,CAACD,WAAW;IAC7C,IAAImB,0BAA0B,GAAG3D,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC;IAC1D,IAAI4C,MAAM,GAAGgB,0BAA0B,CAAChB,MAAM;IAC9C,IAAItB,MAAM,GAAGsC,0BAA0B,CAACtC,MAAM;IAE9C,KAAK,IAAIyB,OAAO,IAAIN,WAAW,CAACzC,IAAI,CAAC,EAAE;MACrC,IAAI,CAAC4C,MAAM,CAACG,OAAO,CAAC,EAAE;QACpBH,MAAM,CAACG,OAAO,CAAC,GAAG,EAAE;MACtB;MAEA,KAAK,IAAIC,YAAY,IAAIP,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,EAAE;QACnD,IAAI7D,UAAU,GAAGuD,WAAW,CAACzC,IAAI,CAAC,CAAC+C,OAAO,CAAC,CAACC,YAAY,CAAC;;QAEzD;QACA;QACA,IAAI,CAAC9D,UAAU,CAAC2E,UAAU,CAACC,KAAK,CAAC,MAAM,CAAC,EAAE;UACxC;QACF;;QAEA;QACA;QACAlB,MAAM,CAACG,OAAO,CAAC,CAACK,IAAI,CAACvE,SAAS,CAAC,SAAS,CAAC,CAACsE,YAAY,CAAC;UAAEjC,EAAE,EAAE8B;QAAa,CAAC,EAAE9D,UAAU,CAAC,CAAC;QAEzF,IAAI,OAAOoC,MAAM,CAAC0B,YAAY,CAAC,KAAK,WAAW,EAAE;UAC/C,IAAIlC,KAAK,GAAGiB,IAAI,CAAC2B,kBAAkB,CAAC;YAClCxC,EAAE,EAAEhC,UAAU,CAAC2E,UAAU;YACzB1E,IAAI,EAAE,UAAU;YAChBwC,OAAO,EAAE,KAAK;YACd2B,QAAQ,EAAEpE,UAAU,CAACoE,QAAQ;YAC7BC,KAAK,EAAEP;UACT,CAAC,EAAE,KAAK,CAAC,CAAClC,KAAK;UAEfQ,MAAM,CAAC0B,YAAY,CAAC,GAAGlC,KAAK;QAC9B;MACF;IACF;EACF;AACF,CAAC;AAEDxC,OAAO,CAACiE,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI/B,WAAW,GAAG,SAASA,WAAWA,CAACR,IAAI,EAAEC,QAAQ,EAAE;EACrD,OAAO,UAAUa,KAAK,EAAE;IACtB,IAAIiD,oBAAoB,GAAG9D,QAAQ,CAAC8D,oBAAoB;IACxD,IAAInB,MAAM,GAAG3C,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC,CAAC4C,MAAM;IAE7C,IAAIV,KAAK,GAAG6B,oBAAoB,CAAC7B,KAAK,CAAC,CAAC;IAExC,IAAI,CAACA,KAAK,EAAE;MACV,OAAO,IAAI;IACb;IAEA,IAAI8B,QAAQ,GAAG,IAAI;IAEnB,IAAI9B,KAAK,CAAC+B,UAAU,CAACjE,IAAI,CAAC,EAAE;MAC1BgE,QAAQ,GAAGpB,MAAM,CAACV,KAAK,CAAC+B,UAAU,CAACjE,IAAI,CAAC,CAAC;IAC3C;IAEAgE,QAAQ,GAAGA,QAAQ,IAAIpB,MAAM,CAACvC,IAAI;IAElC,IAAI,OAAOS,KAAK,KAAK,WAAW,EAAE;MAChC,OAAOkD,QAAQ;IACjB;IAEA,IAAIlD,KAAK,KAAK,IAAI,EAAE;MAClB;MACA;MACA,OAAO,IAAI;IACb;IAEA,OAAOkD,QAAQ,CAAC7C,MAAM,CAAC,UAAU+C,KAAK,EAAE;MACtC,OAAOA,KAAK,CAAChD,EAAE,KAAKJ,KAAK,CAACI,EAAE;IAC9B,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;EACf,CAAC;AACH,CAAC;AAED5C,OAAO,CAACkC,WAAW,GAAGA,WAAW;AACjC,IAAID,WAAW,GAAG;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,KAAK,EAAE,SAASA,KAAKA,CAAChB,IAAI,EAAEC,QAAQ,EAAE;IACpC,OAAO,YAAY;MACjB,IAAIqB,MAAM,GAAGrB,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC,CAACsB,MAAM;MAE7C,KAAK,IAAIJ,EAAE,IAAII,MAAM,EAAE;QACrB,IAAIA,MAAM,CAACJ,EAAE,CAAC,CAACS,OAAO,EAAE;UACtB,OAAOL,MAAM,CAACJ,EAAE,CAAC;QACnB;MACF;MAEA,OAAO,IAAI;IACb,CAAC;EACH,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,SAAS,EAAE,SAASA,SAASA,CAAC5B,IAAI,EAAEC,QAAQ,EAAE;IAC5C,OAAO,YAAY;MACjB,IAAIqB,MAAM,GAAGrB,QAAQ,CAACK,UAAU,CAACN,IAAI,CAAC,CAACsB,MAAM;MAE7C,KAAK,IAAIJ,EAAE,IAAII,MAAM,EAAE;QACrB,IAAIA,MAAM,CAACJ,EAAE,CAAC,CAACW,IAAI,KAAK,SAAS,EAAE;UACjC,OAAOP,MAAM,CAACJ,EAAE,CAAC;QACnB;MACF;MAEA,OAAO,IAAI;IACb,CAAC;EACH;AACF,CAAC;AAED5C,OAAO,CAACiC,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI4D,gBAAgB,GAAG,SAASA,gBAAgBA,CAAClE,QAAQ,EAAE;EACzD,CAAC,OAAO,EAAE,WAAW,EAAE,iBAAiB,CAAC,CAACmE,OAAO,CAAC,UAAUpE,IAAI,EAAE;IAChEuC,UAAU,CAACvC,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC;EAClC,CAAC,CAAC;EAEF,IAAIK,UAAU,GAAGL,QAAQ,CAACK,UAAU;EACpC,IAAIyD,oBAAoB,GAAG9D,QAAQ,CAAC8D,oBAAoB;EACxD,IAAIhC,IAAI,GAAG9B,QAAQ,CAAC8B,IAAI;EACxB,IAAIS,GAAG,GAAGvC,QAAQ,CAACuC,GAAG;;EAEtB;EACA,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC4B,OAAO,CAAC,UAAUpE,IAAI,EAAE;IAC7CM,UAAU,CAACN,IAAI,CAAC,CAACQ,WAAW,GAAGA,WAAW,CAACR,IAAI,EAAEC,QAAQ,CAAC;IAC1DK,UAAU,CAACN,IAAI,CAAC,CAACO,WAAW,GAAGA,WAAW,CAACP,IAAI,CAAC,CAACA,IAAI,EAAEC,QAAQ,CAAC;IAChEK,UAAU,CAACN,IAAI,CAAC,CAACD,cAAc,GAAGA,cAAc,CAACC,IAAI,EAAEC,QAAQ,CAAC;IAChEK,UAAU,CAACN,IAAI,CAAC,CAACY,cAAc,GAAGA,cAAc,CAACZ,IAAI,EAAEC,QAAQ,CAAC;EAClE,CAAC,CAAC;;EAEF;EACA;EACA,IAAIoE,UAAU,GAAG/D,UAAU,CAACU,KAAK,CAACR,WAAW,CAAC,CAAC;EAC/C,IAAIuC,OAAO,GAAG,CAACsB,UAAU,CAAClD,MAAM,CAAC,UAAUC,KAAK,EAAE;IAChD,OAAOA,KAAK,CAAC,SAAS,CAAC;EACzB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIiD,UAAU,CAAC,CAAC,CAAC,EAAEnD,EAAE;EAE1BZ,UAAU,CAACU,KAAK,CAACM,MAAM,CAACyB,OAAO,CAAC,CAACpB,OAAO,GAAG,IAAI;EAC/CrB,UAAU,CAACU,KAAK,CAACJ,cAAc,CAAC,CAAC;EAEjCmD,oBAAoB,CAAC9B,EAAE,CAAC,aAAa,EAAE,YAAY;IACjD,CAAC,OAAO,EAAE,WAAW,CAAC,CAACmC,OAAO,CAAC,UAAUpE,IAAI,EAAE;MAC7C,OAAOM,UAAU,CAACN,IAAI,CAAC,CAACD,cAAc,CAAC,CAAC;IAC1C,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,IAAIuE,mBAAmB,GAAG,SAASA,mBAAmBA,CAAA,EAAG;IACvDhE,UAAU,CAACU,KAAK,CAACJ,cAAc,CAAC,CAAC;IACjCmB,IAAI,CAACwC,OAAO,CAAC;MAAEvE,IAAI,EAAE,OAAO;MAAEwE,IAAI,EAAE;IAAmB,CAAC,CAAC;EAC3D,CAAC;EAEDzC,IAAI,CAAC0C,WAAW,CAAC,CAAC,CAACC,gBAAgB,CAAC,QAAQ,EAAEJ,mBAAmB,CAAC;EAClEvC,IAAI,CAAC4C,gBAAgB,CAAC,CAAC,CAACD,gBAAgB,CAAC,QAAQ,EAAEpE,UAAU,CAACsB,SAAS,CAAChB,cAAc,CAAC;EAEvF4B,GAAG,CAACP,EAAE,CAAC,SAAS,EAAE,YAAY;IAC5BF,IAAI,CAAC0C,WAAW,CAAC,CAAC,CAACG,mBAAmB,CAAC,QAAQ,EAAEN,mBAAmB,CAAC;IACrEvC,IAAI,CAAC4C,gBAAgB,CAAC,CAAC,CAACC,mBAAmB,CAAC,QAAQ,EAAEtE,UAAU,CAACsB,SAAS,CAAChB,cAAc,CAAC;EAC5F,CAAC,CAAC;;EAEF;EACAmB,IAAI,CAAC8C,WAAW,CAAC,OAAO,CAAC;EAEzB,KAAK,IAAI3D,EAAE,IAAIZ,UAAU,CAACU,KAAK,CAACM,MAAM,EAAE;IACtCS,IAAI,CAAC0C,WAAW,CAAC,CAAC,CAACK,QAAQ,CAACxE,UAAU,CAACU,KAAK,CAACM,MAAM,CAACJ,EAAE,CAAC,CAAC;EAC1D;AACF,CAAC;AAED5C,OAAO,CAAC6F,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIY,gBAAgB,GAAG,SAASA,gBAAgBA,CAAA,EAAG;EACjD,IAAIzE,UAAU,GAAG,CAAC,CAAC;EAEnB,CAAC,OAAO,EAAE,WAAW,EAAE,iBAAiB,CAAC,CAAC8D,OAAO,CAAC,UAAUpE,IAAI,EAAE;IAChEM,UAAU,CAACN,IAAI,CAAC,GAAG;MACjB4C,MAAM,EAAE,CAAC,CAAC;MACVtB,MAAM,EAAE,CAAC,CAAC;MACV3B,oBAAoB,EAAE,IAAI;MAC1Ba,WAAW,EAAExB,IAAI;MACjBuB,WAAW,EAAEvB,IAAI;MACjBe,cAAc,EAAEf,IAAI;MACpB4B,cAAc,EAAE5B;IAClB,CAAC;EACH,CAAC,CAAC;EAEF,OAAOsB,UAAU;AACnB,CAAC;AACDhC,OAAO,CAACyG,gBAAgB,GAAGA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}