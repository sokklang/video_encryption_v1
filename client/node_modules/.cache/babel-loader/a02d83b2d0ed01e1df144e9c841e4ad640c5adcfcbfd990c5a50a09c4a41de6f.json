{"ast":null,"code":"/**\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function (type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0,\n    // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function (flv, count) {\n      var bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n    case FlvTag.VIDEO_TAG:\n      this.length = 16;\n      // Start the buffer at 256k\n      bufferStartSize *= 6;\n      break;\n    case FlvTag.AUDIO_TAG:\n      this.length = 13;\n      this.keyFrame = true;\n      break;\n    case FlvTag.METADATA_TAG:\n      this.length = 29;\n      this.keyFrame = true;\n      break;\n    default:\n      throw new Error('Unknown FLV tag type');\n  }\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function (bytes, offset, length) {\n    var start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function (byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function (short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function (pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function () {\n    if (adHoc === 0) {\n      return 0;\n    }\n    return this.length - (adHoc + 4);\n  };\n  this.startNalUnit = function () {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function (nalContainer) {\n    var nalStart,\n      // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function (key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function (key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function () {\n    var dtsDelta,\n      // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n      case FlvTag.VIDEO_TAG:\n        // We only support AVC, 1 = key frame (for AVC, a seekable\n        // frame), 2 = inter frame (for AVC, a non-seekable frame)\n        this.bytes[11] = (this.keyFrame || extraData ? 0x10 : 0x20) | 0x07;\n        this.bytes[12] = extraData ? 0x00 : 0x01;\n        dtsDelta = this.pts - this.dts;\n        this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n        this.bytes[14] = (dtsDelta & 0x0000FF00) >>> 8;\n        this.bytes[15] = (dtsDelta & 0x000000FF) >>> 0;\n        break;\n      case FlvTag.AUDIO_TAG:\n        this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n        this.bytes[12] = extraData ? 0x00 : 0x01;\n        break;\n      case FlvTag.METADATA_TAG:\n        this.position = 11;\n        this.view.setUint8(this.position, 0x02); // String type\n        this.position++;\n        this.view.setUint16(this.position, 0x0A); // 10 Bytes\n        this.position += 2;\n        // set \"onMetaData\"\n        this.bytes.set([0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61], this.position);\n        this.position += 10;\n        this.bytes[this.position] = 0x08; // Array type\n        this.position++;\n        this.view.setUint32(this.position, adHoc);\n        this.position = this.length;\n        this.bytes.set([0, 0, 9], this.position);\n        this.position += 3; // End Data Tag\n        this.length = this.position;\n        break;\n    }\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[2] = (len & 0x0000FF00) >>> 8;\n    this.bytes[3] = (len & 0x000000FF) >>> 0;\n    // write the Timestamp\n    this.bytes[4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[5] = (this.dts & 0x0000FF00) >>> 8;\n    this.bytes[6] = (this.dts & 0x000000FF) >>> 0;\n    this.bytes[7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[8] = 0;\n    this.bytes[9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function (tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function (tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function (tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function (tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function (tag) {\n  var pts = tag[4] << 16; // :uint\n  pts |= tag[5] << 8;\n  pts |= tag[6] << 0;\n  pts |= tag[7] << 24;\n  return pts;\n};\nmodule.exports = FlvTag;","map":{"version":3,"names":["FlvTag","type","extraData","adHoc","bufferStartSize","prepareWrite","flv","count","bytes","minLength","position","byteLength","Uint8Array","set","subarray","view","DataView","buffer","widthBytes","length","heightBytes","videocodecidBytes","i","charCodeAt","keyFrame","VIDEO_TAG","AUDIO_TAG","METADATA_TAG","Error","pts","dts","writeBytes","offset","start","end","Math","max","writeByte","byte","writeShort","short","setUint16","negIndex","pos","nalUnitSize","startNalUnit","endNalUnit","nalContainer","nalStart","nalLength","setUint32","push","writeMetaDataDouble","key","val","setFloat64","writeMetaDataBoolean","setUint8","finalize","dtsDelta","len","frameTime","isAudioFrame","tag","isVideoFrame","isMetaData","isKeyFrame","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js"],"sourcesContent":["/**\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function(type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0, // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function(flv, count) {\n      var\n        bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n  case FlvTag.VIDEO_TAG:\n    this.length = 16;\n    // Start the buffer at 256k\n    bufferStartSize *= 6;\n    break;\n  case FlvTag.AUDIO_TAG:\n    this.length = 13;\n    this.keyFrame = true;\n    break;\n  case FlvTag.METADATA_TAG:\n    this.length = 29;\n    this.keyFrame = true;\n    break;\n  default:\n    throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function(bytes, offset, length) {\n    var\n      start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function(byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function(short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function(pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function() {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function() {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function(nalContainer) {\n    var\n      nalStart, // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function(key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function(key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function() {\n    var\n      dtsDelta, // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n    case FlvTag.VIDEO_TAG:\n       // We only support AVC, 1 = key frame (for AVC, a seekable\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\n      this.bytes[12] = extraData ?  0x00 : 0x01;\n\n      dtsDelta = this.pts - this.dts;\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\n      break;\n\n    case FlvTag.AUDIO_TAG:\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n      this.bytes[12] = extraData ? 0x00 : 0x01;\n      break;\n\n    case FlvTag.METADATA_TAG:\n      this.position = 11;\n      this.view.setUint8(this.position, 0x02); // String type\n      this.position++;\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\n      this.position += 2;\n      // set \"onMetaData\"\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\n                      0x74, 0x61, 0x44, 0x61,\n                      0x74, 0x61], this.position);\n      this.position += 10;\n      this.bytes[this.position] = 0x08; // Array type\n      this.position++;\n      this.view.setUint32(this.position, adHoc);\n      this.position = this.length;\n      this.bytes.set([0, 0, 9], this.position);\n      this.position += 3; // End Data Tag\n      this.length = this.position;\n      break;\n    }\n\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\n    // write the Timestamp\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[ 8] = 0;\n    this.bytes[ 9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\n\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function(tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function(tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function(tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function(tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function(tag) {\n  var pts = tag[ 4] << 16; // :uint\n  pts |= tag[ 5] <<  8;\n  pts |= tag[ 6] <<  0;\n  pts |= tag[ 7] << 24;\n  return pts;\n};\n\nmodule.exports = FlvTag;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}