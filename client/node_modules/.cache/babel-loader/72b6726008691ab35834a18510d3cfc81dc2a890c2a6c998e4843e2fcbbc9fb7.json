{"ast":null,"code":"/**\n * @file vtt-segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x3, _x4, _x5) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x3,\n      property = _x4,\n      receiver = _x5;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x3 = parent;\n        _x4 = property;\n        _x5 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _segmentLoader = require('./segment-loader');\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _globalWindow = require('global/window');\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\nvar _binUtils = require('./bin-utils');\nvar VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (char) {\n  return char.charCodeAt(0);\n}));\nvar uintToString = function uintToString(uintArray) {\n  return String.fromCharCode.apply(null, uintArray);\n};\n\n/**\n * An object that manages segment loading and appending.\n *\n * @class VTTSegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar VTTSegmentLoader = function (_SegmentLoader) {\n  _inherits(VTTSegmentLoader, _SegmentLoader);\n  function VTTSegmentLoader(settings) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    _classCallCheck(this, VTTSegmentLoader);\n    _get(Object.getPrototypeOf(VTTSegmentLoader.prototype), 'constructor', this).call(this, settings, options);\n\n    // SegmentLoader requires a MediaSource be specified or it will throw an error;\n    // however, VTTSegmentLoader has no need of a media source, so delete the reference\n    this.mediaSource_ = null;\n    this.subtitlesTrack_ = null;\n  }\n\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n\n  _createClass(VTTSegmentLoader, [{\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n      var cues = this.subtitlesTrack_.cues;\n      var start = cues[0].startTime;\n      var end = cues[cues.length - 1].startTime;\n      return _videoJs2['default'].createTimeRanges([[start, end]]);\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      if (!map) {\n        return null;\n      }\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n      if (set && !storedMap && map.bytes) {\n        // append WebVTT line terminators to the media initialization segment if it exists\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n        // requires two or more WebVTT line terminators between the WebVTT header and the\n        // rest of the file\n        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n        var combinedSegment = new Uint8Array(combinedByteLength);\n        combinedSegment.set(map.bytes);\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: combinedSegment\n        };\n      }\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * Set a subtitle track on the segment loader to add subtitles to\n     *\n     * @param {TextTrack=} track\n     *        The text track to add loaded subtitles to\n     * @return {TextTrack}\n     *        Returns the subtitles track\n     */\n  }, {\n    key: 'track',\n    value: function track(_track) {\n      if (typeof _track === 'undefined') {\n        return this.subtitlesTrack_;\n      }\n      this.subtitlesTrack_ = _track;\n\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n      return this.subtitlesTrack_;\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.subtitlesTrack_);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      var _this = this;\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n      segmentInfo = this.skipEmptySegments_(segmentInfo);\n      if (!segmentInfo) {\n        return;\n      }\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n        // We don't have the timestamp offset that we need to sync subtitles.\n        // Rerun on a timestamp offset or user interaction.\n        var checkTimestampOffset = function checkTimestampOffset() {\n          _this.state = 'READY';\n          if (!_this.paused()) {\n            // if not paused, queue a buffer check as soon as possible\n            _this.monitorBuffer_();\n          }\n        };\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\n        this.state = 'WAITING_ON_TIMELINE';\n        return;\n      }\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Prevents the segment loader from requesting segments we know contain no subtitles\n     * by walking forward until we find the next segment that we don't know whether it is\n     * empty or not.\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @return {Object}\n     *         a segment info object that describes the current segment\n     */\n  }, {\n    key: 'skipEmptySegments_',\n    value: function skipEmptySegments_(segmentInfo) {\n      while (segmentInfo && segmentInfo.segment.empty) {\n        segmentInfo = this.generateSegmentInfo_(segmentInfo.playlist, segmentInfo.mediaIndex + 1, segmentInfo.startOfSegment + segmentInfo.duration, segmentInfo.isSyncRequest);\n      }\n      return segmentInfo;\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this2 = this;\n      if (!this.pendingSegment_ || !this.subtitlesTrack_) {\n        this.state = 'READY';\n        return;\n      }\n      this.state = 'APPENDING';\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n\n      // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n      if (typeof _globalWindow2['default'].WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n        var _ret = function () {\n          var loadHandler = function loadHandler() {\n            _this2.handleSegment_();\n          };\n          _this2.state = 'WAITING_ON_VTTJS';\n          _this2.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n          _this2.subtitlesTrack_.tech_.one('vttjserror', function () {\n            _this2.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n            _this2.error({\n              message: 'Error loading vtt.js'\n            });\n            _this2.state = 'READY';\n            _this2.pause();\n            _this2.trigger('error');\n          });\n          return {\n            v: undefined\n          };\n        }();\n        if (typeof _ret === 'object') return _ret.v;\n      }\n      segment.requested = true;\n      try {\n        this.parseVTTCues_(segmentInfo);\n      } catch (e) {\n        this.error({\n          message: e.message\n        });\n        this.state = 'READY';\n        this.pause();\n        return this.trigger('error');\n      }\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      this.mediaSecondsLoaded += segment.duration;\n      if (segmentInfo.cues.length) {\n        // remove any overlapping cues to prevent doubling\n        this.remove(segmentInfo.cues[0].endTime, segmentInfo.cues[segmentInfo.cues.length - 1].endTime);\n      }\n      segmentInfo.cues.forEach(function (cue) {\n        _this2.subtitlesTrack_.addCue(cue);\n      });\n      this.handleUpdateEnd_();\n    }\n\n    /**\n     * Uses the WebVTT parser to parse the segment response\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @private\n     */\n  }, {\n    key: 'parseVTTCues_',\n    value: function parseVTTCues_(segmentInfo) {\n      var decoder = undefined;\n      var decodeBytesToString = false;\n      if (typeof _globalWindow2['default'].TextDecoder === 'function') {\n        decoder = new _globalWindow2['default'].TextDecoder('utf8');\n      } else {\n        decoder = _globalWindow2['default'].WebVTT.StringDecoder();\n        decodeBytesToString = true;\n      }\n      var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, decoder);\n      segmentInfo.cues = [];\n      segmentInfo.timestampmap = {\n        MPEGTS: 0,\n        LOCAL: 0\n      };\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n      parser.ontimestampmap = function (map) {\n        return segmentInfo.timestampmap = map;\n      };\n      parser.onparsingerror = function (error) {\n        _videoJs2['default'].log.warn('Error encountered when parsing cues: ' + error.message);\n      };\n      if (segmentInfo.segment.map) {\n        var mapData = segmentInfo.segment.map.bytes;\n        if (decodeBytesToString) {\n          mapData = uintToString(mapData);\n        }\n        parser.parse(mapData);\n      }\n      var segmentData = segmentInfo.bytes;\n      if (decodeBytesToString) {\n        segmentData = uintToString(segmentData);\n      }\n      parser.parse(segmentData);\n      parser.flush();\n    }\n\n    /**\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n     * from the SyncController\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @param {Object} mappingObj\n     *        object containing a mapping from TS to media time\n     * @param {Object} playlist\n     *        the playlist object containing the segment\n     * @private\n     */\n  }, {\n    key: 'updateTimeMapping_',\n    value: function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n      var segment = segmentInfo.segment;\n      if (!mappingObj) {\n        // If the sync controller does not have a mapping of TS to Media Time for the\n        // timeline, then we don't have enough information to update the cue\n        // start/end times\n        return;\n      }\n      if (!segmentInfo.cues.length) {\n        // If there are no cues, we also do not have enough information to figure out\n        // segment timing. Mark that the segment contains no cues so we don't re-request\n        // an empty segment.\n        segment.empty = true;\n        return;\n      }\n      var timestampmap = segmentInfo.timestampmap;\n      var diff = timestampmap.MPEGTS / 90000 - timestampmap.LOCAL + mappingObj.mapping;\n      segmentInfo.cues.forEach(function (cue) {\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\n        cue.startTime += diff;\n        cue.endTime += diff;\n      });\n      if (!playlist.syncInfo) {\n        var firstStart = segmentInfo.cues[0].startTime;\n        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n        playlist.syncInfo = {\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: Math.min(firstStart, lastStart - segment.duration)\n        };\n      }\n    }\n  }]);\n  return VTTSegmentLoader;\n}(_segmentLoader2['default']);\nexports['default'] = VTTSegmentLoader;\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x3","_x4","_x5","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_segmentLoader","require","_segmentLoader2","_videoJs","_videoJs2","_globalWindow","_globalWindow2","_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs","_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2","_binUtils","VTT_LINE_TERMINATORS","Uint8Array","split","map","char","charCodeAt","uintToString","uintArray","String","fromCharCode","apply","VTTSegmentLoader","_SegmentLoader","settings","options","arguments","mediaSource_","subtitlesTrack_","buffered_","cues","createTimeRanges","start","startTime","end","initSegment","set","id","initSegmentId","storedMap","initSegments_","bytes","combinedByteLength","byteLength","combinedSegment","resolvedUri","byterange","couldBeginLoading_","playlist_","paused","init_","state","resetEverything","monitorBuffer_","track","_track","remove","fillBuffer_","_this","syncPoint_","syncController_","getSyncPoint","duration_","currentTimeline_","currentTime_","segmentInfo","checkBuffer_","mediaIndex","hasPlayed_","skipEmptySegments_","timestampOffsetForTimeline","timeline","checkTimestampOffset","one","loadSegment_","segment","empty","generateSegmentInfo_","playlist","startOfSegment","duration","isSyncRequest","handleSegment_","_this2","pendingSegment_","WebVTT","tech_","_ret","loadHandler","off","error","message","pause","trigger","v","requested","parseVTTCues_","e","updateTimeMapping_","timelines","mediaSecondsLoaded","endTime","forEach","cue","addCue","handleUpdateEnd_","decoder","decodeBytesToString","TextDecoder","StringDecoder","parser","Parser","vttjs","timestampmap","MPEGTS","LOCAL","oncue","push","bind","ontimestampmap","onparsingerror","log","warn","mapData","parse","segmentData","flush","mappingObj","diff","mapping","syncInfo","firstStart","lastStart","mediaSequence","time","Math","min","module"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/vtt-segment-loader.js"],"sourcesContent":["/**\n * @file vtt-segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _segmentLoader = require('./segment-loader');\n\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (char) {\n  return char.charCodeAt(0);\n}));\n\nvar uintToString = function uintToString(uintArray) {\n  return String.fromCharCode.apply(null, uintArray);\n};\n\n/**\n * An object that manages segment loading and appending.\n *\n * @class VTTSegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar VTTSegmentLoader = (function (_SegmentLoader) {\n  _inherits(VTTSegmentLoader, _SegmentLoader);\n\n  function VTTSegmentLoader(settings) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, VTTSegmentLoader);\n\n    _get(Object.getPrototypeOf(VTTSegmentLoader.prototype), 'constructor', this).call(this, settings, options);\n\n    // SegmentLoader requires a MediaSource be specified or it will throw an error;\n    // however, VTTSegmentLoader has no need of a media source, so delete the reference\n    this.mediaSource_ = null;\n\n    this.subtitlesTrack_ = null;\n  }\n\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n\n  _createClass(VTTSegmentLoader, [{\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n\n      var cues = this.subtitlesTrack_.cues;\n      var start = cues[0].startTime;\n      var end = cues[cues.length - 1].startTime;\n\n      return _videoJs2['default'].createTimeRanges([[start, end]]);\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      if (!map) {\n        return null;\n      }\n\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set && !storedMap && map.bytes) {\n        // append WebVTT line terminators to the media initialization segment if it exists\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n        // requires two or more WebVTT line terminators between the WebVTT header and the\n        // rest of the file\n        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n        var combinedSegment = new Uint8Array(combinedByteLength);\n\n        combinedSegment.set(map.bytes);\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: combinedSegment\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * Set a subtitle track on the segment loader to add subtitles to\n     *\n     * @param {TextTrack=} track\n     *        The text track to add loaded subtitles to\n     * @return {TextTrack}\n     *        Returns the subtitles track\n     */\n  }, {\n    key: 'track',\n    value: function track(_track) {\n      if (typeof _track === 'undefined') {\n        return this.subtitlesTrack_;\n      }\n\n      this.subtitlesTrack_ = _track;\n\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n\n      return this.subtitlesTrack_;\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.subtitlesTrack_);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      var _this = this;\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      segmentInfo = this.skipEmptySegments_(segmentInfo);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n        // We don't have the timestamp offset that we need to sync subtitles.\n        // Rerun on a timestamp offset or user interaction.\n        var checkTimestampOffset = function checkTimestampOffset() {\n          _this.state = 'READY';\n          if (!_this.paused()) {\n            // if not paused, queue a buffer check as soon as possible\n            _this.monitorBuffer_();\n          }\n        };\n\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\n        this.state = 'WAITING_ON_TIMELINE';\n        return;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Prevents the segment loader from requesting segments we know contain no subtitles\n     * by walking forward until we find the next segment that we don't know whether it is\n     * empty or not.\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @return {Object}\n     *         a segment info object that describes the current segment\n     */\n  }, {\n    key: 'skipEmptySegments_',\n    value: function skipEmptySegments_(segmentInfo) {\n      while (segmentInfo && segmentInfo.segment.empty) {\n        segmentInfo = this.generateSegmentInfo_(segmentInfo.playlist, segmentInfo.mediaIndex + 1, segmentInfo.startOfSegment + segmentInfo.duration, segmentInfo.isSyncRequest);\n      }\n      return segmentInfo;\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this2 = this;\n\n      if (!this.pendingSegment_ || !this.subtitlesTrack_) {\n        this.state = 'READY';\n        return;\n      }\n\n      this.state = 'APPENDING';\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n\n      // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n      if (typeof _globalWindow2['default'].WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n        var _ret = (function () {\n\n          var loadHandler = function loadHandler() {\n            _this2.handleSegment_();\n          };\n\n          _this2.state = 'WAITING_ON_VTTJS';\n          _this2.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n          _this2.subtitlesTrack_.tech_.one('vttjserror', function () {\n            _this2.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n            _this2.error({\n              message: 'Error loading vtt.js'\n            });\n            _this2.state = 'READY';\n            _this2.pause();\n            _this2.trigger('error');\n          });\n\n          return {\n            v: undefined\n          };\n        })();\n\n        if (typeof _ret === 'object') return _ret.v;\n      }\n\n      segment.requested = true;\n\n      try {\n        this.parseVTTCues_(segmentInfo);\n      } catch (e) {\n        this.error({\n          message: e.message\n        });\n        this.state = 'READY';\n        this.pause();\n        return this.trigger('error');\n      }\n\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n\n      this.mediaSecondsLoaded += segment.duration;\n\n      if (segmentInfo.cues.length) {\n        // remove any overlapping cues to prevent doubling\n        this.remove(segmentInfo.cues[0].endTime, segmentInfo.cues[segmentInfo.cues.length - 1].endTime);\n      }\n\n      segmentInfo.cues.forEach(function (cue) {\n        _this2.subtitlesTrack_.addCue(cue);\n      });\n\n      this.handleUpdateEnd_();\n    }\n\n    /**\n     * Uses the WebVTT parser to parse the segment response\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @private\n     */\n  }, {\n    key: 'parseVTTCues_',\n    value: function parseVTTCues_(segmentInfo) {\n      var decoder = undefined;\n      var decodeBytesToString = false;\n\n      if (typeof _globalWindow2['default'].TextDecoder === 'function') {\n        decoder = new _globalWindow2['default'].TextDecoder('utf8');\n      } else {\n        decoder = _globalWindow2['default'].WebVTT.StringDecoder();\n        decodeBytesToString = true;\n      }\n\n      var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, decoder);\n\n      segmentInfo.cues = [];\n      segmentInfo.timestampmap = { MPEGTS: 0, LOCAL: 0 };\n\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n      parser.ontimestampmap = function (map) {\n        return segmentInfo.timestampmap = map;\n      };\n      parser.onparsingerror = function (error) {\n        _videoJs2['default'].log.warn('Error encountered when parsing cues: ' + error.message);\n      };\n\n      if (segmentInfo.segment.map) {\n        var mapData = segmentInfo.segment.map.bytes;\n\n        if (decodeBytesToString) {\n          mapData = uintToString(mapData);\n        }\n\n        parser.parse(mapData);\n      }\n\n      var segmentData = segmentInfo.bytes;\n\n      if (decodeBytesToString) {\n        segmentData = uintToString(segmentData);\n      }\n\n      parser.parse(segmentData);\n      parser.flush();\n    }\n\n    /**\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n     * from the SyncController\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @param {Object} mappingObj\n     *        object containing a mapping from TS to media time\n     * @param {Object} playlist\n     *        the playlist object containing the segment\n     * @private\n     */\n  }, {\n    key: 'updateTimeMapping_',\n    value: function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n      var segment = segmentInfo.segment;\n\n      if (!mappingObj) {\n        // If the sync controller does not have a mapping of TS to Media Time for the\n        // timeline, then we don't have enough information to update the cue\n        // start/end times\n        return;\n      }\n\n      if (!segmentInfo.cues.length) {\n        // If there are no cues, we also do not have enough information to figure out\n        // segment timing. Mark that the segment contains no cues so we don't re-request\n        // an empty segment.\n        segment.empty = true;\n        return;\n      }\n\n      var timestampmap = segmentInfo.timestampmap;\n      var diff = timestampmap.MPEGTS / 90000 - timestampmap.LOCAL + mappingObj.mapping;\n\n      segmentInfo.cues.forEach(function (cue) {\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\n        cue.startTime += diff;\n        cue.endTime += diff;\n      });\n\n      if (!playlist.syncInfo) {\n        var firstStart = segmentInfo.cues[0].startTime;\n        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n\n        playlist.syncInfo = {\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: Math.min(firstStart, lastStart - segment.duration)\n        };\n      }\n    }\n  }]);\n\n  return VTTSegmentLoader;\n})(_segmentLoader2['default']);\n\nexports['default'] = VTTSegmentLoader;\nmodule.exports = exports['default'];"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}