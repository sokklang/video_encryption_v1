{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function () {\n  var everything = new Uint8Array(),\n    timeStamp = 0;\n  AacStream.prototype.init.call(this);\n  this.setTimestamp = function (timestamp) {\n    timeStamp = timestamp;\n  };\n  this.parseId3TagSize = function (header, byteIndex) {\n    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n      flags = header[byteIndex + 5],\n      footerPresent = (flags & 16) >> 4;\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n    return returnSize + 10;\n  };\n  this.parseAdtsSize = function (header, byteIndex) {\n    var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n      middle = header[byteIndex + 4] << 3,\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\n    return highTwo | middle | lowThree;\n  };\n  this.push = function (bytes) {\n    var frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n    while (everything.length - byteIndex >= 3) {\n      if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = this.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if (everything[byteIndex] & 0xff === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n        frameSize = this.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\nAacStream.prototype = new Stream();\nmodule.exports = AacStream;","map":{"version":3,"names":["Stream","require","AacStream","everything","Uint8Array","timeStamp","prototype","init","call","setTimestamp","timestamp","parseId3TagSize","header","byteIndex","returnSize","flags","footerPresent","parseAdtsSize","lowThree","middle","highTwo","push","bytes","frameSize","bytesLeft","chunk","packet","tempLength","length","byteLength","set","subarray","charCodeAt","type","data","trigger","pts","dts","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/aac/index.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.parseId3TagSize = function(header, byteIndex) {\n    var\n      returnSize = (header[byteIndex + 6] << 21) |\n                   (header[byteIndex + 7] << 14) |\n                   (header[byteIndex + 8] << 7) |\n                   (header[byteIndex + 9]),\n      flags = header[byteIndex + 5],\n      footerPresent = (flags & 16) >> 4;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n    return returnSize + 10;\n  };\n\n  this.parseAdtsSize = function(header, byteIndex) {\n    var\n      lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n      middle = header[byteIndex + 4] << 3,\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n    return (highTwo | middle) | lowThree;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = this.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if ((everything[byteIndex] & 0xff === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = this.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}