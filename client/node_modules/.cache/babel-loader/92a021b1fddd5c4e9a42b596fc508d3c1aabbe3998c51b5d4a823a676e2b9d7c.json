{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/probe.js');\nvar PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188,\n  // bytes\n  SYNC_BYTE = 0x47;\nvar isLikelyAacData = function (data) {\n  if (data[0] === 'I'.charCodeAt(0) && data[1] === 'D'.charCodeAt(0) && data[2] === '3'.charCodeAt(0)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function (bytes, pmt) {\n  var startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet,\n    type;\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function (bytes, pmt, result) {\n  var startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet,\n    type,\n    pesType,\n    pusi,\n    parsed;\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      if (endLoop) {\n        break;\n      }\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      if (endLoop) {\n        break;\n      }\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function (bytes, pmt, result) {\n  var startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet,\n    type,\n    pesType,\n    pusi,\n    parsed,\n    frame,\n    i,\n    pes;\n  var endLoop = false;\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'video';\n              result.video.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n      if (endLoop) {\n        break;\n      }\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function (segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function (info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function (info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function (bytes) {\n  var endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n  var result = {\n    audio: [{\n      type: 'audio',\n      dts: timestamp,\n      pts: timestamp\n    }, {\n      type: 'audio',\n      dts: timestamp + audioCount * 1024 * audioTimescale,\n      pts: timestamp + audioCount * 1024 * audioTimescale\n    }]\n  };\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function (bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n  var result = {};\n  parsePsi_(bytes, pmt);\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function (bytes, baseTimestamp) {\n  var isAacData = isLikelyAacData(bytes);\n  var result;\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n  if (!result || !result.audio && !result.video) {\n    return null;\n  }\n  adjustTimestamp_(result, baseTimestamp);\n  return result;\n};\nmodule.exports = {\n  inspect: inspect\n};","map":{"version":3,"names":["StreamTypes","require","handleRollover","probe","ts","aac","PES_TIMESCALE","MP2T_PACKET_LENGTH","SYNC_BYTE","isLikelyAacData","data","charCodeAt","parsePsi_","bytes","pmt","startIndex","endIndex","packet","type","byteLength","subarray","parseType","pid","parsePat","table","parsePmt","parseAudioPes_","result","pesType","pusi","parsed","endLoop","parsePesType","parsePayloadUnitStartIndicator","parsePesTime","audio","push","parseVideoPes_","frame","i","pes","currentFrame","size","video","firstKeyFrame","Uint8Array","length","shift","set","videoPacketContainsKeyFrame","adjustTimestamp_","segmentInfo","baseTimestamp","audioBaseTimestamp","dts","forEach","info","pts","dtsTime","ptsTime","videoBaseTimestamp","inspectAac_","audioCount","sampleRate","timestamp","frameSize","byteIndex","parseId3TagSize","parseAacTimestamp","parseAdtsSize","parseSampleRate","audioTimescale","inspectTs_","hasOwnProperty","H264_STREAM_TYPE","ADTS_STREAM_TYPE","inspect","isAacData","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/node_modules/mux.js/lib/tools/ts-inspector.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/probe.js');\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}