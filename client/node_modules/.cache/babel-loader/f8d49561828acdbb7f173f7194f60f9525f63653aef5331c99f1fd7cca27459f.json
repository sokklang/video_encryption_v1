{"ast":null,"code":"/**\n * @file playlist.js\n *\n * Playlist related utilities.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _videoJs = require('video.js');\nvar _globalWindow = require('global/window');\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * walk backward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\n\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\n  var result = 0;\n  var i = endSequence - playlist.mediaSequence;\n  // if a start time is available for segment immediately following\n  // the interval, use it\n  var segment = playlist.segments[i];\n\n  // Walk backward until we find the latest segment with timeline\n  // information that is earlier than endSequence\n  if (segment) {\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start,\n        precise: true\n      };\n    }\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - segment.duration,\n        precise: true\n      };\n    }\n  }\n  while (i--) {\n    segment = playlist.segments[i];\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: result + segment.end,\n        precise: true\n      };\n    }\n    result += segment.duration;\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: result + segment.start,\n        precise: true\n      };\n    }\n  }\n  return {\n    result: result,\n    precise: false\n  };\n};\n\n/**\n * walk forward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\n  var result = 0;\n  var segment = undefined;\n  var i = endSequence - playlist.mediaSequence;\n  // Walk forward until we find the earliest segment with timeline\n  // information\n\n  for (; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i];\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start - result,\n        precise: true\n      };\n    }\n    result += segment.duration;\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - result,\n        precise: true\n      };\n    }\n  }\n  // indicate we didn't find a useful duration estimate\n  return {\n    result: -1,\n    precise: false\n  };\n};\n\n/**\n  * Calculate the media duration from the segments associated with a\n  * playlist. The duration of a subinterval of the available segments\n  * may be calculated by specifying an end index.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper boundary\n  * for the playlist.  Defaults to playlist length.\n  * @param {Number} expired the amount of time that has dropped\n  * off the front of the playlist in a live scenario\n  * @return {Number} the duration between the first available segment\n  * and end index.\n  */\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\n  var backward = undefined;\n  var forward = undefined;\n  if (typeof endSequence === 'undefined') {\n    endSequence = playlist.mediaSequence + playlist.segments.length;\n  }\n  if (endSequence < playlist.mediaSequence) {\n    return 0;\n  }\n\n  // do a backward walk to estimate the duration\n  backward = backwardDuration(playlist, endSequence);\n  if (backward.precise) {\n    // if we were able to base our duration estimate on timing\n    // information provided directly from the Media Source, return\n    // it\n    return backward.result;\n  }\n\n  // walk forward to see if a precise duration estimate can be made\n  // that way\n  forward = forwardDuration(playlist, endSequence);\n  if (forward.precise) {\n    // we found a segment that has been buffered and so it's\n    // position is known precisely\n    return forward.result;\n  }\n\n  // return the less-precise, playlist-based duration estimate\n  return backward.result + expired;\n};\n\n/**\n  * Calculates the duration of a playlist. If a start and end index\n  * are specified, the duration will be for the subset of the media\n  * timeline between those two indices. The total duration for live\n  * playlists is always Infinity.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper\n  * boundary for the playlist. Defaults to the playlist media\n  * sequence number plus its length.\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {Number} the duration between the start index and end\n  * index.\n  */\nvar duration = function duration(playlist, endSequence, expired) {\n  if (!playlist) {\n    return 0;\n  }\n  if (typeof expired !== 'number') {\n    expired = 0;\n  }\n\n  // if a slice of the total duration is not requested, use\n  // playlist-level duration indicators when they're present\n  if (typeof endSequence === 'undefined') {\n    // if present, use the duration specified in the playlist\n    if (playlist.totalDuration) {\n      return playlist.totalDuration;\n    }\n\n    // duration should be Infinity for live playlists\n    if (!playlist.endList) {\n      return _globalWindow2['default'].Infinity;\n    }\n  }\n\n  // calculate the total duration based on the segment durations\n  return intervalDuration(playlist, endSequence, expired);\n};\nexports.duration = duration;\n/**\n  * Calculate the time between two indexes in the current playlist\n  * neight the start- nor the end-index need to be within the current\n  * playlist in which case, the targetDuration of the playlist is used\n  * to approximate the durations of the segments\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number} startIndex\n  * @param {Number} endIndex\n  * @return {Number} the number of seconds between startIndex and endIndex\n  */\nvar sumDurations = function sumDurations(playlist, startIndex, endIndex) {\n  var durations = 0;\n  if (startIndex > endIndex) {\n    var _ref = [endIndex, startIndex];\n    startIndex = _ref[0];\n    endIndex = _ref[1];\n  }\n  if (startIndex < 0) {\n    for (var i = startIndex; i < Math.min(0, endIndex); i++) {\n      durations += playlist.targetDuration;\n    }\n    startIndex = 0;\n  }\n  for (var i = startIndex; i < endIndex; i++) {\n    durations += playlist.segments[i].duration;\n  }\n  return durations;\n};\nexports.sumDurations = sumDurations;\n/**\n * Determines the media index of the segment corresponding to the safe edge of the live\n * window which is the duration of the last segment plus 2 target durations from the end\n * of the playlist.\n *\n * @param {Object} playlist\n *        a media playlist object\n * @return {Number}\n *         The media index of the segment at the safe live point. 0 if there is no \"safe\"\n *         point.\n * @function safeLiveIndex\n */\nvar safeLiveIndex = function safeLiveIndex(playlist) {\n  if (!playlist.segments.length) {\n    return 0;\n  }\n  var i = playlist.segments.length - 1;\n  var distanceFromEnd = playlist.segments[i].duration || playlist.targetDuration;\n  var safeDistance = distanceFromEnd + playlist.targetDuration * 2;\n  while (i--) {\n    distanceFromEnd += playlist.segments[i].duration;\n    if (distanceFromEnd >= safeDistance) {\n      break;\n    }\n  }\n  return Math.max(0, i);\n};\nexports.safeLiveIndex = safeLiveIndex;\n/**\n * Calculates the playlist end time\n *\n * @param {Object} playlist a media playlist object\n * @param {Number=} expired the amount of time that has\n *                  dropped off the front of the playlist in a live scenario\n * @param {Boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n *                        playlist end calculation should consider the safe live end\n *                        (truncate the playlist end by three segments). This is normally\n *                        used for calculating the end of the playlist's seekable range.\n * @returns {Number} the end time of playlist\n * @function playlistEnd\n */\nvar playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd) {\n  if (!playlist || !playlist.segments) {\n    return null;\n  }\n  if (playlist.endList) {\n    return duration(playlist);\n  }\n  if (expired === null) {\n    return null;\n  }\n  expired = expired || 0;\n  var endSequence = useSafeLiveEnd ? safeLiveIndex(playlist) : playlist.segments.length;\n  return intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\n};\nexports.playlistEnd = playlistEnd;\n/**\n  * Calculates the interval of time that is currently seekable in a\n  * playlist. The returned time ranges are relative to the earliest\n  * moment in the specified playlist that is still available. A full\n  * seekable implementation for live streams would need to offset\n  * these values by the duration of content that has expired from the\n  * stream.\n  *\n  * @param {Object} playlist a media playlist object\n  * dropped off the front of the playlist in a live scenario\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {TimeRanges} the periods of time that are valid targets\n  * for seeking\n  */\nvar seekable = function seekable(playlist, expired) {\n  var useSafeLiveEnd = true;\n  var seekableStart = expired || 0;\n  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd);\n  if (seekableEnd === null) {\n    return (0, _videoJs.createTimeRange)();\n  }\n  return (0, _videoJs.createTimeRange)(seekableStart, seekableEnd);\n};\nexports.seekable = seekable;\nvar isWholeNumber = function isWholeNumber(num) {\n  return num - Math.floor(num) === 0;\n};\nvar roundSignificantDigit = function roundSignificantDigit(increment, num) {\n  // If we have a whole number, just add 1 to it\n  if (isWholeNumber(num)) {\n    return num + increment * 0.1;\n  }\n  var numDecimalDigits = num.toString().split('.')[1].length;\n  for (var i = 1; i <= numDecimalDigits; i++) {\n    var scale = Math.pow(10, i);\n    var temp = num * scale;\n    if (isWholeNumber(temp) || i === numDecimalDigits) {\n      return (temp + increment) / scale;\n    }\n  }\n};\nvar ceilLeastSignificantDigit = roundSignificantDigit.bind(null, 1);\nvar floorLeastSignificantDigit = roundSignificantDigit.bind(null, -1);\n\n/**\n * Determine the index and estimated starting time of the segment that\n * contains a specified playback position in a media playlist.\n *\n * @param {Object} playlist the media playlist to query\n * @param {Number} currentTime The number of seconds since the earliest\n * possible position to determine the containing segment for\n * @param {Number} startIndex\n * @param {Number} startTime\n * @return {Object}\n */\nvar getMediaInfoForTime = function getMediaInfoForTime(playlist, currentTime, startIndex, startTime) {\n  var i = undefined;\n  var segment = undefined;\n  var numSegments = playlist.segments.length;\n  var time = currentTime - startTime;\n  if (time < 0) {\n    // Walk backward from startIndex in the playlist, adding durations\n    // until we find a segment that contains `time` and return it\n    if (startIndex > 0) {\n      for (i = startIndex - 1; i >= 0; i--) {\n        segment = playlist.segments[i];\n        time += floorLeastSignificantDigit(segment.duration);\n        if (time > 0) {\n          return {\n            mediaIndex: i,\n            startTime: startTime - sumDurations(playlist, startIndex, i)\n          };\n        }\n      }\n    }\n    // We were unable to find a good segment within the playlist\n    // so select the first segment\n    return {\n      mediaIndex: 0,\n      startTime: currentTime\n    };\n  }\n\n  // When startIndex is negative, we first walk forward to first segment\n  // adding target durations. If we \"run out of time\" before getting to\n  // the first segment, return the first segment\n  if (startIndex < 0) {\n    for (i = startIndex; i < 0; i++) {\n      time -= playlist.targetDuration;\n      if (time < 0) {\n        return {\n          mediaIndex: 0,\n          startTime: currentTime\n        };\n      }\n    }\n    startIndex = 0;\n  }\n\n  // Walk forward from startIndex in the playlist, subtracting durations\n  // until we find a segment that contains `time` and return it\n  for (i = startIndex; i < numSegments; i++) {\n    segment = playlist.segments[i];\n    time -= ceilLeastSignificantDigit(segment.duration);\n    if (time < 0) {\n      return {\n        mediaIndex: i,\n        startTime: startTime + sumDurations(playlist, startIndex, i)\n      };\n    }\n  }\n\n  // We are out of possible candidates so load the last one...\n  return {\n    mediaIndex: numSegments - 1,\n    startTime: currentTime\n  };\n};\nexports.getMediaInfoForTime = getMediaInfoForTime;\n/**\n * Check whether the playlist is blacklisted or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is blacklisted or not\n * @function isBlacklisted\n */\nvar isBlacklisted = function isBlacklisted(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n};\nexports.isBlacklisted = isBlacklisted;\n/**\n * Check whether the playlist is compatible with current playback configuration or has\n * been blacklisted permanently for being incompatible.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is incompatible or not\n * @function isIncompatible\n */\nvar isIncompatible = function isIncompatible(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n};\nexports.isIncompatible = isIncompatible;\n/**\n * Check whether the playlist is enabled or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is enabled or not\n * @function isEnabled\n */\nvar isEnabled = function isEnabled(playlist) {\n  var blacklisted = isBlacklisted(playlist);\n  return !playlist.disabled && !blacklisted;\n};\nexports.isEnabled = isEnabled;\n/**\n * Check whether the playlist has been manually disabled through the representations api.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is disabled manually or not\n * @function isDisabled\n */\nvar isDisabled = function isDisabled(playlist) {\n  return playlist.disabled;\n};\nexports.isDisabled = isDisabled;\n/**\n * Returns whether the current playlist is an AES encrypted HLS stream\n *\n * @return {Boolean} true if it's an AES encrypted HLS stream\n */\nvar isAes = function isAes(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].key) {\n      return true;\n    }\n  }\n  return false;\n};\nexports.isAes = isAes;\n/**\n * Returns whether the current playlist contains fMP4\n *\n * @return {Boolean} true if the playlist contains fMP4\n */\nvar isFmp4 = function isFmp4(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].map) {\n      return true;\n    }\n  }\n  return false;\n};\nexports.isFmp4 = isFmp4;\n/**\n * Checks if the playlist has a value for the specified attribute\n *\n * @param {String} attr\n *        Attribute to check for\n * @param {Object} playlist\n *        The media playlist object\n * @return {Boolean}\n *         Whether the playlist contains a value for the attribute or not\n * @function hasAttribute\n */\nvar hasAttribute = function hasAttribute(attr, playlist) {\n  return playlist.attributes && playlist.attributes[attr];\n};\nexports.hasAttribute = hasAttribute;\n/**\n * Estimates the time required to complete a segment download from the specified playlist\n *\n * @param {Number} segmentDuration\n *        Duration of requested segment\n * @param {Number} bandwidth\n *        Current measured bandwidth of the player\n * @param {Object} playlist\n *        The media playlist object\n * @param {Number=} bytesReceived\n *        Number of bytes already received for the request. Defaults to 0\n * @return {Number|NaN}\n *         The estimated time to request the segment. NaN if bandwidth information for\n *         the given playlist is unavailable\n * @function estimateSegmentRequestTime\n */\nvar estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist) {\n  var bytesReceived = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n  if (!hasAttribute('BANDWIDTH', playlist)) {\n    return NaN;\n  }\n  var size = segmentDuration * playlist.attributes.BANDWIDTH;\n  return (size - bytesReceived * 8) / bandwidth;\n};\nexports.estimateSegmentRequestTime = estimateSegmentRequestTime;\n/*\n * Returns whether the current playlist is the lowest rendition\n *\n * @return {Boolean} true if on lowest rendition\n */\nvar isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\n  if (master.playlists.length === 1) {\n    return true;\n  }\n  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n  return master.playlists.filter(function (playlist) {\n    if (!isEnabled(playlist)) {\n      return false;\n    }\n    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n  }).length === 0;\n};\nexports.isLowestEnabledRendition = isLowestEnabledRendition;\n// exports\nexports['default'] = {\n  duration: duration,\n  seekable: seekable,\n  safeLiveIndex: safeLiveIndex,\n  getMediaInfoForTime: getMediaInfoForTime,\n  isEnabled: isEnabled,\n  isDisabled: isDisabled,\n  isBlacklisted: isBlacklisted,\n  isIncompatible: isIncompatible,\n  playlistEnd: playlistEnd,\n  isAes: isAes,\n  isFmp4: isFmp4,\n  hasAttribute: hasAttribute,\n  estimateSegmentRequestTime: estimateSegmentRequestTime,\n  isLowestEnabledRendition: isLowestEnabledRendition\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_videoJs","require","_globalWindow","_globalWindow2","backwardDuration","playlist","endSequence","result","i","mediaSequence","segment","segments","start","precise","end","duration","forwardDuration","undefined","length","intervalDuration","expired","backward","forward","totalDuration","endList","Infinity","sumDurations","startIndex","endIndex","durations","_ref","Math","min","targetDuration","safeLiveIndex","distanceFromEnd","safeDistance","max","playlistEnd","useSafeLiveEnd","seekable","seekableStart","seekableEnd","createTimeRange","isWholeNumber","num","floor","roundSignificantDigit","increment","numDecimalDigits","toString","split","scale","pow","temp","ceilLeastSignificantDigit","bind","floorLeastSignificantDigit","getMediaInfoForTime","currentTime","startTime","numSegments","time","mediaIndex","isBlacklisted","excludeUntil","Date","now","isIncompatible","isEnabled","blacklisted","disabled","isDisabled","isAes","media","key","isFmp4","map","hasAttribute","attr","attributes","estimateSegmentRequestTime","segmentDuration","bandwidth","bytesReceived","arguments","NaN","size","BANDWIDTH","isLowestEnabledRendition","master","playlists","currentBandwidth","Number","MAX_VALUE","filter"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/playlist.js"],"sourcesContent":["/**\n * @file playlist.js\n *\n * Playlist related utilities.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = require('video.js');\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * walk backward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\n\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\n  var result = 0;\n  var i = endSequence - playlist.mediaSequence;\n  // if a start time is available for segment immediately following\n  // the interval, use it\n  var segment = playlist.segments[i];\n\n  // Walk backward until we find the latest segment with timeline\n  // information that is earlier than endSequence\n  if (segment) {\n    if (typeof segment.start !== 'undefined') {\n      return { result: segment.start, precise: true };\n    }\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - segment.duration,\n        precise: true\n      };\n    }\n  }\n  while (i--) {\n    segment = playlist.segments[i];\n    if (typeof segment.end !== 'undefined') {\n      return { result: result + segment.end, precise: true };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.start !== 'undefined') {\n      return { result: result + segment.start, precise: true };\n    }\n  }\n  return { result: result, precise: false };\n};\n\n/**\n * walk forward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\n  var result = 0;\n  var segment = undefined;\n  var i = endSequence - playlist.mediaSequence;\n  // Walk forward until we find the earliest segment with timeline\n  // information\n\n  for (; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i];\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start - result,\n        precise: true\n      };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - result,\n        precise: true\n      };\n    }\n  }\n  // indicate we didn't find a useful duration estimate\n  return { result: -1, precise: false };\n};\n\n/**\n  * Calculate the media duration from the segments associated with a\n  * playlist. The duration of a subinterval of the available segments\n  * may be calculated by specifying an end index.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper boundary\n  * for the playlist.  Defaults to playlist length.\n  * @param {Number} expired the amount of time that has dropped\n  * off the front of the playlist in a live scenario\n  * @return {Number} the duration between the first available segment\n  * and end index.\n  */\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\n  var backward = undefined;\n  var forward = undefined;\n\n  if (typeof endSequence === 'undefined') {\n    endSequence = playlist.mediaSequence + playlist.segments.length;\n  }\n\n  if (endSequence < playlist.mediaSequence) {\n    return 0;\n  }\n\n  // do a backward walk to estimate the duration\n  backward = backwardDuration(playlist, endSequence);\n  if (backward.precise) {\n    // if we were able to base our duration estimate on timing\n    // information provided directly from the Media Source, return\n    // it\n    return backward.result;\n  }\n\n  // walk forward to see if a precise duration estimate can be made\n  // that way\n  forward = forwardDuration(playlist, endSequence);\n  if (forward.precise) {\n    // we found a segment that has been buffered and so it's\n    // position is known precisely\n    return forward.result;\n  }\n\n  // return the less-precise, playlist-based duration estimate\n  return backward.result + expired;\n};\n\n/**\n  * Calculates the duration of a playlist. If a start and end index\n  * are specified, the duration will be for the subset of the media\n  * timeline between those two indices. The total duration for live\n  * playlists is always Infinity.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper\n  * boundary for the playlist. Defaults to the playlist media\n  * sequence number plus its length.\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {Number} the duration between the start index and end\n  * index.\n  */\nvar duration = function duration(playlist, endSequence, expired) {\n  if (!playlist) {\n    return 0;\n  }\n\n  if (typeof expired !== 'number') {\n    expired = 0;\n  }\n\n  // if a slice of the total duration is not requested, use\n  // playlist-level duration indicators when they're present\n  if (typeof endSequence === 'undefined') {\n    // if present, use the duration specified in the playlist\n    if (playlist.totalDuration) {\n      return playlist.totalDuration;\n    }\n\n    // duration should be Infinity for live playlists\n    if (!playlist.endList) {\n      return _globalWindow2['default'].Infinity;\n    }\n  }\n\n  // calculate the total duration based on the segment durations\n  return intervalDuration(playlist, endSequence, expired);\n};\n\nexports.duration = duration;\n/**\n  * Calculate the time between two indexes in the current playlist\n  * neight the start- nor the end-index need to be within the current\n  * playlist in which case, the targetDuration of the playlist is used\n  * to approximate the durations of the segments\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number} startIndex\n  * @param {Number} endIndex\n  * @return {Number} the number of seconds between startIndex and endIndex\n  */\nvar sumDurations = function sumDurations(playlist, startIndex, endIndex) {\n  var durations = 0;\n\n  if (startIndex > endIndex) {\n    var _ref = [endIndex, startIndex];\n    startIndex = _ref[0];\n    endIndex = _ref[1];\n  }\n\n  if (startIndex < 0) {\n    for (var i = startIndex; i < Math.min(0, endIndex); i++) {\n      durations += playlist.targetDuration;\n    }\n    startIndex = 0;\n  }\n\n  for (var i = startIndex; i < endIndex; i++) {\n    durations += playlist.segments[i].duration;\n  }\n\n  return durations;\n};\n\nexports.sumDurations = sumDurations;\n/**\n * Determines the media index of the segment corresponding to the safe edge of the live\n * window which is the duration of the last segment plus 2 target durations from the end\n * of the playlist.\n *\n * @param {Object} playlist\n *        a media playlist object\n * @return {Number}\n *         The media index of the segment at the safe live point. 0 if there is no \"safe\"\n *         point.\n * @function safeLiveIndex\n */\nvar safeLiveIndex = function safeLiveIndex(playlist) {\n  if (!playlist.segments.length) {\n    return 0;\n  }\n\n  var i = playlist.segments.length - 1;\n  var distanceFromEnd = playlist.segments[i].duration || playlist.targetDuration;\n  var safeDistance = distanceFromEnd + playlist.targetDuration * 2;\n\n  while (i--) {\n    distanceFromEnd += playlist.segments[i].duration;\n\n    if (distanceFromEnd >= safeDistance) {\n      break;\n    }\n  }\n\n  return Math.max(0, i);\n};\n\nexports.safeLiveIndex = safeLiveIndex;\n/**\n * Calculates the playlist end time\n *\n * @param {Object} playlist a media playlist object\n * @param {Number=} expired the amount of time that has\n *                  dropped off the front of the playlist in a live scenario\n * @param {Boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n *                        playlist end calculation should consider the safe live end\n *                        (truncate the playlist end by three segments). This is normally\n *                        used for calculating the end of the playlist's seekable range.\n * @returns {Number} the end time of playlist\n * @function playlistEnd\n */\nvar playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd) {\n  if (!playlist || !playlist.segments) {\n    return null;\n  }\n  if (playlist.endList) {\n    return duration(playlist);\n  }\n\n  if (expired === null) {\n    return null;\n  }\n\n  expired = expired || 0;\n\n  var endSequence = useSafeLiveEnd ? safeLiveIndex(playlist) : playlist.segments.length;\n\n  return intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\n};\n\nexports.playlistEnd = playlistEnd;\n/**\n  * Calculates the interval of time that is currently seekable in a\n  * playlist. The returned time ranges are relative to the earliest\n  * moment in the specified playlist that is still available. A full\n  * seekable implementation for live streams would need to offset\n  * these values by the duration of content that has expired from the\n  * stream.\n  *\n  * @param {Object} playlist a media playlist object\n  * dropped off the front of the playlist in a live scenario\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {TimeRanges} the periods of time that are valid targets\n  * for seeking\n  */\nvar seekable = function seekable(playlist, expired) {\n  var useSafeLiveEnd = true;\n  var seekableStart = expired || 0;\n  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd);\n\n  if (seekableEnd === null) {\n    return (0, _videoJs.createTimeRange)();\n  }\n  return (0, _videoJs.createTimeRange)(seekableStart, seekableEnd);\n};\n\nexports.seekable = seekable;\nvar isWholeNumber = function isWholeNumber(num) {\n  return num - Math.floor(num) === 0;\n};\n\nvar roundSignificantDigit = function roundSignificantDigit(increment, num) {\n  // If we have a whole number, just add 1 to it\n  if (isWholeNumber(num)) {\n    return num + increment * 0.1;\n  }\n\n  var numDecimalDigits = num.toString().split('.')[1].length;\n\n  for (var i = 1; i <= numDecimalDigits; i++) {\n    var scale = Math.pow(10, i);\n    var temp = num * scale;\n\n    if (isWholeNumber(temp) || i === numDecimalDigits) {\n      return (temp + increment) / scale;\n    }\n  }\n};\n\nvar ceilLeastSignificantDigit = roundSignificantDigit.bind(null, 1);\nvar floorLeastSignificantDigit = roundSignificantDigit.bind(null, -1);\n\n/**\n * Determine the index and estimated starting time of the segment that\n * contains a specified playback position in a media playlist.\n *\n * @param {Object} playlist the media playlist to query\n * @param {Number} currentTime The number of seconds since the earliest\n * possible position to determine the containing segment for\n * @param {Number} startIndex\n * @param {Number} startTime\n * @return {Object}\n */\nvar getMediaInfoForTime = function getMediaInfoForTime(playlist, currentTime, startIndex, startTime) {\n  var i = undefined;\n  var segment = undefined;\n  var numSegments = playlist.segments.length;\n\n  var time = currentTime - startTime;\n\n  if (time < 0) {\n    // Walk backward from startIndex in the playlist, adding durations\n    // until we find a segment that contains `time` and return it\n    if (startIndex > 0) {\n      for (i = startIndex - 1; i >= 0; i--) {\n        segment = playlist.segments[i];\n        time += floorLeastSignificantDigit(segment.duration);\n        if (time > 0) {\n          return {\n            mediaIndex: i,\n            startTime: startTime - sumDurations(playlist, startIndex, i)\n          };\n        }\n      }\n    }\n    // We were unable to find a good segment within the playlist\n    // so select the first segment\n    return {\n      mediaIndex: 0,\n      startTime: currentTime\n    };\n  }\n\n  // When startIndex is negative, we first walk forward to first segment\n  // adding target durations. If we \"run out of time\" before getting to\n  // the first segment, return the first segment\n  if (startIndex < 0) {\n    for (i = startIndex; i < 0; i++) {\n      time -= playlist.targetDuration;\n      if (time < 0) {\n        return {\n          mediaIndex: 0,\n          startTime: currentTime\n        };\n      }\n    }\n    startIndex = 0;\n  }\n\n  // Walk forward from startIndex in the playlist, subtracting durations\n  // until we find a segment that contains `time` and return it\n  for (i = startIndex; i < numSegments; i++) {\n    segment = playlist.segments[i];\n    time -= ceilLeastSignificantDigit(segment.duration);\n    if (time < 0) {\n      return {\n        mediaIndex: i,\n        startTime: startTime + sumDurations(playlist, startIndex, i)\n      };\n    }\n  }\n\n  // We are out of possible candidates so load the last one...\n  return {\n    mediaIndex: numSegments - 1,\n    startTime: currentTime\n  };\n};\n\nexports.getMediaInfoForTime = getMediaInfoForTime;\n/**\n * Check whether the playlist is blacklisted or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is blacklisted or not\n * @function isBlacklisted\n */\nvar isBlacklisted = function isBlacklisted(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n};\n\nexports.isBlacklisted = isBlacklisted;\n/**\n * Check whether the playlist is compatible with current playback configuration or has\n * been blacklisted permanently for being incompatible.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is incompatible or not\n * @function isIncompatible\n */\nvar isIncompatible = function isIncompatible(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n};\n\nexports.isIncompatible = isIncompatible;\n/**\n * Check whether the playlist is enabled or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is enabled or not\n * @function isEnabled\n */\nvar isEnabled = function isEnabled(playlist) {\n  var blacklisted = isBlacklisted(playlist);\n\n  return !playlist.disabled && !blacklisted;\n};\n\nexports.isEnabled = isEnabled;\n/**\n * Check whether the playlist has been manually disabled through the representations api.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is disabled manually or not\n * @function isDisabled\n */\nvar isDisabled = function isDisabled(playlist) {\n  return playlist.disabled;\n};\n\nexports.isDisabled = isDisabled;\n/**\n * Returns whether the current playlist is an AES encrypted HLS stream\n *\n * @return {Boolean} true if it's an AES encrypted HLS stream\n */\nvar isAes = function isAes(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].key) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexports.isAes = isAes;\n/**\n * Returns whether the current playlist contains fMP4\n *\n * @return {Boolean} true if the playlist contains fMP4\n */\nvar isFmp4 = function isFmp4(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].map) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexports.isFmp4 = isFmp4;\n/**\n * Checks if the playlist has a value for the specified attribute\n *\n * @param {String} attr\n *        Attribute to check for\n * @param {Object} playlist\n *        The media playlist object\n * @return {Boolean}\n *         Whether the playlist contains a value for the attribute or not\n * @function hasAttribute\n */\nvar hasAttribute = function hasAttribute(attr, playlist) {\n  return playlist.attributes && playlist.attributes[attr];\n};\n\nexports.hasAttribute = hasAttribute;\n/**\n * Estimates the time required to complete a segment download from the specified playlist\n *\n * @param {Number} segmentDuration\n *        Duration of requested segment\n * @param {Number} bandwidth\n *        Current measured bandwidth of the player\n * @param {Object} playlist\n *        The media playlist object\n * @param {Number=} bytesReceived\n *        Number of bytes already received for the request. Defaults to 0\n * @return {Number|NaN}\n *         The estimated time to request the segment. NaN if bandwidth information for\n *         the given playlist is unavailable\n * @function estimateSegmentRequestTime\n */\nvar estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist) {\n  var bytesReceived = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n  if (!hasAttribute('BANDWIDTH', playlist)) {\n    return NaN;\n  }\n\n  var size = segmentDuration * playlist.attributes.BANDWIDTH;\n\n  return (size - bytesReceived * 8) / bandwidth;\n};\n\nexports.estimateSegmentRequestTime = estimateSegmentRequestTime;\n/*\n * Returns whether the current playlist is the lowest rendition\n *\n * @return {Boolean} true if on lowest rendition\n */\nvar isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\n  if (master.playlists.length === 1) {\n    return true;\n  }\n\n  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n\n  return master.playlists.filter(function (playlist) {\n    if (!isEnabled(playlist)) {\n      return false;\n    }\n\n    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n  }).length === 0;\n};\n\nexports.isLowestEnabledRendition = isLowestEnabledRendition;\n// exports\nexports['default'] = {\n  duration: duration,\n  seekable: seekable,\n  safeLiveIndex: safeLiveIndex,\n  getMediaInfoForTime: getMediaInfoForTime,\n  isEnabled: isEnabled,\n  isDisabled: isDisabled,\n  isBlacklisted: isBlacklisted,\n  isIncompatible: isIncompatible,\n  playlistEnd: playlistEnd,\n  isAes: isAes,\n  isFmp4: isFmp4,\n  hasAttribute: hasAttribute,\n  estimateSegmentRequestTime: estimateSegmentRequestTime,\n  isLowestEnabledRendition: isLowestEnabledRendition\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}