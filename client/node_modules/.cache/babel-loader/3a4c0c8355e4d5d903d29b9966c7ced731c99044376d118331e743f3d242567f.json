{"ast":null,"code":"'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar FlvTag = require('./flv-tag.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar CoalesceStream = require('./coalesce-stream.js');\nvar TagList = require('./tag-list.js');\nvar Transmuxer, VideoSegmentStream, AudioSegmentStream, collectTimelineInfo, metaDataTag, extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function (track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts = Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts = Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\nmetaDataTag = function (track, pts) {\n  var tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n  return tag;\n};\nextraDataTag = function (track, pts) {\n  var i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n  tag.dts = pts;\n  tag.pts = pts;\n  tag.writeByte(0x01); // version\n  tag.writeByte(track.profileIdc); // profile\n  tag.writeByte(track.profileCompatibility); // compatibility\n  tag.writeByte(track.levelIdc); // level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function (track) {\n  var adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n  AudioSegmentStream.prototype.init.call(this);\n  this.push = function (data) {\n    collectTimelineInfo(track, data);\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = track.audioobjecttype << 11 | track.samplingfrequencyindex << 7 | track.channelcount << 3;\n    }\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n  this.flush = function () {\n    var currentFrame,\n      adtsFrame,\n      lastMetaPts,\n      tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n    lastMetaPts = -Infinity;\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n      adtsFrame.writeBytes(currentFrame.data);\n      tags.push(adtsFrame.finalize());\n    }\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {\n      track: track,\n      tags: tags.list\n    });\n    this.trigger('done', 'AudioSegmentStream');\n  };\n  this.writeMetaDataTags = function (tags, pts) {\n    var adtsFrame;\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n    tags.push(adtsFrame.finalize());\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n    tags.push(adtsFrame.finalize());\n  };\n  this.onVideoKeyFrame = function (pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function (track) {\n  var nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n  this.finishFrame = function (tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata && (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n      this.trigger('keyframe', frame.dts);\n    }\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n  this.push = function (data) {\n    collectTimelineInfo(track, data);\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n  this.flush = function () {\n    var currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n    this.trigger('data', {\n      track: track,\n      tags: tags.list\n    });\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function (options) {\n  var self = this,\n    packetStream,\n    parseStream,\n    elementaryStream,\n    videoTimestampRolloverStream,\n    audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream,\n    h264Stream,\n    videoSegmentStream,\n    audioSegmentStream,\n    captionStream,\n    coalesceStream;\n  Transmuxer.prototype.init.call(this);\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream.pipe(parseStream).pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream.pipe(videoTimestampRolloverStream).pipe(h264Stream);\n  elementaryStream.pipe(audioTimestampRolloverStream).pipe(adtsStream);\n  elementaryStream.pipe(timedMetadataTimestampRolloverStream).pipe(this.metadataStream).pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream).pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function (data) {\n    var i, videoTrack, audioTrack;\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream.pipe(videoSegmentStream).pipe(coalesceStream);\n      }\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream.pipe(audioSegmentStream).pipe(coalesceStream);\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function (data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function () {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function () {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function (event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function () {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;","map":{"version":3,"names":["Stream","require","FlvTag","m2ts","AdtsStream","H264Stream","CoalesceStream","TagList","Transmuxer","VideoSegmentStream","AudioSegmentStream","collectTimelineInfo","metaDataTag","extraDataTag","track","data","pts","timelineStartInfo","undefined","Math","min","dts","tag","METADATA_TAG","writeMetaDataDouble","width","height","i","VIDEO_TAG","writeByte","profileIdc","profileCompatibility","levelIdc","writeShort","sps","length","writeBytes","pps","adtsFrames","videoKeyFrames","oldExtraData","prototype","init","call","push","audioobjecttype","channelcount","samplerate","samplingfrequencyindex","samplesize","extraData","round","flush","currentFrame","adtsFrame","lastMetaPts","tags","trigger","Infinity","shift","writeMetaDataTags","AUDIO_TAG","finalize","list","writeMetaDataBoolean","view","setUint16","position","max","onVideoKeyFrame","nalUnits","config","h264Frame","finishFrame","frame","newMetadata","keyFrame","metaTag","extraTag","endNalUnit","currentNal","nalUnitType","startNalUnit","options","self","packetStream","parseStream","elementaryStream","videoTimestampRolloverStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","h264Stream","videoSegmentStream","audioSegmentStream","captionStream","coalesceStream","metadataStream","MetadataStream","TransportPacketStream","TransportParseStream","ElementaryStream","TimestampRolloverStream","pipe","CaptionStream","on","videoTrack","audioTrack","type","tracks","numberOfTracks","resetCaptions","reset","event","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/transmuxer.js"],"sourcesContent":["'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar FlvTag = require('./flv-tag.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar CoalesceStream = require('./coalesce-stream.js');\nvar TagList = require('./tag-list.js');\n\nvar\n  Transmuxer,\n  VideoSegmentStream,\n  AudioSegmentStream,\n  collectTimelineInfo,\n  metaDataTag,\n  extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts =\n        Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts =\n        Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function(track, pts) {\n  var\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n\n  return tag;\n};\n\nextraDataTag = function(track, pts) {\n  var\n    i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeByte(0x01);// version\n  tag.writeByte(track.profileIdc);// profile\n  tag.writeByte(track.profileCompatibility);// compatibility\n  tag.writeByte(track.levelIdc);// level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = (track.audioobjecttype << 11) |\n                        (track.samplingfrequencyindex << 7) |\n                        (track.channelcount << 3);\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.flush = function() {\n    var currentFrame, adtsFrame, lastMetaPts, tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n\n      adtsFrame.writeBytes(currentFrame.data);\n\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {track: track, tags: tags.list});\n\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function(tags, pts) {\n    var adtsFrame;\n\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n\n    tags.push(adtsFrame.finalize());\n\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function(pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function(track) {\n  var\n    nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function(tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata &&\n        (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n\n  this.flush = function() {\n    var\n      currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {track: track, tags: tags.list});\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n\n    packetStream, parseStream, elementaryStream,\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream, h264Stream,\n    videoSegmentStream, audioSegmentStream, captionStream,\n    coalesceStream;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream\n    .pipe(parseStream)\n    .pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream\n    .pipe(videoTimestampRolloverStream)\n    .pipe(h264Stream);\n  elementaryStream\n    .pipe(audioTimestampRolloverStream)\n    .pipe(adtsStream);\n\n  elementaryStream\n    .pipe(timedMetadataTimestampRolloverStream)\n    .pipe(this.metadataStream)\n    .pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream)\n    .pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function(data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream\n          .pipe(videoSegmentStream)\n          .pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream\n          .pipe(audioSegmentStream)\n          .pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function(event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function() {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}