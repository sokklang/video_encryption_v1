{"ast":null,"code":"/**\n * @file sync-controller.js\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _get = function get(_x2, _x3, _x4) {\n  var _again = true;\n  _function: while (_again) {\n    var object = _x2,\n      property = _x3,\n      receiver = _x4;\n    _again = false;\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n      if (parent === null) {\n        return undefined;\n      } else {\n        _x2 = parent;\n        _x3 = property;\n        _x4 = receiver;\n        _again = true;\n        desc = parent = undefined;\n        continue _function;\n      }\n    } else if ('value' in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return getter.call(receiver);\n    }\n  }\n};\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar _muxJsLibMp4Probe = require('mux.js/lib/mp4/probe');\nvar _muxJsLibMp4Probe2 = _interopRequireDefault(_muxJsLibMp4Probe);\nvar _muxJsLibToolsTsInspectorJs = require('mux.js/lib/tools/ts-inspector.js');\nvar _playlist = require('./playlist');\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar syncPointStrategies = [\n// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n//                the equivalence display-time 0 === segment-index 0\n{\n  name: 'VOD',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (duration !== Infinity) {\n      var syncPoint = {\n        time: 0,\n        segmentIndex: 0\n      };\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n{\n  name: 'ProgramDateTime',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (syncController.datetimeToDisplayTime && playlist.dateTimeObject) {\n      var playlistTime = playlist.dateTimeObject.getTime() / 1000;\n      var playlistStart = playlistTime + syncController.datetimeToDisplayTime;\n      var syncPoint = {\n        time: playlistStart,\n        segmentIndex: 0\n      };\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"Segment\": We have a known time mapping for a timeline and a\n//                    segment in the current timeline with timing data\n{\n  name: 'Segment',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n    currentTime = currentTime || 0;\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment.timeline === currentTimeline && typeof segment.start !== 'undefined') {\n        var distance = Math.abs(currentTime - segment.start);\n\n        // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n          lastDistance = distance;\n          syncPoint = {\n            time: segment.start,\n            segmentIndex: i\n          };\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Discontinuity\": We have a discontinuity with a known\n//                          display-time\n{\n  name: 'Discontinuity',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var syncPoint = null;\n    currentTime = currentTime || 0;\n    if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      var lastDistance = null;\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var discontinuitySync = syncController.discontinuities[discontinuity];\n        if (discontinuitySync) {\n          var distance = Math.abs(currentTime - discontinuitySync.time);\n\n          // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: discontinuitySync.time,\n              segmentIndex: segmentIndex\n            };\n          }\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Playlist\": We have a playlist with a known mapping of\n//                     segment index to display time\n{\n  name: 'Playlist',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (playlist.syncInfo) {\n      var syncPoint = {\n        time: playlist.syncInfo.time,\n        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence\n      };\n      return syncPoint;\n    }\n    return null;\n  }\n}];\nexports.syncPointStrategies = syncPointStrategies;\nvar SyncController = function (_videojs$EventTarget) {\n  _inherits(SyncController, _videojs$EventTarget);\n  function SyncController() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    _classCallCheck(this, SyncController);\n    _get(Object.getPrototypeOf(SyncController.prototype), 'constructor', this).call(this);\n    // Segment Loader state variables...\n    // ...for synching across variants\n    this.inspectCache_ = undefined;\n\n    // ...for synching across variants\n    this.timelines = [];\n    this.discontinuities = [];\n    this.datetimeToDisplayTime = null;\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'sync-controller ->');\n    }\n  }\n\n  /**\n   * Find a sync-point for the playlist specified\n   *\n   * A sync-point is defined as a known mapping from display-time to\n   * a segment-index in the current playlist.\n   *\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {Number} duration\n   *        Duration of the MediaSource (Infinite if playing a live source)\n   * @param {Number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @returns {Object}\n   *          A sync-point object\n   */\n\n  _createClass(SyncController, [{\n    key: 'getSyncPoint',\n    value: function getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n      if (!syncPoints.length) {\n        // Signal that we need to attempt to get a sync-point manually\n        // by fetching a segment in the playlist and constructing\n        // a sync-point from that information\n        return null;\n      }\n\n      // Now find the sync-point that is closest to the currentTime because\n      // that should result in the most accurate guess about which segment\n      // to fetch\n      return this.selectSyncPoint_(syncPoints, {\n        key: 'time',\n        value: currentTime\n      });\n    }\n\n    /**\n     * Calculate the amount of time that has expired off the playlist during playback\n     *\n     * @param {Playlist} playlist\n     *        Playlist object to calculate expired from\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playling a live source)\n     * @returns {Number|null}\n     *          The amount of time that has expired off the playlist during playback. Null\n     *          if no sync-points for the playlist can be found.\n     */\n  }, {\n    key: 'getExpiredTime',\n    value: function getExpiredTime(playlist, duration) {\n      if (!playlist || !playlist.segments) {\n        return null;\n      }\n      var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);\n\n      // Without sync-points, there is not enough information to determine the expired time\n      if (!syncPoints.length) {\n        return null;\n      }\n      var syncPoint = this.selectSyncPoint_(syncPoints, {\n        key: 'segmentIndex',\n        value: 0\n      });\n\n      // If the sync-point is beyond the start of the playlist, we want to subtract the\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\n      if (syncPoint.segmentIndex > 0) {\n        syncPoint.time *= -1;\n      }\n      return Math.abs(syncPoint.time + (0, _playlist.sumDurations)(playlist, syncPoint.segmentIndex, 0));\n    }\n\n    /**\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\n     * strategies\n     *\n     * @private\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playing a live source)\n     * @param {Number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @returns {Array}\n     *          A list of sync-point objects\n     */\n  }, {\n    key: 'runStrategies_',\n    value: function runStrategies_(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = [];\n\n      // Try to find a sync-point in by utilizing various strategies...\n      for (var i = 0; i < syncPointStrategies.length; i++) {\n        var strategy = syncPointStrategies[i];\n        var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n        if (syncPoint) {\n          syncPoint.strategy = strategy.name;\n          syncPoints.push({\n            strategy: strategy.name,\n            syncPoint: syncPoint\n          });\n          this.logger_('syncPoint found via <' + strategy.name + '>:', syncPoint);\n        }\n      }\n      return syncPoints;\n    }\n\n    /**\n     * Selects the sync-point nearest the specified target\n     *\n     * @private\n     * @param {Array} syncPoints\n     *        List of sync-points to select from\n     * @param {Object} target\n     *        Object specifying the property and value we are targeting\n     * @param {String} target.key\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n     * @param {Number} target.value\n     *        The value to target for the specified key.\n     * @returns {Object}\n     *          The sync-point nearest the target\n     */\n  }, {\n    key: 'selectSyncPoint_',\n    value: function selectSyncPoint_(syncPoints, target) {\n      var bestSyncPoint = syncPoints[0].syncPoint;\n      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n      var bestStrategy = syncPoints[0].strategy;\n      for (var i = 1; i < syncPoints.length; i++) {\n        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          bestSyncPoint = syncPoints[i].syncPoint;\n          bestStrategy = syncPoints[i].strategy;\n        }\n      }\n      this.logger_('syncPoint with strategy <' + bestStrategy + '> chosen: ', bestSyncPoint);\n      return bestSyncPoint;\n    }\n\n    /**\n     * Save any meta-data present on the segments when segments leave\n     * the live window to the playlist to allow for synchronization at the\n     * playlist level later.\n     *\n     * @param {Playlist} oldPlaylist - The previous active playlist\n     * @param {Playlist} newPlaylist - The updated and most current playlist\n     */\n  }, {\n    key: 'saveExpiredSegmentInfo',\n    value: function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      // When a segment expires from the playlist and it has a start time\n      // save that information as a possible sync-point reference in future\n      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\n        var lastRemovedSegment = oldPlaylist.segments[i];\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n          newPlaylist.syncInfo = {\n            mediaSequence: oldPlaylist.mediaSequence + i,\n            time: lastRemovedSegment.start\n          };\n          this.logger_('playlist sync:', newPlaylist.syncInfo);\n          this.trigger('syncinfoupdate');\n          break;\n        }\n      }\n    }\n\n    /**\n     * Save the mapping from playlist's ProgramDateTime to display. This should\n     * only ever happen once at the start of playback.\n     *\n     * @param {Playlist} playlist - The currently active playlist\n     */\n  }, {\n    key: 'setDateTimeMapping',\n    value: function setDateTimeMapping(playlist) {\n      if (!this.datetimeToDisplayTime && playlist.dateTimeObject) {\n        var playlistTimestamp = playlist.dateTimeObject.getTime() / 1000;\n        this.datetimeToDisplayTime = -playlistTimestamp;\n      }\n    }\n\n    /**\n     * Reset the state of the inspection cache when we do a rendition\n     * switch\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.inspectCache_ = undefined;\n    }\n\n    /**\n     * Probe or inspect a fmp4 or an mpeg2-ts segment to determine the start\n     * and end of the segment in it's internal \"media time\". Used to generate\n     * mappings from that internal \"media time\" to the display time that is\n     * shown on the player.\n     *\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'probeSegmentInfo',\n    value: function probeSegmentInfo(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var playlist = segmentInfo.playlist;\n      var timingInfo = undefined;\n      if (segment.map) {\n        timingInfo = this.probeMp4Segment_(segmentInfo);\n      } else {\n        timingInfo = this.probeTsSegment_(segmentInfo);\n      }\n      if (timingInfo) {\n        if (this.calculateSegmentTimeMapping_(segmentInfo, timingInfo)) {\n          this.saveDiscontinuitySyncInfo_(segmentInfo);\n\n          // If the playlist does not have sync information yet, record that information\n          // now with segment timing information\n          if (!playlist.syncInfo) {\n            playlist.syncInfo = {\n              mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n              time: segment.start\n            };\n          }\n        }\n      }\n      return timingInfo;\n    }\n\n    /**\n     * Probe an fmp4 or an mpeg2-ts segment to determine the start of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeMp4Segment_',\n    value: function probeMp4Segment_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var timescales = _muxJsLibMp4Probe2['default'].timescale(segment.map.bytes);\n      var startTime = _muxJsLibMp4Probe2['default'].startTime(timescales, segmentInfo.bytes);\n      if (segmentInfo.timestampOffset !== null) {\n        segmentInfo.timestampOffset -= startTime;\n      }\n      return {\n        start: startTime,\n        end: startTime + segment.duration\n      };\n    }\n\n    /**\n     * Probe an mpeg2-ts segment to determine the start and end of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeTsSegment_',\n    value: function probeTsSegment_(segmentInfo) {\n      var timeInfo = (0, _muxJsLibToolsTsInspectorJs.inspect)(segmentInfo.bytes, this.inspectCache_);\n      var segmentStartTime = undefined;\n      var segmentEndTime = undefined;\n      if (!timeInfo) {\n        return null;\n      }\n      if (timeInfo.video && timeInfo.video.length === 2) {\n        this.inspectCache_ = timeInfo.video[1].dts;\n        segmentStartTime = timeInfo.video[0].dtsTime;\n        segmentEndTime = timeInfo.video[1].dtsTime;\n      } else if (timeInfo.audio && timeInfo.audio.length === 2) {\n        this.inspectCache_ = timeInfo.audio[1].dts;\n        segmentStartTime = timeInfo.audio[0].dtsTime;\n        segmentEndTime = timeInfo.audio[1].dtsTime;\n      }\n      return {\n        start: segmentStartTime,\n        end: segmentEndTime,\n        containsVideo: timeInfo.video && timeInfo.video.length === 2,\n        containsAudio: timeInfo.audio && timeInfo.audio.length === 2\n      };\n    }\n  }, {\n    key: 'timestampOffsetForTimeline',\n    value: function timestampOffsetForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].time;\n    }\n  }, {\n    key: 'mappingForTimeline',\n    value: function mappingForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].mapping;\n    }\n\n    /**\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n     * save that display time to the segment.\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo\n     *        The current active request information\n     * @param {object} timingInfo\n     *        The start and end time of the current segment in \"media time\"\n     * @returns {Boolean}\n     *          Returns false if segment time mapping could not be calculated\n     */\n  }, {\n    key: 'calculateSegmentTimeMapping_',\n    value: function calculateSegmentTimeMapping_(segmentInfo, timingInfo) {\n      var segment = segmentInfo.segment;\n      var mappingObj = this.timelines[segmentInfo.timeline];\n      if (segmentInfo.timestampOffset !== null) {\n        this.logger_('tsO:', segmentInfo.timestampOffset);\n        mappingObj = {\n          time: segmentInfo.startOfSegment,\n          mapping: segmentInfo.startOfSegment - timingInfo.start\n        };\n        this.timelines[segmentInfo.timeline] = mappingObj;\n        this.trigger('timestampoffset');\n        segment.start = segmentInfo.startOfSegment;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else if (mappingObj) {\n        segment.start = timingInfo.start + mappingObj.mapping;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\n     * in display of the start of the discontinuity and save that. We also save an accuracy\n     * value so that we save values with the most accuracy (closest to 0.)\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'saveDiscontinuitySyncInfo_',\n    value: function saveDiscontinuitySyncInfo_(segmentInfo) {\n      var playlist = segmentInfo.playlist;\n      var segment = segmentInfo.segment;\n\n      // If the current segment is a discontinuity then we know exactly where\n      // the start of the range and it's accuracy is 0 (greater accuracy values\n      // mean more approximation)\n      if (segment.discontinuity) {\n        this.discontinuities[segment.timeline] = {\n          time: segment.start,\n          accuracy: 0\n        };\n      } else if (playlist.discontinuityStarts.length) {\n        // Search for future discontinuities that we can provide better timing\n        // information for and save that information for sync purposes\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n          var segmentIndex = playlist.discontinuityStarts[i];\n          var discontinuity = playlist.discontinuitySequence + i + 1;\n          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n          var accuracy = Math.abs(mediaIndexDiff);\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n            var time = undefined;\n            if (mediaIndexDiff < 0) {\n              time = segment.start - (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex, segmentIndex);\n            } else {\n              time = segment.end + (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex + 1, segmentIndex);\n            }\n            this.discontinuities[discontinuity] = {\n              time: time,\n              accuracy: accuracy\n            };\n          }\n        }\n      }\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n  }]);\n  return SyncController;\n}(_videoJs2['default'].EventTarget);\nexports['default'] = SyncController;","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_get","get","_x2","_x3","_x4","_again","_function","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","call","_interopRequireDefault","obj","__esModule","_classCallCheck","instance","TypeError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_muxJsLibMp4Probe","require","_muxJsLibMp4Probe2","_muxJsLibToolsTsInspectorJs","_playlist","_videoJs","_videoJs2","syncPointStrategies","name","run","syncController","playlist","duration","currentTimeline","currentTime","Infinity","syncPoint","time","segmentIndex","datetimeToDisplayTime","dateTimeObject","playlistTime","getTime","playlistStart","segments","lastDistance","segment","timeline","start","distance","Math","abs","discontinuityStarts","discontinuity","discontinuitySequence","discontinuitySync","discontinuities","syncInfo","mediaSequence","SyncController","_videojs$EventTarget","options","arguments","inspectCache_","timelines","debug","logger_","log","bind","getSyncPoint","syncPoints","runStrategies_","selectSyncPoint_","getExpiredTime","sumDurations","strategy","push","bestSyncPoint","bestDistance","bestStrategy","newDistance","saveExpiredSegmentInfo","oldPlaylist","newPlaylist","mediaSequenceDiff","lastRemovedSegment","trigger","setDateTimeMapping","playlistTimestamp","reset","probeSegmentInfo","segmentInfo","timingInfo","map","probeMp4Segment_","probeTsSegment_","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","mediaIndex","timescales","timescale","bytes","startTime","timestampOffset","end","timeInfo","inspect","segmentStartTime","segmentEndTime","video","dts","dtsTime","audio","containsVideo","containsAudio","timestampOffsetForTimeline","mappingForTimeline","mapping","mappingObj","startOfSegment","accuracy","mediaIndexDiff","EventTarget"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/sync-controller.js"],"sourcesContent":["/**\n * @file sync-controller.js\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _muxJsLibMp4Probe = require('mux.js/lib/mp4/probe');\n\nvar _muxJsLibMp4Probe2 = _interopRequireDefault(_muxJsLibMp4Probe);\n\nvar _muxJsLibToolsTsInspectorJs = require('mux.js/lib/tools/ts-inspector.js');\n\nvar _playlist = require('./playlist');\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar syncPointStrategies = [\n// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n//                the equivalence display-time 0 === segment-index 0\n{\n  name: 'VOD',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (duration !== Infinity) {\n      var syncPoint = {\n        time: 0,\n        segmentIndex: 0\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n{\n  name: 'ProgramDateTime',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (syncController.datetimeToDisplayTime && playlist.dateTimeObject) {\n      var playlistTime = playlist.dateTimeObject.getTime() / 1000;\n      var playlistStart = playlistTime + syncController.datetimeToDisplayTime;\n      var syncPoint = {\n        time: playlistStart,\n        segmentIndex: 0\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"Segment\": We have a known time mapping for a timeline and a\n//                    segment in the current timeline with timing data\n{\n  name: 'Segment',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.timeline === currentTimeline && typeof segment.start !== 'undefined') {\n        var distance = Math.abs(currentTime - segment.start);\n\n        // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n\n        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n          lastDistance = distance;\n          syncPoint = {\n            time: segment.start,\n            segmentIndex: i\n          };\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Discontinuity\": We have a discontinuity with a known\n//                          display-time\n{\n  name: 'Discontinuity',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var syncPoint = null;\n\n    currentTime = currentTime || 0;\n\n    if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      var lastDistance = null;\n\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var discontinuitySync = syncController.discontinuities[discontinuity];\n\n        if (discontinuitySync) {\n          var distance = Math.abs(currentTime - discontinuitySync.time);\n\n          // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: discontinuitySync.time,\n              segmentIndex: segmentIndex\n            };\n          }\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Playlist\": We have a playlist with a known mapping of\n//                     segment index to display time\n{\n  name: 'Playlist',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (playlist.syncInfo) {\n      var syncPoint = {\n        time: playlist.syncInfo.time,\n        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n}];\n\nexports.syncPointStrategies = syncPointStrategies;\n\nvar SyncController = (function (_videojs$EventTarget) {\n  _inherits(SyncController, _videojs$EventTarget);\n\n  function SyncController() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, SyncController);\n\n    _get(Object.getPrototypeOf(SyncController.prototype), 'constructor', this).call(this);\n    // Segment Loader state variables...\n    // ...for synching across variants\n    this.inspectCache_ = undefined;\n\n    // ...for synching across variants\n    this.timelines = [];\n    this.discontinuities = [];\n    this.datetimeToDisplayTime = null;\n\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'sync-controller ->');\n    }\n  }\n\n  /**\n   * Find a sync-point for the playlist specified\n   *\n   * A sync-point is defined as a known mapping from display-time to\n   * a segment-index in the current playlist.\n   *\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {Number} duration\n   *        Duration of the MediaSource (Infinite if playing a live source)\n   * @param {Number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @returns {Object}\n   *          A sync-point object\n   */\n\n  _createClass(SyncController, [{\n    key: 'getSyncPoint',\n    value: function getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n\n      if (!syncPoints.length) {\n        // Signal that we need to attempt to get a sync-point manually\n        // by fetching a segment in the playlist and constructing\n        // a sync-point from that information\n        return null;\n      }\n\n      // Now find the sync-point that is closest to the currentTime because\n      // that should result in the most accurate guess about which segment\n      // to fetch\n      return this.selectSyncPoint_(syncPoints, { key: 'time', value: currentTime });\n    }\n\n    /**\n     * Calculate the amount of time that has expired off the playlist during playback\n     *\n     * @param {Playlist} playlist\n     *        Playlist object to calculate expired from\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playling a live source)\n     * @returns {Number|null}\n     *          The amount of time that has expired off the playlist during playback. Null\n     *          if no sync-points for the playlist can be found.\n     */\n  }, {\n    key: 'getExpiredTime',\n    value: function getExpiredTime(playlist, duration) {\n      if (!playlist || !playlist.segments) {\n        return null;\n      }\n\n      var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);\n\n      // Without sync-points, there is not enough information to determine the expired time\n      if (!syncPoints.length) {\n        return null;\n      }\n\n      var syncPoint = this.selectSyncPoint_(syncPoints, {\n        key: 'segmentIndex',\n        value: 0\n      });\n\n      // If the sync-point is beyond the start of the playlist, we want to subtract the\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\n      if (syncPoint.segmentIndex > 0) {\n        syncPoint.time *= -1;\n      }\n\n      return Math.abs(syncPoint.time + (0, _playlist.sumDurations)(playlist, syncPoint.segmentIndex, 0));\n    }\n\n    /**\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\n     * strategies\n     *\n     * @private\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playing a live source)\n     * @param {Number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @returns {Array}\n     *          A list of sync-point objects\n     */\n  }, {\n    key: 'runStrategies_',\n    value: function runStrategies_(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = [];\n\n      // Try to find a sync-point in by utilizing various strategies...\n      for (var i = 0; i < syncPointStrategies.length; i++) {\n        var strategy = syncPointStrategies[i];\n        var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n\n        if (syncPoint) {\n          syncPoint.strategy = strategy.name;\n          syncPoints.push({\n            strategy: strategy.name,\n            syncPoint: syncPoint\n          });\n          this.logger_('syncPoint found via <' + strategy.name + '>:', syncPoint);\n        }\n      }\n\n      return syncPoints;\n    }\n\n    /**\n     * Selects the sync-point nearest the specified target\n     *\n     * @private\n     * @param {Array} syncPoints\n     *        List of sync-points to select from\n     * @param {Object} target\n     *        Object specifying the property and value we are targeting\n     * @param {String} target.key\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n     * @param {Number} target.value\n     *        The value to target for the specified key.\n     * @returns {Object}\n     *          The sync-point nearest the target\n     */\n  }, {\n    key: 'selectSyncPoint_',\n    value: function selectSyncPoint_(syncPoints, target) {\n      var bestSyncPoint = syncPoints[0].syncPoint;\n      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n      var bestStrategy = syncPoints[0].strategy;\n\n      for (var i = 1; i < syncPoints.length; i++) {\n        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          bestSyncPoint = syncPoints[i].syncPoint;\n          bestStrategy = syncPoints[i].strategy;\n        }\n      }\n\n      this.logger_('syncPoint with strategy <' + bestStrategy + '> chosen: ', bestSyncPoint);\n      return bestSyncPoint;\n    }\n\n    /**\n     * Save any meta-data present on the segments when segments leave\n     * the live window to the playlist to allow for synchronization at the\n     * playlist level later.\n     *\n     * @param {Playlist} oldPlaylist - The previous active playlist\n     * @param {Playlist} newPlaylist - The updated and most current playlist\n     */\n  }, {\n    key: 'saveExpiredSegmentInfo',\n    value: function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      // When a segment expires from the playlist and it has a start time\n      // save that information as a possible sync-point reference in future\n      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\n        var lastRemovedSegment = oldPlaylist.segments[i];\n\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n          newPlaylist.syncInfo = {\n            mediaSequence: oldPlaylist.mediaSequence + i,\n            time: lastRemovedSegment.start\n          };\n          this.logger_('playlist sync:', newPlaylist.syncInfo);\n          this.trigger('syncinfoupdate');\n          break;\n        }\n      }\n    }\n\n    /**\n     * Save the mapping from playlist's ProgramDateTime to display. This should\n     * only ever happen once at the start of playback.\n     *\n     * @param {Playlist} playlist - The currently active playlist\n     */\n  }, {\n    key: 'setDateTimeMapping',\n    value: function setDateTimeMapping(playlist) {\n      if (!this.datetimeToDisplayTime && playlist.dateTimeObject) {\n        var playlistTimestamp = playlist.dateTimeObject.getTime() / 1000;\n\n        this.datetimeToDisplayTime = -playlistTimestamp;\n      }\n    }\n\n    /**\n     * Reset the state of the inspection cache when we do a rendition\n     * switch\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.inspectCache_ = undefined;\n    }\n\n    /**\n     * Probe or inspect a fmp4 or an mpeg2-ts segment to determine the start\n     * and end of the segment in it's internal \"media time\". Used to generate\n     * mappings from that internal \"media time\" to the display time that is\n     * shown on the player.\n     *\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'probeSegmentInfo',\n    value: function probeSegmentInfo(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var playlist = segmentInfo.playlist;\n      var timingInfo = undefined;\n\n      if (segment.map) {\n        timingInfo = this.probeMp4Segment_(segmentInfo);\n      } else {\n        timingInfo = this.probeTsSegment_(segmentInfo);\n      }\n\n      if (timingInfo) {\n        if (this.calculateSegmentTimeMapping_(segmentInfo, timingInfo)) {\n          this.saveDiscontinuitySyncInfo_(segmentInfo);\n\n          // If the playlist does not have sync information yet, record that information\n          // now with segment timing information\n          if (!playlist.syncInfo) {\n            playlist.syncInfo = {\n              mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n              time: segment.start\n            };\n          }\n        }\n      }\n\n      return timingInfo;\n    }\n\n    /**\n     * Probe an fmp4 or an mpeg2-ts segment to determine the start of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeMp4Segment_',\n    value: function probeMp4Segment_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var timescales = _muxJsLibMp4Probe2['default'].timescale(segment.map.bytes);\n      var startTime = _muxJsLibMp4Probe2['default'].startTime(timescales, segmentInfo.bytes);\n\n      if (segmentInfo.timestampOffset !== null) {\n        segmentInfo.timestampOffset -= startTime;\n      }\n\n      return {\n        start: startTime,\n        end: startTime + segment.duration\n      };\n    }\n\n    /**\n     * Probe an mpeg2-ts segment to determine the start and end of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeTsSegment_',\n    value: function probeTsSegment_(segmentInfo) {\n      var timeInfo = (0, _muxJsLibToolsTsInspectorJs.inspect)(segmentInfo.bytes, this.inspectCache_);\n      var segmentStartTime = undefined;\n      var segmentEndTime = undefined;\n\n      if (!timeInfo) {\n        return null;\n      }\n\n      if (timeInfo.video && timeInfo.video.length === 2) {\n        this.inspectCache_ = timeInfo.video[1].dts;\n        segmentStartTime = timeInfo.video[0].dtsTime;\n        segmentEndTime = timeInfo.video[1].dtsTime;\n      } else if (timeInfo.audio && timeInfo.audio.length === 2) {\n        this.inspectCache_ = timeInfo.audio[1].dts;\n        segmentStartTime = timeInfo.audio[0].dtsTime;\n        segmentEndTime = timeInfo.audio[1].dtsTime;\n      }\n\n      return {\n        start: segmentStartTime,\n        end: segmentEndTime,\n        containsVideo: timeInfo.video && timeInfo.video.length === 2,\n        containsAudio: timeInfo.audio && timeInfo.audio.length === 2\n      };\n    }\n  }, {\n    key: 'timestampOffsetForTimeline',\n    value: function timestampOffsetForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].time;\n    }\n  }, {\n    key: 'mappingForTimeline',\n    value: function mappingForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].mapping;\n    }\n\n    /**\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n     * save that display time to the segment.\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo\n     *        The current active request information\n     * @param {object} timingInfo\n     *        The start and end time of the current segment in \"media time\"\n     * @returns {Boolean}\n     *          Returns false if segment time mapping could not be calculated\n     */\n  }, {\n    key: 'calculateSegmentTimeMapping_',\n    value: function calculateSegmentTimeMapping_(segmentInfo, timingInfo) {\n      var segment = segmentInfo.segment;\n      var mappingObj = this.timelines[segmentInfo.timeline];\n\n      if (segmentInfo.timestampOffset !== null) {\n        this.logger_('tsO:', segmentInfo.timestampOffset);\n\n        mappingObj = {\n          time: segmentInfo.startOfSegment,\n          mapping: segmentInfo.startOfSegment - timingInfo.start\n        };\n        this.timelines[segmentInfo.timeline] = mappingObj;\n        this.trigger('timestampoffset');\n\n        segment.start = segmentInfo.startOfSegment;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else if (mappingObj) {\n        segment.start = timingInfo.start + mappingObj.mapping;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\n     * in display of the start of the discontinuity and save that. We also save an accuracy\n     * value so that we save values with the most accuracy (closest to 0.)\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'saveDiscontinuitySyncInfo_',\n    value: function saveDiscontinuitySyncInfo_(segmentInfo) {\n      var playlist = segmentInfo.playlist;\n      var segment = segmentInfo.segment;\n\n      // If the current segment is a discontinuity then we know exactly where\n      // the start of the range and it's accuracy is 0 (greater accuracy values\n      // mean more approximation)\n      if (segment.discontinuity) {\n        this.discontinuities[segment.timeline] = {\n          time: segment.start,\n          accuracy: 0\n        };\n      } else if (playlist.discontinuityStarts.length) {\n        // Search for future discontinuities that we can provide better timing\n        // information for and save that information for sync purposes\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n          var segmentIndex = playlist.discontinuityStarts[i];\n          var discontinuity = playlist.discontinuitySequence + i + 1;\n          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n          var accuracy = Math.abs(mediaIndexDiff);\n\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n            var time = undefined;\n\n            if (mediaIndexDiff < 0) {\n              time = segment.start - (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex, segmentIndex);\n            } else {\n              time = segment.end + (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex + 1, segmentIndex);\n            }\n\n            this.discontinuities[discontinuity] = {\n              time: time,\n              accuracy: accuracy\n            };\n          }\n        }\n      }\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n  }]);\n\n  return SyncController;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = SyncController;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}