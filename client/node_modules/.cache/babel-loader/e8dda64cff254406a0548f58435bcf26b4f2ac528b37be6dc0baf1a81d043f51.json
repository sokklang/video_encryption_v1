{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\n// constants\nvar AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\nvar VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility'];\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n// Helper functions\nvar createDefaultSample, isLikelyAacData, collectDtsInfo, clearDtsInfo, calculateTrackBaseMediaDecodeTime, arrayEquals, sumFrameByteLengths;\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\ncreateDefaultSample = function () {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0\n    }\n  };\n};\nisLikelyAacData = function (data) {\n  if (data[0] === 'I'.charCodeAt(0) && data[1] === 'D'.charCodeAt(0) && data[2] === '3'.charCodeAt(0)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\narrayEquals = function (a, b) {\n  var i;\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nsumFrameByteLengths = function (array) {\n  var i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n  return sum;\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n */\nAudioSegmentStream = function (track) {\n  var adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n  AudioSegmentStream.prototype.init.call(this);\n  this.push = function (data) {\n    collectDtsInfo(track, data);\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function (prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n  this.setEarliestDts = function (earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n  this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n  this.setAudioAppendStart = function (timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n  this.flush = function () {\n    var frames, moof, mdat, boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n    this.prefixWithSilence_(track, frames);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = this.generateSampleTable_(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\n    adtsFrames = [];\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n    clearDtsInfo(track);\n    this.trigger('data', {\n      track: track,\n      boxes: boxes\n    });\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n  this.prefixWithSilence_ = function (track, frames) {\n    var baseMediaDecodeTimeTs,\n      frameDuration = 0,\n      audioGapDuration = 0,\n      audioFillFrameCount = 0,\n      audioFillDuration = 0,\n      silentFrame,\n      i;\n    if (!frames.length) {\n      return;\n    }\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n    // determine frame clock duration based on sample rate, round up to avoid overfills\n    frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n      // number of full frames in the audio gap\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    }\n\n    // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n    if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n    silentFrame = coneOfSilence[track.samplerate];\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n    for (i = 0; i < audioFillFrameCount; i++) {\n      frames.splice(i, 0, {\n        data: silentFrame\n      });\n    }\n    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n  };\n\n  // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n  this.trimAdtsFramesByEarliestDts_ = function (adtsFrames) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    }\n\n    // We will need to recalculate the earliest segment Dts\n    track.minSegmentDts = Infinity;\n    return adtsFrames.filter(function (currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      }\n      // Otherwise, discard it\n      return false;\n    });\n  };\n\n  // generate the track's raw mdat data from an array of frames\n  this.generateSampleTable_ = function (frames) {\n    var i,\n      currentFrame,\n      samples = [];\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n      });\n    }\n    return samples;\n  };\n\n  // generate the track's sample table from an array of frames\n  this.concatenateFrameData_ = function (frames) {\n    var i,\n      currentFrame,\n      dataOffset = 0,\n      data = new Uint8Array(sumFrameByteLengths(frames));\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n    return data;\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n */\nVideoSegmentStream = function (track, options) {\n  var sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n  options = options || {};\n  VideoSegmentStream.prototype.init.call(this);\n  delete track.minPTS;\n  this.gopCache_ = [];\n  this.push = function (nalUnit) {\n    collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n      VIDEO_PROPERTIES.forEach(function (prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n  this.flush = function () {\n    var frames, gopForFusion, gops, moof, mdat, boxes;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = this.groupNalsIntoFrames_(nalUnits);\n    gops = this.groupFramesIntoGops_(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n      if (gopForFusion) {\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyrame-pulling\n        gops = this.extendFirstKeyFrame_(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      clearDtsInfo(track);\n      gops = alignedGops;\n    }\n    collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = this.generateSampleTable_(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n    this.trigger('processedGopsInfo', gops.map(function (gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n    this.trigger('data', {\n      track: track,\n      boxes: boxes\n    });\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n  this.resetStream_ = function () {\n    clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function (nalUnit) {\n    var halfSecond = 45000,\n      // Half-a-second in a 90khz clock\n      allowableOverlap = 10000,\n      // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj || nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n  this.extendFirstKeyFrame_ = function (gops) {\n    var currentGop;\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n      gops.byteLength -= currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount;\n\n      // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n    return gops;\n  };\n\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  this.groupNalsIntoFrames_ = function (nalUnits) {\n    var i,\n      currentNal,\n      currentFrame = [],\n      frames = [];\n    currentFrame.byteLength = 0;\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i];\n\n      // Split on 'aud'-type nal units\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          frames.push(currentFrame);\n        }\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    }\n\n    // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    }\n\n    // Push the final frame\n    frames.push(currentFrame);\n    return frames;\n  };\n\n  // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n  this.groupFramesIntoGops_ = function (frames) {\n    var i,\n      currentFrame,\n      currentGop = [],\n      gops = [];\n\n    // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts;\n\n    // store some metadata about all the Gops\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration;\n\n    // push the final Gop\n    gops.push(currentGop);\n    return gops;\n  };\n\n  // generate the track's sample table from an array of gops\n  this.generateSampleTable_ = function (gops, baseDataOffset) {\n    var h,\n      i,\n      sample,\n      currentGop,\n      currentFrame,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n        sample = createDefaultSample();\n        sample.dataOffset = dataOffset;\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\n        sample.duration = currentFrame.duration;\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\n        sample.size += currentFrame.byteLength;\n        if (currentFrame.keyFrame) {\n          sample.flags.dependsOn = 2;\n        }\n        dataOffset += sample.size;\n        samples.push(sample);\n      }\n    }\n    return samples;\n  };\n\n  // generate the track's raw mdat data from an array of gops\n  this.concatenateNalData_ = function (gops) {\n    var h,\n      i,\n      j,\n      currentGop,\n      currentFrame,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = gops.byteLength,\n      numberOfNals = gops.nalCount,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer);\n\n    // For each Gop..\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      // For each Frame..\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        // For each NAL..\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n    return data;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function (gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n      if (align.pts === gop.pts) {\n        break;\n      }\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function (gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n      gopIndex--;\n    }\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n    var trimIndex;\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n    if (trimIndex === 0) {\n      return gops;\n    }\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function (total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, {\n      byteLength: 0,\n      duration: 0,\n      nalCount: 0\n    });\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n    return alignedGops;\n  };\n  this.alignGopsWith = function (newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectDtsInfo = function (track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nclearDtsInfo = function (track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n */\ncalculateTrackBaseMediaDecodeTime = function (track) {\n  var baseMediaDecodeTime,\n    scale,\n    // Calculate the distance, in time, that this segment starts from the start\n    // of the timeline (earliest time seen since the transmuxer initialized)\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts;\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += timeSinceStartOfTimeline;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n  return baseMediaDecodeTime;\n};\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n */\nCoalesceStream = function (options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function (output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function (flushSource) {\n  var offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function (prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function (prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n  this.emittedTracks += this.pendingTracks.length;\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function (options) {\n  var self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n  Transmuxer.prototype.init.call(this);\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n  this.setupAacPipeline = function () {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n    pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n    pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n    pipeline.metadataStream.on('timestamp', function (frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n    pipeline.aacStream.on('data', function (data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n  this.setupTsPipeline = function () {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream.pipe(pipeline.videoTimestampRolloverStream).pipe(pipeline.h264Stream);\n    pipeline.elementaryStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n    pipeline.elementaryStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n    pipeline.elementaryStream.on('data', function (data) {\n      var i;\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n          pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n            // When video emits timelineStartInfo data after a flush, we forward that\n            // info to the AudioSegmentStream, if it exists, because video timeline\n            // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n          pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n        }\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(audioTrack);\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n  this.setAudioAppendStart = function (timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n  this.alignGopsWith = function (gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function (data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function () {\n    hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function () {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n};\nTransmuxer.prototype = new Stream();\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\n};","map":{"version":3,"names":["Stream","require","mp4","m2ts","AdtsStream","H264Stream","AacStream","coneOfSilence","clock","AUDIO_PROPERTIES","VIDEO_PROPERTIES","ONE_SECOND_IN_TS","VideoSegmentStream","AudioSegmentStream","Transmuxer","CoalesceStream","createDefaultSample","isLikelyAacData","collectDtsInfo","clearDtsInfo","calculateTrackBaseMediaDecodeTime","arrayEquals","sumFrameByteLengths","size","flags","isLeading","dependsOn","isDependedOn","hasRedundancy","degradationPriority","data","charCodeAt","a","b","i","length","array","currentObj","sum","byteLength","track","adtsFrames","sequenceNumber","earliestAllowedDts","audioAppendStartTs","videoBaseMediaDecodeTime","Infinity","prototype","init","call","push","forEach","prop","setEarliestDts","earliestDts","timelineStartInfo","baseMediaDecodeTime","setVideoBaseMediaDecodeTime","setAudioAppendStart","timestamp","flush","frames","moof","mdat","boxes","trigger","trimAdtsFramesByEarliestDts_","prefixWithSilence_","samples","generateSampleTable_","concatenateFrameData_","Uint8Array","set","baseMediaDecodeTimeTs","frameDuration","audioGapDuration","audioFillFrameCount","audioFillDuration","silentFrame","audioTsToVideoTs","samplerate","Math","ceil","max","floor","splice","videoTsToAudioTs","minSegmentDts","filter","currentFrame","dts","min","minSegmentPts","duration","dataOffset","options","nalUnits","gopsToAlignWith","config","pps","minPTS","gopCache_","nalUnit","nalUnitType","sps","gopForFusion","gops","shift","resetStream_","groupNalsIntoFrames_","groupFramesIntoGops_","keyFrame","getGopForFusion_","unshift","nalCount","pts","extendFirstKeyFrame_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","pop","concatenateNalData_","map","undefined","halfSecond","allowableOverlap","nearestDistance","dtsDistance","nearestGopObj","currentGop","currentGopObj","currentNal","baseDataOffset","h","sample","compositionTimeOffset","j","nalsByteLength","numberOfNals","totalByteLength","view","DataView","buffer","setUint32","alignIndex","gopIndex","align","slice","alignEndIndex","matchFound","trimIndex","metadata","reduce","total","alignGopsWith","newGopsToAlignWith","maxSegmentPts","maxSegmentDts","scale","timeSinceStartOfTimeline","type","metadataStream","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","text","audioTrack","flushSource","offset","event","captions","captionStreams","info","caption","id3","initSegment","timelineStartPts","startTime","startPts","endTime","endPts","stream","cueTime","dispatchType","self","hasFlushed","transmuxPipeline_","setupAacPipeline","pipeline","MetadataStream","aacStream","audioTimestampRolloverStream","TimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","pipe","on","frame","setTimestamp","timeStamp","audioSegmentStream","codec","bind","setupTsPipeline","packetStream","TransportPacketStream","parseStream","TransportParseStream","elementaryStream","ElementaryStream","videoTimestampRolloverStream","h264Stream","captionStream","CaptionStream","tracks","videoSegmentStream","setBaseMediaDecodeTime","discontinuity","reset","isAac","resetCaptions","module","exports"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js"],"sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n// Helper functions\nvar\n  createDefaultSample,\n  isLikelyAacData,\n  collectDtsInfo,\n  clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime,\n  arrayEquals,\n  sumFrameByteLengths;\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\ncreateDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0\n    }\n  };\n};\n\nisLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\narrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nsumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.prefixWithSilence_(track, frames);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = this.generateSampleTable_(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n  this.prefixWithSilence_ = function(track, frames) {\n    var\n      baseMediaDecodeTimeTs,\n      frameDuration = 0,\n      audioGapDuration = 0,\n      audioFillFrameCount = 0,\n      audioFillDuration = 0,\n      silentFrame,\n      i;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n    // determine frame clock duration based on sample rate, round up to avoid overfills\n    frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration =\n        baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n      // number of full frames in the audio gap\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    }\n\n    // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n    if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = coneOfSilence[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      frames.splice(i, 0, {\n        data: silentFrame\n      });\n    }\n\n    track.baseMediaDecodeTime -=\n      Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n  };\n\n  // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n  this.trimAdtsFramesByEarliestDts_ = function(adtsFrames) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    }\n\n    // We will need to recalculate the earliest segment Dts\n    track.minSegmentDts = Infinity;\n\n    return adtsFrames.filter(function(currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      }\n      // Otherwise, discard it\n      return false;\n    });\n  };\n\n  // generate the track's raw mdat data from an array of frames\n  this.generateSampleTable_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n      });\n    }\n    return samples;\n  };\n\n  // generate the track's sample table from an array of frames\n  this.concatenateFrameData_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      dataOffset = 0,\n      data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n    return data;\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  this.push = function(nalUnit) {\n    collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = this.groupNalsIntoFrames_(nalUnits);\n    gops = this.groupFramesIntoGops_(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyrame-pulling\n        gops = this.extendFirstKeyFrame_(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = this.generateSampleTable_(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\n\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  this.extendFirstKeyFrame_ = function(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n\n      gops.byteLength -=  currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount;\n\n      // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  this.groupNalsIntoFrames_ = function(nalUnits) {\n    var\n      i,\n      currentNal,\n      currentFrame = [],\n      frames = [];\n\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i];\n\n      // Split on 'aud'-type nal units\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          frames.push(currentFrame);\n        }\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    }\n\n    // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n    if (frames.length &&\n        (!currentFrame.duration ||\n         currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    }\n\n    // Push the final frame\n    frames.push(currentFrame);\n    return frames;\n  };\n\n  // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n  this.groupFramesIntoGops_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      currentGop = [],\n      gops = [];\n\n    // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts;\n\n    // store some metadata about all the Gops\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration;\n\n    // push the final Gop\n    gops.push(currentGop);\n    return gops;\n  };\n\n  // generate the track's sample table from an array of gops\n  this.generateSampleTable_ = function(gops, baseDataOffset) {\n    var\n      h, i,\n      sample,\n      currentGop,\n      currentFrame,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        sample = createDefaultSample();\n\n        sample.dataOffset = dataOffset;\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\n        sample.duration = currentFrame.duration;\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\n        sample.size += currentFrame.byteLength;\n\n        if (currentFrame.keyFrame) {\n          sample.flags.dependsOn = 2;\n        }\n\n        dataOffset += sample.size;\n\n        samples.push(sample);\n      }\n    }\n    return samples;\n  };\n\n  // generate the track's raw mdat data from an array of gops\n  this.concatenateNalData_ = function(gops) {\n    var\n      h, i, j,\n      currentGop,\n      currentFrame,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = gops.byteLength,\n      numberOfNals = gops.nalCount,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer);\n\n    // For each Gop..\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      // For each Frame..\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        // For each NAL..\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n    return data;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nclearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n */\ncalculateTrackBaseMediaDecodeTime = function(track) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    // Calculate the distance, in time, that this segment starts from the start\n    // of the timeline (earliest time seen since the transmuxer initialized)\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts;\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += timeSinceStartOfTimeline;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = (caption.startPts - timelineStartPts);\n    caption.startTime /= 90e3;\n    caption.endTime = (caption.endPts - timelineStartPts);\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = (id3.pts - timelineStartPts);\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(audioTrack);\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}