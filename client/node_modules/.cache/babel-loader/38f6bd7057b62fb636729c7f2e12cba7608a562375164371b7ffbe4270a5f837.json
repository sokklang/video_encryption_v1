{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\nvar _videoJs = require('video.js');\nvar _videoJs2 = _interopRequireDefault(_videoJs);\nvar _binUtils = require('./bin-utils');\nvar REQUEST_ERRORS = {\n  FAILURE: 2,\n  TIMEOUT: -101,\n  ABORTED: -102\n};\nexports.REQUEST_ERRORS = REQUEST_ERRORS;\n/**\n * Turns segment byterange into a string suitable for use in\n * HTTP Range requests\n *\n * @param {Object} byterange - an object with two values defining the start and end\n *                             of a byte-range\n */\nvar byterangeStr = function byterangeStr(byterange) {\n  var byterangeStart = undefined;\n  var byterangeEnd = undefined;\n\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  byterangeEnd = byterange.offset + byterange.length - 1;\n  byterangeStart = byterange.offset;\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n};\n\n/**\n * Defines headers for use in the xhr request for a particular segment.\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n */\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\n  var headers = {};\n  if (segment.byterange) {\n    headers.Range = byterangeStr(segment.byterange);\n  }\n  return headers;\n};\n\n/**\n * Abort all requests\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n */\nvar abortAll = function abortAll(activeXhrs) {\n  activeXhrs.forEach(function (xhr) {\n    xhr.abort();\n  });\n};\n\n/**\n * Gather important bandwidth stats once a request has completed\n *\n * @param {Object} request - the XHR request from which to gather stats\n */\nvar getRequestStats = function getRequestStats(request) {\n  return {\n    bandwidth: request.bandwidth,\n    bytesReceived: request.bytesReceived || 0,\n    roundTripTime: request.roundTripTime || 0\n  };\n};\n\n/**\n * If possible gather bandwidth stats as a request is in\n * progress\n *\n * @param {Event} progressEvent - an event object from an XHR's progress event\n */\nvar getProgressStats = function getProgressStats(progressEvent) {\n  var request = progressEvent.target;\n  var roundTripTime = Date.now() - request.requestTime;\n  var stats = {\n    bandwidth: Infinity,\n    bytesReceived: 0,\n    roundTripTime: roundTripTime || 0\n  };\n  stats.bytesReceived = progressEvent.loaded;\n  // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n  // because we should only use bandwidth stats on progress to determine when\n  // abort a request early due to insufficient bandwidth\n  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n  return stats;\n};\n\n/**\n * Handle all error conditions in one place and return an object\n * with all the information\n *\n * @param {Error|null} error - if non-null signals an error occured with the XHR\n * @param {Object} request -  the XHR request that possibly generated the error\n */\nvar handleErrors = function handleErrors(error, request) {\n  if (request.timedout) {\n    return {\n      status: request.status,\n      message: 'HLS request timed-out at URL: ' + request.uri,\n      code: REQUEST_ERRORS.TIMEOUT,\n      xhr: request\n    };\n  }\n  if (request.aborted) {\n    return {\n      status: request.status,\n      message: 'HLS request aborted at URL: ' + request.uri,\n      code: REQUEST_ERRORS.ABORTED,\n      xhr: request\n    };\n  }\n  if (error) {\n    return {\n      status: request.status,\n      message: 'HLS request errored at URL: ' + request.uri,\n      code: REQUEST_ERRORS.FAILURE,\n      xhr: request\n    };\n  }\n  return null;\n};\n\n/**\n * Handle responses for key data and convert the key data to the correct format\n * for the decryption step later\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleKeyResponse = function handleKeyResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n    var view = new DataView(response);\n    segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Handle init-segment responses\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleInitSegmentResponse = function handleInitSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n    segment.map.bytes = new Uint8Array(request.response);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Response handler for segment-requests being sure to set the correct\n * property depending on whether the segment is encryped or not\n * Also records and keeps track of stats that are used for ABR purposes\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleSegmentResponse = function handleSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n    segment.stats = getRequestStats(request);\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(request.response);\n    } else {\n      segment.bytes = new Uint8Array(request.response);\n    }\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Decrypt the segment via the decryption web worker\n *\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} doneFn - a callback that is executed after decryption has completed\n */\nvar decryptSegment = function decryptSegment(decrypter, segment, doneFn) {\n  var decryptionHandler = function decryptionHandler(event) {\n    if (event.data.source === segment.requestId) {\n      decrypter.removeEventListener('message', decryptionHandler);\n      var decrypted = event.data.decrypted;\n      segment.bytes = new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength);\n      return doneFn(null, segment);\n    }\n  };\n  decrypter.addEventListener('message', decryptionHandler);\n\n  // this is an encrypted segment\n  // incrementally decrypt the segment\n  decrypter.postMessage((0, _binUtils.createTransferableMessage)({\n    source: segment.requestId,\n    encrypted: segment.encryptedBytes,\n    key: segment.key.bytes,\n    iv: segment.key.iv\n  }), [segment.encryptedBytes.buffer, segment.key.bytes.buffer]);\n};\n\n/**\n * The purpose of this function is to get the most pertinent error from the\n * array of errors.\n * For instance if a timeout and two aborts occur, then the aborts were\n * likely triggered by the timeout so return that error object.\n */\nvar getMostImportantError = function getMostImportantError(errors) {\n  return errors.reduce(function (prev, err) {\n    return err.code > prev.code ? err : prev;\n  });\n};\n\n/**\n * This function waits for all XHRs to finish (with either success or failure)\n * before continueing processing via it's callback. The function gathers errors\n * from each request into a single errors array so that the error status for\n * each request can be examined later.\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Function} doneFn - a callback that is executed after all resources have been\n *                            downloaded and any decryption completed\n */\nvar waitForCompletion = function waitForCompletion(activeXhrs, decrypter, doneFn) {\n  var errors = [];\n  var count = 0;\n  return function (error, segment) {\n    if (error) {\n      // If there are errors, we have to abort any outstanding requests\n      abortAll(activeXhrs);\n      errors.push(error);\n    }\n    count += 1;\n    if (count === activeXhrs.length) {\n      // Keep track of when *all* of the requests have completed\n      segment.endOfAllRequests = Date.now();\n      if (errors.length > 0) {\n        var worstError = getMostImportantError(errors);\n        return doneFn(worstError, segment);\n      }\n      if (segment.encryptedBytes) {\n        return decryptSegment(decrypter, segment, doneFn);\n      }\n      // Otherwise, everything is ready just continue\n      return doneFn(null, segment);\n    }\n  };\n};\n\n/**\n * Simple progress event callback handler that gathers some stats before\n * executing a provided callback with the `segment` object\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that is executed each time a progress event\n *                                is received\n * @param {Event} event - the progress event object from XMLHttpRequest\n */\nvar handleProgress = function handleProgress(segment, progressFn) {\n  return function (event) {\n    segment.stats = _videoJs2['default'].mergeOptions(segment.stats, getProgressStats(event));\n\n    // record the time that we receive the first byte of data\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n    return progressFn(event, segment);\n  };\n};\n\n/**\n * Load all resources and does any processing necessary for a media-segment\n *\n * Features:\n *   decrypts the media-segment if it has a key uri and an iv\n *   aborts *all* requests if *any* one request fails\n *\n * The segment object, at minimum, has the following format:\n * {\n *   resolvedUri: String,\n *   [byterange]: {\n *     offset: Number,\n *     length: Number\n *   },\n *   [key]: {\n *     resolvedUri: String\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     iv: {\n *       bytes: Uint32Array\n *     }\n *   },\n *   [map]: {\n *     resolvedUri: String,\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     [bytes]: Uint8Array\n *   }\n * }\n * ...where [name] denotes optional properties\n *\n * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n * @param {Object} xhrOptions - the base options to provide to all xhr requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n *                                       decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that receives progress events from the main\n *                                segment's xhr request\n * @param {Function} doneFn - a callback that is executed only once all requests have\n *                            succeeded or failed\n * @returns {Function} a function that, when invoked, immediately aborts all\n *                     outstanding requests\n */\nvar mediaSegmentRequest = function mediaSegmentRequest(xhr, xhrOptions, decryptionWorker, segment, progressFn, doneFn) {\n  var activeXhrs = [];\n  var finishProcessingFn = waitForCompletion(activeXhrs, decryptionWorker, doneFn);\n\n  // optionally, request the decryption key\n  if (segment.key) {\n    var keyRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.key.resolvedUri,\n      responseType: 'arraybuffer'\n    });\n    var keyRequestCallback = handleKeyResponse(segment, finishProcessingFn);\n    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n    activeXhrs.push(keyXhr);\n  }\n\n  // optionally, request the associated media init segment\n  if (segment.map && !segment.map.bytes) {\n    var initSegmentOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.map.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment.map)\n    });\n    var initSegmentRequestCallback = handleInitSegmentResponse(segment, finishProcessingFn);\n    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n    activeXhrs.push(initSegmentXhr);\n  }\n  var segmentRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n    uri: segment.resolvedUri,\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(segment)\n  });\n  var segmentRequestCallback = handleSegmentResponse(segment, finishProcessingFn);\n  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n  segmentXhr.addEventListener('progress', handleProgress(segment, progressFn));\n  activeXhrs.push(segmentXhr);\n  return function () {\n    return abortAll(activeXhrs);\n  };\n};\nexports.mediaSegmentRequest = mediaSegmentRequest;","map":{"version":3,"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_videoJs","require","_videoJs2","_binUtils","REQUEST_ERRORS","FAILURE","TIMEOUT","ABORTED","byterangeStr","byterange","byterangeStart","undefined","byterangeEnd","offset","length","segmentXhrHeaders","segment","headers","Range","abortAll","activeXhrs","forEach","xhr","abort","getRequestStats","request","bandwidth","bytesReceived","roundTripTime","getProgressStats","progressEvent","target","Date","now","requestTime","stats","Infinity","loaded","Math","floor","handleErrors","error","timedout","status","message","uri","code","aborted","handleKeyResponse","finishProcessingFn","response","errorObj","byteLength","view","DataView","key","bytes","Uint32Array","getUint32","handleInitSegmentResponse","map","Uint8Array","handleSegmentResponse","encryptedBytes","decryptSegment","decrypter","doneFn","decryptionHandler","event","data","source","requestId","removeEventListener","decrypted","byteOffset","addEventListener","postMessage","createTransferableMessage","encrypted","iv","buffer","getMostImportantError","errors","reduce","prev","err","waitForCompletion","count","push","endOfAllRequests","worstError","handleProgress","progressFn","mergeOptions","firstBytesReceivedAt","mediaSegmentRequest","xhrOptions","decryptionWorker","keyRequestOptions","resolvedUri","responseType","keyRequestCallback","keyXhr","initSegmentOptions","initSegmentRequestCallback","initSegmentXhr","segmentRequestOptions","segmentRequestCallback","segmentXhr"],"sources":["C:/Users/J3adl30y/Desktop/videostreaming/client/node_modules/videojs-contrib-hls/es5/media-segment-request.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = require('video.js');\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar REQUEST_ERRORS = {\n  FAILURE: 2,\n  TIMEOUT: -101,\n  ABORTED: -102\n};\n\nexports.REQUEST_ERRORS = REQUEST_ERRORS;\n/**\n * Turns segment byterange into a string suitable for use in\n * HTTP Range requests\n *\n * @param {Object} byterange - an object with two values defining the start and end\n *                             of a byte-range\n */\nvar byterangeStr = function byterangeStr(byterange) {\n  var byterangeStart = undefined;\n  var byterangeEnd = undefined;\n\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  byterangeEnd = byterange.offset + byterange.length - 1;\n  byterangeStart = byterange.offset;\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n};\n\n/**\n * Defines headers for use in the xhr request for a particular segment.\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n */\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\n  var headers = {};\n\n  if (segment.byterange) {\n    headers.Range = byterangeStr(segment.byterange);\n  }\n  return headers;\n};\n\n/**\n * Abort all requests\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n */\nvar abortAll = function abortAll(activeXhrs) {\n  activeXhrs.forEach(function (xhr) {\n    xhr.abort();\n  });\n};\n\n/**\n * Gather important bandwidth stats once a request has completed\n *\n * @param {Object} request - the XHR request from which to gather stats\n */\nvar getRequestStats = function getRequestStats(request) {\n  return {\n    bandwidth: request.bandwidth,\n    bytesReceived: request.bytesReceived || 0,\n    roundTripTime: request.roundTripTime || 0\n  };\n};\n\n/**\n * If possible gather bandwidth stats as a request is in\n * progress\n *\n * @param {Event} progressEvent - an event object from an XHR's progress event\n */\nvar getProgressStats = function getProgressStats(progressEvent) {\n  var request = progressEvent.target;\n  var roundTripTime = Date.now() - request.requestTime;\n  var stats = {\n    bandwidth: Infinity,\n    bytesReceived: 0,\n    roundTripTime: roundTripTime || 0\n  };\n\n  stats.bytesReceived = progressEvent.loaded;\n  // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n  // because we should only use bandwidth stats on progress to determine when\n  // abort a request early due to insufficient bandwidth\n  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n\n  return stats;\n};\n\n/**\n * Handle all error conditions in one place and return an object\n * with all the information\n *\n * @param {Error|null} error - if non-null signals an error occured with the XHR\n * @param {Object} request -  the XHR request that possibly generated the error\n */\nvar handleErrors = function handleErrors(error, request) {\n  if (request.timedout) {\n    return {\n      status: request.status,\n      message: 'HLS request timed-out at URL: ' + request.uri,\n      code: REQUEST_ERRORS.TIMEOUT,\n      xhr: request\n    };\n  }\n\n  if (request.aborted) {\n    return {\n      status: request.status,\n      message: 'HLS request aborted at URL: ' + request.uri,\n      code: REQUEST_ERRORS.ABORTED,\n      xhr: request\n    };\n  }\n\n  if (error) {\n    return {\n      status: request.status,\n      message: 'HLS request errored at URL: ' + request.uri,\n      code: REQUEST_ERRORS.FAILURE,\n      xhr: request\n    };\n  }\n\n  return null;\n};\n\n/**\n * Handle responses for key data and convert the key data to the correct format\n * for the decryption step later\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleKeyResponse = function handleKeyResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    var view = new DataView(response);\n\n    segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Handle init-segment responses\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleInitSegmentResponse = function handleInitSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.map.bytes = new Uint8Array(request.response);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Response handler for segment-requests being sure to set the correct\n * property depending on whether the segment is encryped or not\n * Also records and keeps track of stats that are used for ABR purposes\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleSegmentResponse = function handleSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.stats = getRequestStats(request);\n\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(request.response);\n    } else {\n      segment.bytes = new Uint8Array(request.response);\n    }\n\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Decrypt the segment via the decryption web worker\n *\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} doneFn - a callback that is executed after decryption has completed\n */\nvar decryptSegment = function decryptSegment(decrypter, segment, doneFn) {\n  var decryptionHandler = function decryptionHandler(event) {\n    if (event.data.source === segment.requestId) {\n      decrypter.removeEventListener('message', decryptionHandler);\n      var decrypted = event.data.decrypted;\n\n      segment.bytes = new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength);\n      return doneFn(null, segment);\n    }\n  };\n\n  decrypter.addEventListener('message', decryptionHandler);\n\n  // this is an encrypted segment\n  // incrementally decrypt the segment\n  decrypter.postMessage((0, _binUtils.createTransferableMessage)({\n    source: segment.requestId,\n    encrypted: segment.encryptedBytes,\n    key: segment.key.bytes,\n    iv: segment.key.iv\n  }), [segment.encryptedBytes.buffer, segment.key.bytes.buffer]);\n};\n\n/**\n * The purpose of this function is to get the most pertinent error from the\n * array of errors.\n * For instance if a timeout and two aborts occur, then the aborts were\n * likely triggered by the timeout so return that error object.\n */\nvar getMostImportantError = function getMostImportantError(errors) {\n  return errors.reduce(function (prev, err) {\n    return err.code > prev.code ? err : prev;\n  });\n};\n\n/**\n * This function waits for all XHRs to finish (with either success or failure)\n * before continueing processing via it's callback. The function gathers errors\n * from each request into a single errors array so that the error status for\n * each request can be examined later.\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Function} doneFn - a callback that is executed after all resources have been\n *                            downloaded and any decryption completed\n */\nvar waitForCompletion = function waitForCompletion(activeXhrs, decrypter, doneFn) {\n  var errors = [];\n  var count = 0;\n\n  return function (error, segment) {\n    if (error) {\n      // If there are errors, we have to abort any outstanding requests\n      abortAll(activeXhrs);\n      errors.push(error);\n    }\n    count += 1;\n\n    if (count === activeXhrs.length) {\n      // Keep track of when *all* of the requests have completed\n      segment.endOfAllRequests = Date.now();\n\n      if (errors.length > 0) {\n        var worstError = getMostImportantError(errors);\n\n        return doneFn(worstError, segment);\n      }\n      if (segment.encryptedBytes) {\n        return decryptSegment(decrypter, segment, doneFn);\n      }\n      // Otherwise, everything is ready just continue\n      return doneFn(null, segment);\n    }\n  };\n};\n\n/**\n * Simple progress event callback handler that gathers some stats before\n * executing a provided callback with the `segment` object\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that is executed each time a progress event\n *                                is received\n * @param {Event} event - the progress event object from XMLHttpRequest\n */\nvar handleProgress = function handleProgress(segment, progressFn) {\n  return function (event) {\n    segment.stats = _videoJs2['default'].mergeOptions(segment.stats, getProgressStats(event));\n\n    // record the time that we receive the first byte of data\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n\n    return progressFn(event, segment);\n  };\n};\n\n/**\n * Load all resources and does any processing necessary for a media-segment\n *\n * Features:\n *   decrypts the media-segment if it has a key uri and an iv\n *   aborts *all* requests if *any* one request fails\n *\n * The segment object, at minimum, has the following format:\n * {\n *   resolvedUri: String,\n *   [byterange]: {\n *     offset: Number,\n *     length: Number\n *   },\n *   [key]: {\n *     resolvedUri: String\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     iv: {\n *       bytes: Uint32Array\n *     }\n *   },\n *   [map]: {\n *     resolvedUri: String,\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     [bytes]: Uint8Array\n *   }\n * }\n * ...where [name] denotes optional properties\n *\n * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n * @param {Object} xhrOptions - the base options to provide to all xhr requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n *                                       decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that receives progress events from the main\n *                                segment's xhr request\n * @param {Function} doneFn - a callback that is executed only once all requests have\n *                            succeeded or failed\n * @returns {Function} a function that, when invoked, immediately aborts all\n *                     outstanding requests\n */\nvar mediaSegmentRequest = function mediaSegmentRequest(xhr, xhrOptions, decryptionWorker, segment, progressFn, doneFn) {\n  var activeXhrs = [];\n  var finishProcessingFn = waitForCompletion(activeXhrs, decryptionWorker, doneFn);\n\n  // optionally, request the decryption key\n  if (segment.key) {\n    var keyRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.key.resolvedUri,\n      responseType: 'arraybuffer'\n    });\n    var keyRequestCallback = handleKeyResponse(segment, finishProcessingFn);\n    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n\n    activeXhrs.push(keyXhr);\n  }\n\n  // optionally, request the associated media init segment\n  if (segment.map && !segment.map.bytes) {\n    var initSegmentOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.map.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment.map)\n    });\n    var initSegmentRequestCallback = handleInitSegmentResponse(segment, finishProcessingFn);\n    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n\n    activeXhrs.push(initSegmentXhr);\n  }\n\n  var segmentRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n    uri: segment.resolvedUri,\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(segment)\n  });\n  var segmentRequestCallback = handleSegmentResponse(segment, finishProcessingFn);\n  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n\n  segmentXhr.addEventListener('progress', handleProgress(segment, progressFn));\n  activeXhrs.push(segmentXhr);\n\n  return function () {\n    return abortAll(activeXhrs);\n  };\n};\nexports.mediaSegmentRequest = mediaSegmentRequest;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}